X,y
"package com.google.devtools.build.lib.metrics;



import com.google.common.collect.ImmutableMap;

import com.google.common.eventbus.AllowConcurrentEvents;

import com.google.common.eventbus.Subscribe;

import com.google.devtools.build.lib.actions.ActionCompletionEvent;

import com.google.devtools.build.lib.actions.ActionResultReceivedEvent;

import com.google.devtools.build.lib.actions.AnalysisGraphStatsEvent;

import com.google.devtools.build.lib.actions.TotalAndConfiguredTargetOnlyMetric;

import com.google.devtools.build.lib.actions.cache.Protos.ActionCacheStatistics;

import com.google.devtools.build.lib.analysis.AnalysisPhaseCompleteEvent;

import com.google.devtools.build.lib.analysis.AnalysisPhaseStartedEvent;

import com.google.devtools.build.lib.analysis.NoBuildRequestFinishedEvent;

import com.google.devtools.build.lib.bugreport.BugReport;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.ActionSummary;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.ActionSummary.ActionData;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.ActionSummary.RunnerCount;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.ArtifactMetrics;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.BuildGraphMetrics;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.CumulativeMetrics;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.MemoryMetrics;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.MemoryMetrics.GarbageMetrics;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.NetworkMetrics;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.PackageMetrics;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.TargetMetrics;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.TimingMetrics;

import com.google.devtools.build.lib.buildeventstream.BuildEventStreamProtos.BuildMetrics.WorkerPoolMetrics;

import com.google.devtools.build.lib.buildtool.BuildPrecompleteEvent;

import com.google.devtools.build.lib.buildtool.buildevent.ExecutionStartingEvent;

import com.google.devtools.build.lib.clock.BlazeClock;

import com.google.devtools.build.lib.clock.BlazeClock.NanosToMillisSinceEpochConverter;

import com.google.devtools.build.lib.metrics.MetricsModule.Options;

import com.google.devtools.build.lib.metrics.PostGCMemoryUseRecorder.PeakHeap;

import com.google.devtools.build.lib.packages.metrics.ExtremaPackageMetricsRecorder;

import com.google.devtools.build.lib.packages.metrics.PackageLoadMetrics;

import com.google.devtools.build.lib.packages.metrics.PackageMetricsPackageLoadingListener;

import com.google.devtools.build.lib.packages.metrics.PackageMetricsRecorder;

import com.google.devtools.build.lib.profiler.MemoryProfiler;

import com.google.devtools.build.lib.profiler.NetworkMetricsCollector;

import com.google.devtools.build.lib.profiler.Profiler;

import com.google.devtools.build.lib.runtime.CommandEnvironment;

import com.google.devtools.build.lib.runtime.SpawnStats;

import com.google.devtools.build.lib.skyframe.ExecutionFinishedEvent;

import com.google.devtools.build.lib.skyframe.TopLevelStatusEvents.TopLevelTargetPendingExecutionEvent;

import com.google.devtools.build.lib.worker.WorkerCreatedEvent;

import com.google.devtools.build.lib.worker.WorkerDestroyedEvent;

import com.google.devtools.build.lib.worker.WorkerEvictedEvent;

import com.google.devtools.build.lib.worker.WorkerMetricsCollector;

import com.google.devtools.build.skyframe.SkyframeGraphStatsEvent;

import com.google.errorprone.annotations.CanIgnoreReturnValue;

import com.google.protobuf.util.Durations;

import java.time.Duration;

import java.util.Comparator;

import java.util.HashMap;

import java.util.Map;

import java.util.concurrent.ConcurrentHashMap;

import java.util.concurrent.atomic.AtomicBoolean;

import java.util.concurrent.atomic.AtomicInteger;

import java.util.concurrent.atomic.AtomicLong;

import java.util.concurrent.atomic.LongAccumulator;

import java.util.stream.Stream;


class MetricsCollector {


private final CommandEnvironment env;

private final boolean recordMetricsForAllMnemonics;

// For ActionSummary.

private final ConcurrentHashMap<String, ActionStats> actionStatsMap = new ConcurrentHashMap<>();

// Mapping from worker pool hash, to statistics which we collect during a build.

private final HashMap<Integer, WorkerPoolStats> workerPoolStats = new HashMap<>();


// For CumulativeMetrics.

private final AtomicInteger numAnalyses;

private final AtomicInteger numBuilds;


private final ActionSummary.Builder actionSummary = ActionSummary.newBuilder();

private final TargetMetrics.Builder targetMetrics = TargetMetrics.newBuilder();

private final PackageMetrics.Builder packageMetrics = PackageMetrics.newBuilder();

private final TimingMetrics.Builder timingMetrics = TimingMetrics.newBuilder();

private final ArtifactMetrics.Builder artifactMetrics = ArtifactMetrics.newBuilder();

private final BuildGraphMetrics.Builder buildGraphMetrics = BuildGraphMetrics.newBuilder();

private final SpawnStats spawnStats = new SpawnStats();

// Skymeld-specific: we don't have an ExecutionStartingEvent for skymeld, so we have to use

// TopLevelTargetExecutionStartedEvent. This AtomicBoolean is so that we only account for the

// build once.

private final AtomicBoolean buildAccountedFor;

private long executionStartMillis;


@CanIgnoreReturnValue

private MetricsCollector(

CommandEnvironment env, AtomicInteger numAnalyses, AtomicInteger numBuilds) {

this.env = env;

Options options = env.getOptions().getOptions(Options.class);

this.recordMetricsForAllMnemonics = options != null && options.recordMetricsForAllMnemonics;

this.numAnalyses = numAnalyses;

this.numBuilds = numBuilds;

env.getEventBus().register(this);

WorkerMetricsCollector.instance().setClock(env.getClock());

this.buildAccountedFor = new AtomicBoolean();

}


static void installInEnv(

CommandEnvironment env, AtomicInteger numAnalyses, AtomicInteger numBuilds) {

new MetricsCollector(env, numAnalyses, numBuilds);

}


@SuppressWarnings(""unused"")

@Subscribe

public synchronized void logAnalysisStartingEvent(AnalysisPhaseStartedEvent event) {

numAnalyses.getAndIncrement();

}


@SuppressWarnings(""unused"")

@Subscribe

public void onAnalysisPhaseComplete(AnalysisPhaseCompleteEvent event) {

TotalAndConfiguredTargetOnlyMetric actionsConstructed = event.getActionsConstructed();

actionSummary

.setActionsCreated(actionsConstructed.total())

.setActionsCreatedNotIncludingAspects(actionsConstructed.configuredTargetsOnly());

TotalAndConfiguredTargetOnlyMetric targetsConfigured = event.getTargetsConfigured();

targetMetrics

.setTargetsConfigured(targetsConfigured.total())

.setTargetsConfiguredNotIncludingAspects(targetsConfigured.configuredTargetsOnly());

timingMetrics.setAnalysisPhaseTimeInMs(event.getTimeInMs());


packageMetrics.setPackagesLoaded(event.getPkgManagerStats().getPackagesSuccessfullyLoaded());


if (PackageMetricsPackageLoadingListener.getInstance().getPublishPackageMetricsInBep()) {

PackageMetricsRecorder recorder =

PackageMetricsPackageLoadingListener.getInstance().getPackageMetricsRecorder();

if (recorder != null) {

Stream<PackageLoadMetrics> metrics = recorder.getPackageLoadMetrics().stream();


if (recorder.getRecorderType() == PackageMetricsRecorder.Type.ONLY_EXTREMES) {

ExtremaPackageMetricsRecorder extremaPackageMetricsRecorder =

(ExtremaPackageMetricsRecorder) recorder;

// Safeguard: we have 5 metrics, so print at most 5 times the number of packages as being

// tracked per metric.

metrics = metrics.limit(5L * extremaPackageMetricsRecorder.getNumPackagesToTrack());

}

metrics.forEach(packageMetrics::addPackageLoadMetrics);

}

}

}


private void markExecutionPhaseStarted() {

executionStartMillis = BlazeClock.instance().currentTimeMillis();

}


@SuppressWarnings(""unused"")

@Subscribe

public synchronized void logAnalysisGraphStats(AnalysisGraphStatsEvent event) {

// Check only one event per build. No proto3 check for presence, so check for not-default value.

if (buildGraphMetrics.getActionLookupValueCount() > 0) {

BugReport.sendBugReport(

new IllegalStateException(

""Already initialized build graph metrics builder: ""

+ buildGraphMetrics

+ "", ""

+ event.getBuildGraphMetrics()));

}

buildGraphMetrics.mergeFrom(event.getBuildGraphMetrics());

}


@SuppressWarnings(""unused"")

@Subscribe

public synchronized void logExecutionStartingEvent(ExecutionStartingEvent event) {

markExecutionPhaseStarted();

numBuilds.getAndIncrement();

}


// Skymeld-specific: we don't have an ExecutionStartingEvent for skymeld, so we have to use

// TopLevelTargetExecutionStartedEvent

@Subscribe

public synchronized void handleExecutionPhaseStart(

@SuppressWarnings(""unused"") TopLevelTargetPendingExecutionEvent event) {

if (buildAccountedFor.compareAndSet(/*expectedValue=*/ false, /*newValue=*/ true)) {

markExecutionPhaseStarted();

numBuilds.getAndIncrement();

}

}


@Subscribe

public void onWorkerDestroyed(WorkerDestroyedEvent event) {

synchronized (this) {

WorkerPoolStats stats =

getWorkerPoolStatsOrInsert(event.getWorkerPoolHash(), event.getMnemonic());


stats.incrementDestroyedCount();

}

}


@Subscribe

public void onWorkerCreated(WorkerCreatedEvent event) {

synchronized (this) {

WorkerPoolStats stats =

getWorkerPoolStatsOrInsert(event.getWorkerPoolHash(), event.getMnemonic());


stats.incrementCreatedCount();

}

}


@Subscribe

public void onWorkerEvicted(WorkerEvictedEvent event) {

synchronized (this) {

WorkerPoolStats stats =

getWorkerPoolStatsOrInsert(event.getWorkerPoolHash(), event.getMnemonic());


stats.incrementEvictedCount();

}

}


private WorkerPoolStats getWorkerPoolStatsOrInsert(int workerPoolHash, String mnemonic) {

WorkerPoolStats stats =

workerPoolStats.computeIfAbsent(

workerPoolHash, (Integer k) -> new WorkerPoolStats(mnemonic));


return stats;

}


@SuppressWarnings(""unused"")

@Subscribe

@AllowConcurrentEvents

public void onActionComplete(ActionCompletionEvent event) {

ActionStats actionStats =

actionStatsMap.computeIfAbsent(event.getAction().getMnemonic(), ActionStats::new);

actionStats.numActions.incrementAndGet();

actionStats.firstStarted.accumulate(event.getRelativeActionStartTimeNanos());

actionStats.lastEnded.accumulate(BlazeClock.nanoTime());

spawnStats.incrementActionCount();

}


@Subscribe

@AllowConcurrentEvents

public void actionResultReceived(ActionResultReceivedEvent event) {

spawnStats.countActionResult(event.getActionResult());

ActionStats actionStats =

actionStatsMap.computeIfAbsent(event.getAction().getMnemonic(), ActionStats::new);

int systemTime = event.getActionResult().cumulativeCommandExecutionSystemTimeInMs();

if (systemTime > 0) {

actionStats.systemTime.addAndGet(systemTime);

}

int userTime = event.getActionResult().cumulativeCommandExecutionUserTimeInMs();

if (userTime > 0) {

actionStats.userTime.addAndGet(userTime);

}

}


@SuppressWarnings(""unused"")

@Subscribe

public void onExecutionComplete(ExecutionFinishedEvent event) {

timingMetrics.setExecutionPhaseTimeInMs(

BlazeClock.instance().currentTimeMillis() - executionStartMillis);

artifactMetrics

.setSourceArtifactsRead(event.sourceArtifactsRead())

.setOutputArtifactsSeen(event.outputArtifactsSeen())

.setOutputArtifactsFromActionCache(event.outputArtifactsFromActionCache())

.setTopLevelArtifacts(event.topLevelArtifacts());

}


@SuppressWarnings(""unused"")

@Subscribe

public void onSkyframeGraphStats(SkyframeGraphStatsEvent event) {

buildGraphMetrics.setPostInvocationSkyframeNodeCount(event.getGraphSize());

}


@SuppressWarnings(""unused"")

@Subscribe

public void onBuildComplete(BuildPrecompleteEvent event) {

postBuildMetricsEvent();

}


@SuppressWarnings(""unused"") // Used reflectively

@Subscribe

public void onNoBuildRequestFinishedEvent(NoBuildRequestFinishedEvent event) {

postBuildMetricsEvent();

}


private void postBuildMetricsEvent() {

env.getEventBus().post(new BuildMetricsEvent(createBuildMetrics()));

}


@SuppressWarnings(""unused"")

@Subscribe

private void logActionCacheStatistics(ActionCacheStatistics stats) {

actionSummary.setActionCacheStatistics(stats);

}


private BuildMetrics createBuildMetrics() {

BuildMetrics.Builder buildMetrics =

BuildMetrics.newBuilder()

.setActionSummary(finishActionSummary())

.setMemoryMetrics(createMemoryMetrics())

.setTargetMetrics(targetMetrics.build())

.setPackageMetrics(packageMetrics.build())

.setTimingMetrics(finishTimingMetrics())

.setCumulativeMetrics(createCumulativeMetrics())

.setArtifactMetrics(artifactMetrics.build())

.setBuildGraphMetrics(buildGraphMetrics.build())

.addAllWorkerMetrics(WorkerMetricsCollector.instance().createWorkerMetricsProto())

.setWorkerPoolMetrics(createWorkerPoolMetrics());


NetworkMetrics networkMetrics = NetworkMetricsCollector.instance().collectMetrics();

if (networkMetrics != null) {

buildMetrics.setNetworkMetrics(networkMetrics);

}


return buildMetrics.build();

}


private ActionData buildActionData(ActionStats actionStats) {

NanosToMillisSinceEpochConverter nanosToMillisSinceEpochConverter =

BlazeClock.createNanosToMillisSinceEpochConverter();

ActionData.Builder builder =

ActionData.newBuilder()

.setMnemonic(actionStats.mnemonic)

.setFirstStartedMs(

nanosToMillisSinceEpochConverter.toEpochMillis(

actionStats.firstStarted.longValue()))

.setLastEndedMs(

nanosToMillisSinceEpochConverter.toEpochMillis(actionStats.lastEnded.longValue()))

.setActionsExecuted(actionStats.numActions.get());

long systemTime = actionStats.systemTime.get();

if (systemTime > 0) {

builder.setSystemTime(Durations.fromMillis(systemTime));

}

long userTime = actionStats.userTime.get();

if (userTime > 0) {

builder.setUserTime(Durations.fromMillis(userTime));

}

return builder.build();

}


private static final int MAX_ACTION_DATA = 20;


private ActionSummary finishActionSummary() {

Stream<ActionStats> [MASK] = actionStatsMap.values().stream();

if (!recordMetricsForAllMnemonics) {

[MASK] =

[MASK]

.sorted(Comparator.comparingLong(a -> -a.numActions.get()))

.limit(MAX_ACTION_DATA);

}

[MASK] .forEach(action -> actionSummary.addActionData(buildActionData(action)));


ImmutableMap<String, Integer> spawnSummary = spawnStats.getSummary();

actionSummary.setActionsExecuted(spawnSummary.getOrDefault(""total"", 0));

spawnSummary

.entrySet()

.forEach(

e -> {

RunnerCount.Builder builder = RunnerCount.newBuilder();

builder.setName(e.getKey()).setCount(e.getValue());

String execKind = spawnStats.getExecKindFor(e.getKey());

if (execKind != null) {

builder.setExecKind(execKind);

}

actionSummary.addRunnerCount(builder.build());

});

return actionSummary.build();

}


private MemoryMetrics createMemoryMetrics() {

MemoryMetrics.Builder memoryMetrics = MemoryMetrics.newBuilder();

if (MemoryProfiler.instance().getHeapUsedMemoryAtFinish() > 0) {

memoryMetrics.setUsedHeapSizePostBuild(MemoryProfiler.instance().getHeapUsedMemoryAtFinish());

}

PostGCMemoryUseRecorder.get()

.getPeakPostGcHeap()

.map(PeakHeap::bytes)

.ifPresent(memoryMetrics::setPeakPostGcHeapSize);


if (memoryMetrics.getPeakPostGcHeapSize() < memoryMetrics.getUsedHeapSizePostBuild()) {

// If we just did a GC and computed the heap size, update the one we got from the GC

// notification (which may arrive too late for this specific GC).

memoryMetrics.setPeakPostGcHeapSize(memoryMetrics.getUsedHeapSizePostBuild());

}


PostGCMemoryUseRecorder.get()

.getPeakPostGcHeapTenuredSpace()

.map(PeakHeap::bytes)

.ifPresent(memoryMetrics::setPeakPostGcTenuredSpaceHeapSize);


Map<String, Long> garbageStats = PostGCMemoryUseRecorder.get().getGarbageStats();

for (Map.Entry<String, Long> garbageEntry : garbageStats.entrySet()) {

GarbageMetrics.Builder garbageMetrics = GarbageMetrics.newBuilder();

garbageMetrics.setType(garbageEntry.getKey()).setGarbageCollected(garbageEntry.getValue());

memoryMetrics.addGarbageMetrics(garbageMetrics.build());

}


return memoryMetrics.build();

}


private CumulativeMetrics createCumulativeMetrics() {

return CumulativeMetrics.newBuilder()

.setNumAnalyses(numAnalyses.get())

.setNumBuilds(numBuilds.get())

.build();

}


private TimingMetrics finishTimingMetrics() {

Duration elapsedWallTime = Profiler.elapsedTimeMaybe();

if (elapsedWallTime != null) {

timingMetrics.setWallTimeInMs(elapsedWallTime.toMillis());

}

Duration cpuTime = Profiler.getProcessCpuTimeMaybe();

if (cpuTime != null) {

timingMetrics.setCpuTimeInMs(cpuTime.toMillis());

}

return timingMetrics.build();

}


private WorkerPoolMetrics createWorkerPoolMetrics() {

WorkerPoolMetrics.Builder metricsBuilder = WorkerPoolMetrics.newBuilder();


workerPoolStats.forEach(

(workerPoolHash, workerStats) ->

metricsBuilder.addWorkerPoolStats(

WorkerPoolMetrics.WorkerPoolStats.newBuilder()

.setHash(workerPoolHash)

.setMnemonic(workerStats.getMnemonic())

.setCreatedCount(workerStats.getCreatedCount())

.setDestroyedCount(workerStats.getDestroyedCount())

.setEvictedCount(workerStats.getEvictedCount())

.build()));


return metricsBuilder.build();

}


private static class WorkerPoolStats {

private int createdCount;

private int destroyedCount;

private int evictedCount;

private final String mnemonic;


WorkerPoolStats(String mnemonic) {

this.mnemonic = mnemonic;

}


void incrementCreatedCount() {

createdCount++;

}


void incrementDestroyedCount() {

destroyedCount++;

}


void incrementEvictedCount() {

evictedCount++;

}


public int getCreatedCount() {

return createdCount;

}


public int getDestroyedCount() {

return destroyedCount;

}


public String getMnemonic() {

return mnemonic;

}


public int getEvictedCount() {

return evictedCount;

}

}


private static class ActionStats {


final LongAccumulator firstStarted;

final LongAccumulator lastEnded;

final AtomicLong numActions;

final String mnemonic;

final AtomicLong systemTime;

final AtomicLong userTime;


ActionStats(String mnemonic) {

this.mnemonic = mnemonic;

firstStarted = new LongAccumulator(Math::min, Long.MAX_VALUE);

lastEnded = new LongAccumulator(Math::max, 0);

numActions = new AtomicLong();

systemTime = new AtomicLong();

userTime = new AtomicLong();

}

}

}


","actionStatsStream
"
"package com.facebook.drawee.generic;

import android.graphics.Color;
import androidx.annotation.ColorInt;
import com.facebook.common.internal.Preconditions;
import com.facebook.drawee.drawable.ScalingUtils;
import com.facebook.infer.annotation.Nullsafe;
import java.util.Arrays;
import javax.annotation.Nullable;

/** Class that encapsulates rounding parameters. */
@Nullsafe(Nullsafe.Mode.STRICT)
public class RoundingParams {

  public enum RoundingMethod {
    /**
     * Draws rounded corners on top of the underlying drawable by overlaying a solid color which is
     * specified by {@code setOverlayColor}. This option should only be used when the background
     * beneath the underlying drawable is static and of the same solid color.
     *
     * <p>Adding borders with this method will cause image edges to be trimmed off. Not noticeable
     * if the color is opaque, but very noticeable with low opacity.
     */
    OVERLAY_COLOR,

    /**
     * Uses BitmapShader to draw the bitmap with rounded corners. This is the default rounding
     * method. It doesn't support animations, and it does not support any scale types other than
     * {@link ScalingUtils.ScaleType#CENTER_CROP}, {@link ScalingUtils.ScaleType#FOCUS_CROP} and
     * {@link ScalingUtils.ScaleType#FIT_XY}.
     *
     * <p>If you use this rounding method with other scale types, such as {@link
     * ScalingUtils.ScaleType#CENTER}, you won't get an Exception but the image might look wrong
     * (e.g. repeated edges), especially in cases the source image is smaller than the view.
     */
    BITMAP_ONLY
  }

  private RoundingMethod mRoundingMethod = RoundingMethod.BITMAP_ONLY;
  private boolean mRoundAsCircle = false;
  private @Nullable float[] mCornersRadii = null;
  private int mOverlayColor = 0;
  private float mBorderWidth = 0;
  private int mBorderColor = Color.TRANSPARENT;
  private float mPadding = 0;
  private boolean mScaleDownInsideBorders = false;
  private boolean mPaintFilterBitmap = false;
  private boolean mRepeatEdgePixels = false;

  /**
   * Sets whether to round as circle.
   *
   * @param  [MASK]  whether or not to round as circle
   * @return modified instance
   */
  public RoundingParams setRoundAsCircle(boolean  [MASK] ) {
    mRoundAsCircle =  [MASK] ;
    return this;
  }

  /** Gets whether to round as circle */
  public boolean getRoundAsCircle() {
    return mRoundAsCircle;
  }

  /**
   * Specify if the edge pixels of the image should be repeated if the image is smaller than the
   * rounded image. For example, this can be useful if you have a smaller image icon wht a solid
   * background color that should fill the entire rounded image viewport.
   */
  public RoundingParams setRepeatEdgePixels(boolean repeatEdgePixels) {
    mRepeatEdgePixels = repeatEdgePixels;
    return this;
  }

  public boolean getRepeatEdgePixels() {
    return mRepeatEdgePixels;
  }

  /**
   * Sets the rounded corners radius.
   *
   * @param radius corner radius in pixels
   * @return modified instance
   */
  public RoundingParams setCornersRadius(float radius) {
    Arrays.fill(getOrCreateRoundedCornersRadii(), radius);
    return this;
  }

  /**
   * Sets the rounded corners radii.
   *
   * @param topLeft top-left corner radius in pixels
   * @param topRight top-right corner radius in pixels
   * @param bottomRight bottom-right corner radius in pixels
   * @param bottomLeft bottom-left corner radius in pixels
   * @return modified instance
   */
  public RoundingParams setCornersRadii(
      float topLeft, float topRight, float bottomRight, float bottomLeft) {
    float[] radii = getOrCreateRoundedCornersRadii();
    radii[0] = radii[1] = topLeft;
    radii[2] = radii[3] = topRight;
    radii[4] = radii[5] = bottomRight;
    radii[6] = radii[7] = bottomLeft;
    return this;
  }

  /**
   * Sets the rounded corners radii.
   *
   * @param radii float array of 8 radii in pixels. Each corner receives two radius values [X, Y].
   *     The corners are ordered top-left, top-right, bottom-right, bottom-left.
   * @return modified instance
   */
  public RoundingParams setCornersRadii(float[] radii) {
    Preconditions.checkNotNull(radii);
    Preconditions.checkArgument(radii.length == 8, ""radii should have exactly 8 values"");
    System.arraycopy(radii, 0, getOrCreateRoundedCornersRadii(), 0, 8);
    return this;
  }

  /**
   * Gets the rounded corners radii.
   *
   * <p>For performance reasons the internal array is returned directly. Do not modify it directly,
   * but use one of the exposed corner radii setters instead.
   */
  public @Nullable float[] getCornersRadii() {
    return mCornersRadii;
  }

  /**
   * Sets the rounding method.
   *
   * @param roundingMethod method of rounding
   * @return modified instance
   */
  public RoundingParams setRoundingMethod(RoundingMethod roundingMethod) {
    mRoundingMethod = roundingMethod;
    return this;
  }

  /** Gets the rounding method. */
  public RoundingMethod getRoundingMethod() {
    return mRoundingMethod;
  }

  /**
   * Sets the overlay color and changes the method to {@code RoundingMethod.COLOR_OVERLAY}.
   *
   * @param overlayColor overlay color
   */
  public RoundingParams setOverlayColor(@ColorInt int overlayColor) {
    mOverlayColor = overlayColor;
    mRoundingMethod = RoundingMethod.OVERLAY_COLOR;
    return this;
  }

  /** Gets the overlay color. */
  public int getOverlayColor() {
    return mOverlayColor;
  }

  private float[] getOrCreateRoundedCornersRadii() {
    if (mCornersRadii == null) {
      mCornersRadii = new float[8];
    }
    return mCornersRadii;
  }

  /** Factory method that creates new RoundingParams with RoundAsCircle specified. */
  public static RoundingParams asCircle() {
    return (new RoundingParams()).setRoundAsCircle(true);
  }

  /** Factory method that creates new RoundingParams with the specified corners radius. */
  public static RoundingParams fromCornersRadius(float radius) {
    return (new RoundingParams()).setCornersRadius(radius);
  }

  /** Factory method that creates new RoundingParams with the specified corners radii. */
  public static RoundingParams fromCornersRadii(
      float topLeft, float topRight, float bottomRight, float bottomLeft) {
    return (new RoundingParams()).setCornersRadii(topLeft, topRight, bottomRight, bottomLeft);
  }

  /** Factory method that creates new RoundingParams with the specified corners radii. */
  public static RoundingParams fromCornersRadii(float[] radii) {
    return (new RoundingParams()).setCornersRadii(radii);
  }

  /**
   * Sets the border width
   *
   * @param width of the width
   */
  public RoundingParams setBorderWidth(float width) {
    Preconditions.checkArgument(width >= 0, ""the border width cannot be < 0"");
    mBorderWidth = width;
    return this;
  }

  /** Gets the border width */
  public float getBorderWidth() {
    return mBorderWidth;
  }

  /**
   * Sets the border color
   *
   * @param color of the border
   */
  public RoundingParams setBorderColor(@ColorInt int color) {
    mBorderColor = color;
    return this;
  }

  /** Gets the border color */
  public int getBorderColor() {
    return mBorderColor;
  }

  /**
   * Sets the border around the rounded drawable
   *
   * @param color of the border
   * @param width of the width
   */
  public RoundingParams setBorder(@ColorInt int color, float width) {
    Preconditions.checkArgument(width >= 0, ""the border width cannot be < 0"");
    mBorderWidth = width;
    mBorderColor = color;
    return this;
  }

  /**
   * Sets the padding on rounded drawable. Works only with {@code RoundingMethod.BITMAP_ONLY}
   *
   * @param padding the padding in pixels
   */
  public RoundingParams setPadding(float padding) {
    Preconditions.checkArgument(padding >= 0, ""the padding cannot be < 0"");
    mPadding = padding;
    return this;
  }

  /** Gets the padding size */
  public float getPadding() {
    return mPadding;
  }

  /**
   * Sets whether image should be scaled down inside borders.
   *
   * @param scaleDownInsideBorders whether image should be scaled down inside borders or borders
   *     will be drawn over image
   * @return modified instance
   */
  public RoundingParams setScaleDownInsideBorders(boolean scaleDownInsideBorders) {
    mScaleDownInsideBorders = scaleDownInsideBorders;
    return this;
  }

  /** Gets whether image should be scaled down inside borders. */
  public boolean getScaleDownInsideBorders() {
    return mScaleDownInsideBorders;
  }

  /**
   * Sets FILTER_BITMAP_FLAG flag to Paint. {@link android.graphics.Paint#FILTER_BITMAP_FLAG}
   *
   * <p>This should generally be on when drawing bitmaps, unless performance-bound (rendering to
   * software canvas) or preferring pixelation artifacts to blurriness when scaling significantly.
   *
   * @param paintFilterBitmap whether to set FILTER_BITMAP_FLAG flag to Paint.
   * @return modified instance
   */
  public RoundingParams setPaintFilterBitmap(boolean paintFilterBitmap) {
    mPaintFilterBitmap = paintFilterBitmap;
    return this;
  }

  /** Gets whether to set FILTER_BITMAP_FLAG flag to Paint. */
  public boolean getPaintFilterBitmap() {
    return mPaintFilterBitmap;
  }

  @Override
  public boolean equals(@Nullable Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }

    RoundingParams that = (RoundingParams) o;

    if (mRoundAsCircle != that.mRoundAsCircle) {
      return false;
    }

    if (mOverlayColor != that.mOverlayColor) {
      return false;
    }

    if (Float.compare(that.mBorderWidth, mBorderWidth) != 0) {
      return false;
    }

    if (mBorderColor != that.mBorderColor) {
      return false;
    }

    if (Float.compare(that.mPadding, mPadding) != 0) {
      return false;
    }

    if (mRoundingMethod != that.mRoundingMethod) {
      return false;
    }

    if (mScaleDownInsideBorders != that.mScaleDownInsideBorders) {
      return false;
    }

    if (mPaintFilterBitmap != that.mPaintFilterBitmap) {
      return false;
    }

    return Arrays.equals(mCornersRadii, that.mCornersRadii);
  }

  @Override
  public int hashCode() {
    int result = mRoundingMethod != null ? mRoundingMethod.hashCode() : 0;
    result = 31 * result + (mRoundAsCircle ? 1 : 0);
    result = 31 * result + (mCornersRadii != null ? Arrays.hashCode(mCornersRadii) : 0);
    result = 31 * result + mOverlayColor;
    result = 31 * result + (mBorderWidth != +0.0f ? Float.floatToIntBits(mBorderWidth) : 0);
    result = 31 * result + mBorderColor;
    result = 31 * result + (mPadding != +0.0f ? Float.floatToIntBits(mPadding) : 0);
    result = 31 * result + (mScaleDownInsideBorders ? 1 : 0);
    result = 31 * result + (mPaintFilterBitmap ? 1 : 0);

    return result;
  }
}
","roundAsCircle
"
"package io.realm.internal.network;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import javax.annotation.Nullable;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.realm.internal.async.RealmThreadPoolExecutor;
import io.realm.internal.objectstore.OsJavaNetworkTransport;
import io.realm.mongodb.AppConfiguration;
import io.realm.mongodb.AppException;
import io.realm.mongodb.ErrorCode;
import io.realm.mongodb.log.obfuscator.HttpLogObfuscator;
import okhttp3.Call;
import okhttp3.ConnectionPool;
import okhttp3.Headers;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.RequestBody;
import okhttp3.ResponseBody;
import okio.BufferedSource;

public class OkHttpNetworkTransport extends OsJavaNetworkTransport {

    public static final MediaType JSON = MediaType.parse(""application/json; charset=utf-8"");

    private volatile OkHttpClient client = null;
    private volatile OkHttpClient streamClient = null;

    @Nullable
    private final HttpLogObfuscator httpLogObfuscator;
    // Cannot use App.NETWORK_POOL_EXECUTOR as they end up blocking each other.
    private final ThreadPoolExecutor threadPool = RealmThreadPoolExecutor.newDefaultExecutor();

    public OkHttpNetworkTransport(@Nullable HttpLogObfuscator httpLogObfuscator) {
        this.httpLogObfuscator = httpLogObfuscator;
    }

    private okhttp3.Request createRequest(String method, String url, Map<String, String> headers, String body){
        okhttp3.Request.Builder builder = new okhttp3.Request.Builder().url(url);

        // Ensure that we have correct custom headers until OS handles it.

        // 1. First of all add all custom headers
        for (Map.Entry<String, String> entry : getCustomRequestHeaders().entrySet()) {
            builder.addHeader(entry.getKey(), entry.getValue());
        }
        // 2. Then replace default authorization header with custom one if present
        String authorizationHeaderValue = headers.get(AppConfiguration.DEFAULT_AUTHORIZATION_HEADER_NAME);
        String authorizationHeaderName = getAuthorizationHeaderName();
        if (authorizationHeaderValue != null && !AppConfiguration.DEFAULT_AUTHORIZATION_HEADER_NAME.equals(authorizationHeaderName)) {
            headers.remove(AppConfiguration.DEFAULT_AUTHORIZATION_HEADER_NAME);
            headers.put(authorizationHeaderName, authorizationHeaderValue);
        }

        // 3. Finally add all headers defined by Object Store
        for (Map.Entry<String, String> entry : headers.entrySet()) {
            builder.addHeader(entry.getKey(), entry.getValue());
        }
        
        switch (method) {
            case ""get"":
                builder.get();
                break;
            case ""delete"":
                builder.delete(RequestBody.create(JSON, body));
                break;
            case ""patch"":
                builder.patch(RequestBody.create(JSON, body));
                break;
            case ""post"":
                builder.post(RequestBody.create(JSON, body));
                break;
            case ""put"":
                builder.put(RequestBody.create(JSON, body));
                break;
            default:
                throw new IllegalArgumentException(""Unknown method type: "" + method);
        }

        return builder.build();
    }


    @SuppressFBWarnings(""REC_CATCH_EXCEPTION"")
    @Override
    public void sendRequestAsync(String method,
                            String url,
                            long timeoutMs,
                            Map<String, String> headers,
                            String body,
                            long  [MASK] ) {
        threadPool.execute(new Runnable() {
            @Override
            public void run() {
                try {
                    OsJavaNetworkTransport.Response response = OkHttpNetworkTransport.this.executeRequest(method, url, timeoutMs, headers, body);
                    OkHttpNetworkTransport.this.handleResponse(response,  [MASK] );
                } catch (Error e) {
                    OkHttpNetworkTransport.this.handleResponse(Response.unknownError(e.toString()),  [MASK] );
                }
            }
        });
    }

    @Override
    public OsJavaNetworkTransport.Response executeRequest(String method, String url, long timeoutMs, Map<String, String> headers, String body) {
        try {
            OkHttpClient client = getClient(timeoutMs);

            okhttp3.Response response = null;
            try {
                okhttp3.Request request = createRequest(method, url, headers, body);

                Call call = client.newCall(request);
                response = call.execute();
                ResponseBody responseBody = response.body();
                String result = """";
                if (responseBody != null) {
                    result = responseBody.string();
                }
                return Response.httpResponse(response.code(), parseHeaders(response.headers()), result);
            } catch (IOException ex) {
                return Response.ioError(ex.toString());
            } catch (Exception ex) {
                return Response.unknownError(ex.toString());
            } finally {
                if (response != null) {
                    response.close();
                }
            }
        } catch (Exception e) {
            return Response.unknownError(e.toString());
        }
    }

    @Override
    public OsJavaNetworkTransport.Response sendStreamingRequest(Request request) throws IOException, AppException {
        OkHttpClient client = getStreamClient();

        okhttp3.Request okRequest = createRequest(request.getMethod(), request.getUrl(), request.getHeaders(), request.getBody());

        Call call = client.newCall(okRequest);
        okhttp3.Response response = call.execute();

        if ((response.code() >= 300) || ((response.code() < 200) && (response.code() != 0))) {
            throw new AppException(ErrorCode.fromNativeError(ErrorCode.Type.HTTP, response.code()), response.message());
        }

        return Response.httpResponse(response.code(), parseHeaders(response.headers()), response.body().source());
    }

    @Override
    public void reset() {
        try {
            threadPool.shutdownNow();
            threadPool.awaitTermination(30, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            throw new IllegalStateException(""Threadpool did not terminate in time"", e);
        }
        super.reset();
    }

    // Lazily creates the client if not already created
    // TODO: timeOuts are not expected to change between requests. So for now just use the timeout first send.
    private synchronized OkHttpClient getClient(long timeoutMs) {
        if (client == null) {
            client = new OkHttpClient.Builder()
                    // TODO There doesn't appear to set a timeout for the entire http request,
                    //  so just reuse it across all 3 phases. In the worst case that means the
                    //  the timeout is 3x the defined timeout which is acceptable.
                    .connectTimeout(timeoutMs, TimeUnit.MILLISECONDS)
                    .readTimeout(timeoutMs, TimeUnit.MILLISECONDS)
                    .writeTimeout(timeoutMs, TimeUnit.MILLISECONDS)
                    .followRedirects(true)
                    .addInterceptor(new LoggingInterceptor(httpLogObfuscator))
                    // using custom Connection Pool to evict idle connection after 5 seconds rather than 5 minutes (which is the default)
                    // keeping idle connection on the pool will prevent the ROS to be stopped, since the HttpUtils#stopSyncServer query
                    // will not return before the tests timeout (ex 10 seconds for AuthTests)
                    .connectionPool(new ConnectionPool(5, 5, TimeUnit.SECONDS))
                    .build();
        }

        return client;
    }

    private synchronized OkHttpClient getStreamClient() {
        if (streamClient == null) {
            streamClient = new OkHttpClient.Builder()
                    .readTimeout(0, TimeUnit.MILLISECONDS)
                    .followRedirects(true)
                    .addInterceptor(new LoggingInterceptor(httpLogObfuscator))
                    .build();
        }

        return streamClient;
    }

    // Parse Headers output from OKHttp to the format expected by ObjectStore
    private Map<String, String> parseHeaders(Headers headers) {
        HashMap<String, String> osHeaders = new HashMap<>(headers.size() / 2);
        for (String key : headers.names()) {
            osHeaders.put(key, headers.get(key));
        }
        return osHeaders;
    }

    public static class Response extends OsJavaNetworkTransport.Response {
        private BufferedSource bufferedSource;
        private volatile boolean closed;

        public static OsJavaNetworkTransport.Response unknownError(String stacktrace) {
            return new Response(0, ERROR_UNKNOWN, new HashMap<>(), stacktrace);
        }

        public static OsJavaNetworkTransport.Response ioError(String stackTrace) {
            return new Response(0, ERROR_IO, new HashMap<>(), stackTrace);
        }

        public static OsJavaNetworkTransport.Response interruptedError(String stackTrace) {
            return new Response(0, ERROR_INTERRUPTED, new HashMap<>(), stackTrace);
        }

        public static OsJavaNetworkTransport.Response httpResponse(int statusCode, Map<String, String> responseHeaders, String body) {
            return new Response(statusCode, 0, responseHeaders, body);
        }

        private Response(int httpResponseCode, int customResponseCode, Map<String, String> headers, String body) {
            super(httpResponseCode, customResponseCode, headers, body);
        }

        private Response(int httpResponseCode, Map<String, String> headers, BufferedSource bufferedSource) {
            super(httpResponseCode, 0, headers, """");

            this.bufferedSource = bufferedSource;
        }

        public static OsJavaNetworkTransport.Response httpResponse(int httpResponseCode, Map<String, String> headers, BufferedSource originalResponse) {
            return new Response(httpResponseCode, headers, originalResponse);
        }

        @Override
        public String readBodyLine() throws IOException {
            if (!closed){
                return bufferedSource.readUtf8LineStrict();
            } else{
                bufferedSource.close();
                throw new IOException(""Stream closed"");
            }
        }

        /**
         * Closes the current stream.
         *
         * Note: we use a close flag because okio buffers are not thread safe:
         * @see <a href=""http://google.com"">https://github.com/square/okio/issues/163#issuecomment-127052956</a>
         */
        @Override
        public void close() {
            closed = true;
        }

        @Override
        public boolean isOpen() {
            return !closed && bufferedSource.isOpen();
        }
    }

}

","completionBlockPtr
"
"package proguard.classfile.attribute.visitor;

import proguard.classfile.*;
import proguard.classfile.attribute.*;
import proguard.classfile.attribute.annotation.*;
import proguard.classfile.attribute.module.*;
import proguard.classfile.attribute.preverification.*;
import proguard.util.ArrayUtil;

/**
* This AttributeVisitor delegates all visits to each AttributeVisitor
* in a given list.
*
* @author Eric Lafortune
*/
public class MultiAttributeVisitor implements AttributeVisitor
{
private AttributeVisitor[] attributeVisitors;
private int attributeVisitorCount;


public MultiAttributeVisitor()
{
this.attributeVisitors = new AttributeVisitor[16];
}


public MultiAttributeVisitor(AttributeVisitor... attributeVisitors)
{
this.attributeVisitors = attributeVisitors;
this.attributeVisitorCount = attributeVisitors.length;
}


public void addAttributeVisitor(AttributeVisitor attributeVisitor)
{
attributeVisitors =
ArrayUtil.add(attributeVisitors,
attributeVisitorCount++,
attributeVisitor);
}


// Implementations for AttributeVisitor.


public void visitUnknownAttribute(Clazz clazz, UnknownAttribute unknownAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitUnknownAttribute(clazz, unknownAttribute);
}
}


public void visitBootstrapMethodsAttribute(Clazz clazz, BootstrapMethodsAttribute bootstrapMethodsAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitBootstrapMethodsAttribute(clazz, bootstrapMethodsAttribute);
}
}


public void visitSourceFileAttribute(Clazz clazz, SourceFileAttribute sourceFileAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitSourceFileAttribute(clazz, sourceFileAttribute);
}
}


public void visitSourceDirAttribute(Clazz clazz, SourceDirAttribute sourceDirAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitSourceDirAttribute(clazz, sourceDirAttribute);
}
}


public void visitInnerClassesAttribute(Clazz clazz, InnerClassesAttribute [MASK] )
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitInnerClassesAttribute(clazz, [MASK] );
}
}


public void visitEnclosingMethodAttribute(Clazz clazz, EnclosingMethodAttribute enclosingMethodAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitEnclosingMethodAttribute(clazz, enclosingMethodAttribute);
}
}


public void visitNestHostAttribute(Clazz clazz, NestHostAttribute nestHostAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitNestHostAttribute(clazz, nestHostAttribute);
}
}


public void visitNestMembersAttribute(Clazz clazz, NestMembersAttribute nestMembersAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitNestMembersAttribute(clazz, nestMembersAttribute);
}
}


public void visitModuleAttribute(Clazz clazz, ModuleAttribute moduleAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitModuleAttribute(clazz, moduleAttribute);
}
}


public void visitModuleMainClassAttribute(Clazz clazz, ModuleMainClassAttribute moduleMainClassAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitModuleMainClassAttribute(clazz, moduleMainClassAttribute);
}
}


public void visitModulePackagesAttribute(Clazz clazz, ModulePackagesAttribute modulePackagesAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitModulePackagesAttribute(clazz, modulePackagesAttribute);
}
}


public void visitDeprecatedAttribute(Clazz clazz, DeprecatedAttribute deprecatedAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitDeprecatedAttribute(clazz, deprecatedAttribute);
}
}


public void visitSyntheticAttribute(Clazz clazz, SyntheticAttribute syntheticAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitSyntheticAttribute(clazz, syntheticAttribute);
}
}


public void visitSignatureAttribute(Clazz clazz, SignatureAttribute syntheticAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitSignatureAttribute(clazz, syntheticAttribute);
}
}


public void visitDeprecatedAttribute(Clazz clazz, Field field, DeprecatedAttribute deprecatedAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitDeprecatedAttribute(clazz, field, deprecatedAttribute);
}
}


public void visitSyntheticAttribute(Clazz clazz, Field field, SyntheticAttribute syntheticAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitSyntheticAttribute(clazz, field, syntheticAttribute);
}
}


public void visitSignatureAttribute(Clazz clazz, Field field, SignatureAttribute syntheticAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitSignatureAttribute(clazz, field, syntheticAttribute);
}
}


public void visitDeprecatedAttribute(Clazz clazz, Method method, DeprecatedAttribute deprecatedAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitDeprecatedAttribute(clazz, method, deprecatedAttribute);
}
}


public void visitSyntheticAttribute(Clazz clazz, Method method, SyntheticAttribute syntheticAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitSyntheticAttribute(clazz, method, syntheticAttribute);
}
}


public void visitSignatureAttribute(Clazz clazz, Method method, SignatureAttribute syntheticAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitSignatureAttribute(clazz, method, syntheticAttribute);
}
}


public void visitConstantValueAttribute(Clazz clazz, Field field, ConstantValueAttribute constantValueAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitConstantValueAttribute(clazz, field, constantValueAttribute);
}
}


public void visitMethodParametersAttribute(Clazz clazz, Method method, MethodParametersAttribute methodParametersAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitMethodParametersAttribute(clazz, method, methodParametersAttribute);
}
}


public void visitExceptionsAttribute(Clazz clazz, Method method, ExceptionsAttribute exceptionsAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitExceptionsAttribute(clazz, method, exceptionsAttribute);
}
}


public void visitCodeAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitCodeAttribute(clazz, method, codeAttribute);
}
}


public void visitStackMapAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, StackMapAttribute stackMapAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitStackMapAttribute(clazz, method, codeAttribute, stackMapAttribute);
}
}


public void visitStackMapTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, StackMapTableAttribute stackMapTableAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitStackMapTableAttribute(clazz, method, codeAttribute, stackMapTableAttribute);
}
}


public void visitLineNumberTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, LineNumberTableAttribute lineNumberTableAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitLineNumberTableAttribute(clazz, method, codeAttribute, lineNumberTableAttribute);
}
}


public void visitLocalVariableTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, LocalVariableTableAttribute localVariableTableAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitLocalVariableTableAttribute(clazz, method, codeAttribute, localVariableTableAttribute);
}
}


public void visitLocalVariableTypeTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, LocalVariableTypeTableAttribute localVariableTypeTableAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitLocalVariableTypeTableAttribute(clazz, method, codeAttribute, localVariableTypeTableAttribute);
}
}


public void visitRuntimeVisibleAnnotationsAttribute(Clazz clazz, RuntimeVisibleAnnotationsAttribute runtimeVisibleAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitRuntimeVisibleAnnotationsAttribute(clazz, runtimeVisibleAnnotationsAttribute);
}
}


public void visitRuntimeInvisibleAnnotationsAttribute(Clazz clazz, RuntimeInvisibleAnnotationsAttribute runtimeInvisibleAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitRuntimeInvisibleAnnotationsAttribute(clazz, runtimeInvisibleAnnotationsAttribute);
}
}


public void visitRuntimeVisibleAnnotationsAttribute(Clazz clazz, Field field, RuntimeVisibleAnnotationsAttribute runtimeVisibleAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitRuntimeVisibleAnnotationsAttribute(clazz, field, runtimeVisibleAnnotationsAttribute);
}
}


public void visitRuntimeInvisibleAnnotationsAttribute(Clazz clazz, Field field, RuntimeInvisibleAnnotationsAttribute runtimeInvisibleAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitRuntimeInvisibleAnnotationsAttribute(clazz, field, runtimeInvisibleAnnotationsAttribute);
}
}


public void visitRuntimeVisibleAnnotationsAttribute(Clazz clazz, Method method, RuntimeVisibleAnnotationsAttribute runtimeVisibleAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitRuntimeVisibleAnnotationsAttribute(clazz, method, runtimeVisibleAnnotationsAttribute);
}
}


public void visitRuntimeInvisibleAnnotationsAttribute(Clazz clazz, Method method, RuntimeInvisibleAnnotationsAttribute runtimeInvisibleAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitRuntimeInvisibleAnnotationsAttribute(clazz, method, runtimeInvisibleAnnotationsAttribute);
}
}


public void visitRuntimeVisibleParameterAnnotationsAttribute(Clazz clazz, Method method, RuntimeVisibleParameterAnnotationsAttribute runtimeVisibleParameterAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitRuntimeVisibleParameterAnnotationsAttribute(clazz, method, runtimeVisibleParameterAnnotationsAttribute);
}
}


public void visitRuntimeInvisibleParameterAnnotationsAttribute(Clazz clazz, Method method, RuntimeInvisibleParameterAnnotationsAttribute runtimeInvisibleParameterAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitRuntimeInvisibleParameterAnnotationsAttribute(clazz, method, runtimeInvisibleParameterAnnotationsAttribute);
}
}


public void visitRuntimeVisibleTypeAnnotationsAttribute(Clazz clazz, RuntimeVisibleTypeAnnotationsAttribute runtimeVisibleTypeAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitRuntimeVisibleTypeAnnotationsAttribute(clazz, runtimeVisibleTypeAnnotationsAttribute);
}
}


public void visitRuntimeVisibleTypeAnnotationsAttribute(Clazz clazz, Field field, RuntimeVisibleTypeAnnotationsAttribute runtimeVisibleTypeAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitRuntimeVisibleTypeAnnotationsAttribute(clazz, field, runtimeVisibleTypeAnnotationsAttribute);
}
}


public void visitRuntimeVisibleTypeAnnotationsAttribute(Clazz clazz, Method method, RuntimeVisibleTypeAnnotationsAttribute runtimeVisibleTypeAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitRuntimeVisibleTypeAnnotationsAttribute(clazz, method, runtimeVisibleTypeAnnotationsAttribute);
}
}


public void visitRuntimeVisibleTypeAnnotationsAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, RuntimeVisibleTypeAnnotationsAttribute runtimeVisibleTypeAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitRuntimeVisibleTypeAnnotationsAttribute(clazz, method, codeAttribute, runtimeVisibleTypeAnnotationsAttribute);
}
}


public void visitRuntimeInvisibleTypeAnnotationsAttribute(Clazz clazz, RuntimeInvisibleTypeAnnotationsAttribute runtimeInvisibleTypeAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitRuntimeInvisibleTypeAnnotationsAttribute(clazz, runtimeInvisibleTypeAnnotationsAttribute);
}
}


public void visitRuntimeInvisibleTypeAnnotationsAttribute(Clazz clazz, Field field, RuntimeInvisibleTypeAnnotationsAttribute runtimeInvisibleTypeAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitRuntimeInvisibleTypeAnnotationsAttribute(clazz, field, runtimeInvisibleTypeAnnotationsAttribute);
}
}


public void visitRuntimeInvisibleTypeAnnotationsAttribute(Clazz clazz, Method method, RuntimeInvisibleTypeAnnotationsAttribute runtimeInvisibleTypeAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitRuntimeInvisibleTypeAnnotationsAttribute(clazz, method, runtimeInvisibleTypeAnnotationsAttribute);
}
}


public void visitRuntimeInvisibleTypeAnnotationsAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, RuntimeInvisibleTypeAnnotationsAttribute runtimeInvisibleTypeAnnotationsAttribute)
{
for (int index = 0; index < attributeVisitors.length; index++)
{
attributeVisitors[index].visitRuntimeInvisibleTypeAnnotationsAttribute(clazz, method, codeAttribute, runtimeInvisibleTypeAnnotationsAttribute);
}
}


public void visitAnnotationDefaultAttribute(Clazz clazz, Method method, AnnotationDefaultAttribute annotationDefaultAttribute)
{
for (int index = 0; index < attributeVisitorCount; index++)
{
attributeVisitors[index].visitAnnotationDefaultAttribute(clazz, method, annotationDefaultAttribute);
}
}
}

","innerClassesAttribute
"
"
package com.google.devtools.build.lib.query2.query.output;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Ordering;
import com.google.devtools.build.lib.cmdline.Label;
import com.google.devtools.build.lib.cmdline.RepositoryMapping;
import com.google.devtools.build.lib.collect.CollectionUtils;
import com.google.devtools.build.lib.collect.EquivalenceRelation;
import com.google.devtools.build.lib.graph.Digraph;
import com.google.devtools.build.lib.graph.DotOutputVisitor;
import com.google.devtools.build.lib.graph.LabelSerializer;
import com.google.devtools.build.lib.graph.Node;
import com.google.devtools.build.lib.packages.Target;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import javax.annotation.Nullable;

/**
 * Generic logic for writing query expression results to <a
 * href=""http://graphviz.org/doc/info/lang.html"">GraphViz</a> format.
 *
 * <p>This can be used by any query implementation that can provide results as a {@link Digraph}.
 */
public final class GraphOutputWriter<T> {
  /** Interface for reading the contents of a {@link Digraph} {@link Node}. */
  public interface NodeReader<T> {
    /**
     * Returns the label to associate with a GraphViz node.
     *
     * <p>This is not the same as a build {@link Label}. This is just the text associated with a
     * node in a GraphViz graph.
     */
    String getLabel(Node<T> node, RepositoryMapping mainRepositoryMapping);

    /** Returns a comparator for the build graph nodes that form the payloads of GraphViz nodes. */
    Comparator<T> comparator();
  }

  private final NodeReader<T> nodeReader;
  private final String lineTerminator;
  private final boolean sortLabels;
  private final int maxLabelSize;
  private final int maxConditionalEdges;
  private final boolean mergeEquivalentNodes;
  private final Ordering<Node<T>> nodeComparator;
  private final RepositoryMapping mainRepoMapping;

  private static final int RESERVED_LABEL_CHARS = ""\\n...and 9999999 more items"".length();

  /**
   * Constructors a new writer.
   *
   * @param nodeReader {@link NodeReader} for reading node content
   * @param lineTerminator line string terminator
   * @param sortLabels if true, output nodes in sorted order with {@link NodeReader#comparator})
   * @param maxLabelSize maximum characters in label output. Longer labels are truncated. -1 means
   *     no limit.
   * @param maxConditionalEdges maximum number of {@code select() conditional labels} to show on
   *     each edge. -1 means no limit. 0 means no labels.
   * @param mergeEquivalentNodes if true, topologically equivalent nodes are merged together as
   *     multiple labels in the same node. This condenses the graph. For example, given graph {@code
   *     (nodes=[A, B, C], edges=[A->B, A->C]) }, the output has two nodes: ""A"" and ""B,C"".
   */
  public GraphOutputWriter(
      NodeReader<T> nodeReader,
      String lineTerminator,
      boolean sortLabels,
      int maxLabelSize,
      int maxConditionalEdges,
      boolean mergeEquivalentNodes,
      RepositoryMapping mainRepoMapping) {
    this.nodeReader = nodeReader;
    this.lineTerminator = lineTerminator;
    this.sortLabels = sortLabels;
    this.maxLabelSize = maxLabelSize;
    this.maxConditionalEdges = maxConditionalEdges;
    this.mergeEquivalentNodes = mergeEquivalentNodes;
    this.mainRepoMapping = mainRepoMapping;
    nodeComparator = Ordering.from(nodeReader.comparator()).onResultOf(Node::getLabel);
  }

  /**
   * Writes the given graph.
   *
   * @param graph build graph to write
   * @param conditionalEdges edges corresponding to select()s (see {@link ConditionalEdges})
   * @param out output stream to write to
   */
  public void write(
      Digraph<T> graph, @Nullable ConditionalEdges conditionalEdges, OutputStream out) {
    PrintWriter printWriter = new PrintWriter(new OutputStreamWriter(out, UTF_8));
    if (mergeEquivalentNodes) {
      outputFactored(graph, conditionalEdges, printWriter);
    } else {
      outputUnfactored(graph, conditionalEdges, printWriter);
    }
  }

  private void outputUnfactored(
      Digraph<T> graph, @Nullable ConditionalEdges conditionalEdges, PrintWriter out) {
    graph.visitNodesBeforeEdges(
        new DotOutputVisitor<T>(out, node -> nodeReader.getLabel(node, mainRepoMapping)) {
          @Override
          public void beginVisit() {
            super.beginVisit();
            // TODO(bazel-team): (2009) make this the default in Digraph.
            out.printf(""  node [shape=box];%s"", lineTerminator);
          }

          @Override
          public void visitEdge(Node<T> lhs, Node<T> rhs) {
            super.visitEdge(lhs, rhs);
            String outputLabel =
                getConditionsGraphLabel(
                    ImmutableSet.of(lhs), ImmutableSet.of(rhs), conditionalEdges);
            if (!outputLabel.isEmpty()) {
              out.printf(""  [label=\""%s\""];\n"", outputLabel);
            }
          }
        },
        sortLabels ? nodeReader.comparator() : null);
  }

  /**
   * Given {@code collectionOfUnorderedSets}, a collection of sets of nodes, returns a collection of
   * sets with the same elements as {@code collectionOfUnorderedSets} but with a stable iteration
   * order within each set given by the target ordering, and the collection ordered by the same
   * induced order.
   */
  private Collection<Set<Node<T>>> orderPartition(
      Collection<Set<Node<T>>> collectionOfUnorderedSets) {
    List<Set<Node<T>>> result = new ArrayList<>();
    for (Set<Node<T>> part : collectionOfUnorderedSets) {
      List<Node<T>> toSort = new ArrayList<>(part);
      Collections.sort(toSort, nodeComparator);
      result.add(ImmutableSet.copyOf(toSort));
    }
    Collections.sort(result, nodeComparator.lexicographical());
    return result;
  }

  private void outputFactored(
      Digraph<T> graph, ConditionalEdges conditionalEdges, PrintWriter out) {
    EquivalenceRelation<Node<T>> equivalenceRelation = createEquivalenceRelation();

    Collection<Set<Node<T>>> partition =
        CollectionUtils.partition(graph.getNodes(), equivalenceRelation);
    if (sortLabels) {
      partition = orderPartition(partition);
    }

    Digraph<Set<Node<T>>> factoredGraph = graph.createImageUnderPartition(partition);

    // Concatenate the labels of all topologically-equivalent nodes.
    LabelSerializer<Set<Node<T>>> labelSerializer =
        node -> {
          int actualLimit = maxLabelSize - RESERVED_LABEL_CHARS;
          boolean firstItem = true;
          StringBuilder buf = new StringBuilder();
          int count = 0;
          for (Node<T> eqNode : node.getLabel()) {
            String labelString = nodeReader.getLabel(eqNode, mainRepoMapping);
            if (!firstItem) {
              buf.append(""\\n"");

              // Use -1 to denote no limit, as it is easier than trying to pass MAX_INT on the
              // cmdline
              if (maxLabelSize != -1 && (buf.length() + labelString.length() > actualLimit)) {
                buf.append(""...and "");
                buf.append(node.getLabel().size() - count);
                buf.append("" more items"");
                break;
              }
            }

            buf.append(labelString);
            count++;
            firstItem = false;
          }
          return buf.toString();
        };

    factoredGraph.visitNodesBeforeEdges(
        new DotOutputVisitor<Set<Node<T>>>(out, labelSerializer) {
          @Override
          public void beginVisit() {
            super.beginVisit();
            // TODO(bazel-team): (2009) make this the default in Digraph.
            out.println(""  node [shape=box];"");
          }

          @Override
          public void visitEdge(Node<Set<Node<T>>> lhs, Node<Set<Node<T>>> rhs) {
            super.visitEdge(lhs, rhs);

            String outputLabel =
                getConditionsGraphLabel(lhs.getLabel(), rhs.getLabel(), conditionalEdges);
            if (!outputLabel.isEmpty()) {
              out.printf(""  [label=\""%s\""];\n"", outputLabel);
            }
          }
        },
        sortLabels ? nodeComparator.lexicographical() : null);
  }

  /**
   * Returns an equivalence relation for nodes in the specified graph.
   *
   * <p>Two nodes are considered equal iff they have equal topology (predecessors and successors).
   *
   * <p>TODO(bazel-team): Make this a method of Digraph.
   */
  @SuppressWarnings(""ReferenceEquality"")
  private static <LABEL> EquivalenceRelation<Node<LABEL>> createEquivalenceRelation() {
    return new EquivalenceRelation<Node<LABEL>>() {
      @Override
      public int compare(Node<LABEL> x, Node<LABEL> y) {
        if (x == y) {
          return 0;
        }

        if (x.numPredecessors() != y.numPredecessors() || x.numSuccessors() != y.numSuccessors()) {
          return -1;
        }

        Set<Node<LABEL>> xpred = new HashSet<>(x.getPredecessors());
        Set<Node<LABEL>> ypred = new HashSet<>(y.getPredecessors());
        if (!xpred.equals(ypred)) {
          return -1;
        }

        Set<Node<LABEL>> xsucc = new HashSet<>(x.getSuccessors());
        Set<Node<LABEL>> ysucc = new HashSet<>(y.getSuccessors());
        if (!xsucc.equals(ysucc)) {
          return -1;
        }

        return 0;
      }
    };
  }

  private String getConditionsGraphLabel(
      Iterable<Node<T>> lhs, Iterable<Node<T>> rhs, ConditionalEdges conditionalEdges) {
    StringBuilder buf = new StringBuilder();
    if (conditionalEdges == null || maxConditionalEdges == 0) {
      return buf.toString();
    }

    Set<Label>  [MASK]  = new HashSet<>();
    for (Node<T> src : lhs) {
      Label srcLabel = ((Target) src.getLabel()).getLabel();
      for (Node<T> dest : rhs) {
        Label destLabel = ((Target) dest.getLabel()).getLabel();
        Optional<Set<Label>> conditions = conditionalEdges.get(srcLabel, destLabel);
        if (conditions.isPresent()) {
          boolean firstItem = true;

          int limit =
              (maxConditionalEdges == -1) ? conditions.get().size() : (maxConditionalEdges - 1);

          for (Label conditionLabel : Iterables.limit(conditions.get(), limit)) {
            if (! [MASK] .add(conditionLabel)) {
              // duplicate label; skip.
              continue;
            }

            if (!firstItem) {
              buf.append(""\\n"");
            }

            buf.append(conditionLabel.getCanonicalForm());
            firstItem = false;
          }
          if (conditions.get().size() > limit) {
            buf.append(""..."");
          }
        }
      }
    }
    return buf.toString();
  }
}
","annotatedLabels
"
"package com.badlogic.gdx.tests.bullet;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.PerspectiveCamera;
import com.badlogic.gdx.graphics.VertexAttributes.Usage;
import com.badlogic.gdx.graphics.g3d.Material;
import com.badlogic.gdx.graphics.g3d.Model;
import com.badlogic.gdx.graphics.g3d.attributes.ColorAttribute;
import com.badlogic.gdx.graphics.g3d.utils.MeshPartBuilder;
import com.badlogic.gdx.graphics.g3d.utils.ModelBuilder;
import com.badlogic.gdx.math.Matrix4;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.physics.bullet.collision.btBroadphasePairArray;
import com.badlogic.gdx.physics.bullet.collision.btCollisionDispatcher;
import com.badlogic.gdx.physics.bullet.collision.btCollisionObject;
import com.badlogic.gdx.physics.bullet.collision.btCollisionShape;
import com.badlogic.gdx.physics.bullet.collision.btCollisionWorld;
import com.badlogic.gdx.physics.bullet.collision.btCompoundShape;
import com.badlogic.gdx.physics.bullet.collision.btConvexHullShape;
import com.badlogic.gdx.physics.bullet.collision.btDbvtBroadphase;
import com.badlogic.gdx.physics.bullet.collision.btDefaultCollisionConfiguration;
import com.badlogic.gdx.physics.bullet.collision.btPairCachingGhostObject;
import com.badlogic.gdx.physics.bullet.collision.btPersistentManifoldArray;
import com.badlogic.gdx.utils.Array;

/** @author Xoppa */
public class FrustumCullingTest extends BaseBulletTest {
        /** Only show entities inside the frustum */
        final static int CULL_FRUSTUM = 1;
        /** Transform the render cam with the frustum */
        final static int FRUSTUM_CAM = 2;

        final static boolean USE_BULLET_FRUSTUM_CULLING = true;

        int state = 0; // 0 = No culling, look from above

        final static int BOXCOUNT = 200;

        final static float BOX_X_MIN = -25;
        final static float BOX_Y_MIN = -25;
        final static float BOX_Z_MIN = -25;

        final static float BOX_X_MAX = 25;
        final static float BOX_Y_MAX = 25;
        final static float BOX_Z_MAX = 25;

        final static float SPEED_X = 360f / 7f;
        final static float SPEED_Y = 360f / 19f;
        final static float SPEED_Z = 360f / 13f;

        final static Vector3 tmpV = new Vector3();
        final static Matrix4 tmpM = new Matrix4();

        final static int ptrs[] = new int[512];
        final static Array<btCollisionObject> visibleObjects = new Array<btCollisionObject>();

        public static btPairCachingGhostObject createFrustumObject (final Vector3... points) {
                final btPairCachingGhostObject result = new TestPairCachingGhostObject();
                final boolean USE_COMPOUND = true;
                // Using a compound shape is not necessary, but it's good practice to create shapes around the center.
                if (USE_COMPOUND) {
                        final Vector3 centerNear = new Vector3(points[2]).sub(points[0]).scl(0.5f).add(points[0]);
                        final Vector3 centerFar = new Vector3(points[6]).sub(points[4]).scl(0.5f).add(points[4]);
                        final Vector3 center = new Vector3(centerFar).sub(centerNear).scl(0.5f).add(centerNear);
                        final btConvexHullShape hullShape = new btConvexHullShape();
                        for (int i = 0; i < points.length; i++)
                                hullShape.addPoint(tmpV.set(points[i]).sub(center));
                        final btCompoundShape shape = new btCompoundShape();
                        shape.addChildShape(tmpM.setToTranslation(center), hullShape);
                        result.setCollisionShape(shape);
                } else {
                        final btConvexHullShape shape = new btConvexHullShape();
                        for (int i = 0; i < points.length; i++)
                                shape.addPoint(points[i]);
                        result.setCollisionShape(shape);
                }
                result.setCollisionFlags(btCollisionObject.CollisionFlags.CF_NO_CONTACT_RESPONSE);
                return result;
        }

        public static Array<BulletEntity> getEntitiesCollidingWithObject (final BulletWorld world, final btCollisionObject object,
                final Array<BulletEntity> out, final btPersistentManifoldArray tmpArr) {
                // Fetch the array of contacts
                btBroadphasePairArray arr = world.broadphase.getOverlappingPairCache().getOverlappingPairArray();
                // Get the user values (which are indices in the entities array) of all objects colliding with the object
                final int n = arr.getCollisionObjectsValue(ptrs, object);
                // Fill the array of entities
                out.clear();
                for (int i = 0; i < n; i++)
                        out.add(world.entities.get(ptrs[i]));
                return out;
        }

        public static Model createFrustumModel (final Vector3... p) {
                ModelBuilder builder = new ModelBuilder();
                builder.begin();
                MeshPartBuilder mpb = builder.part("""", GL20.GL_LINES, Usage.Position | Usage.Normal,
                        new Material(new ColorAttribute(ColorAttribute.Diffuse, Color.WHITE)));
                mpb.vertex(p[0].x, p[0].y, p[0].z, 0, 0, 1, p[1].x, p[1].y, p[1].z, 0, 0, 1, p[2].x, p[2].y, p[2].z, 0, 0, 1, p[3].x,
                        p[3].y, p[3].z, 0, 0, 1, // near
                        p[4].x, p[4].y, p[4].z, 0, 0, -1, p[5].x, p[5].y, p[5].z, 0, 0, -1, p[6].x, p[6].y, p[6].z, 0, 0, -1, p[7].x, p[7].y,
                        p[7].z, 0, 0, -1);
                mpb.index((short)0, (short)1, (short)1, (short)2, (short)2, (short)3, (short)3, (short)0);
                mpb.index((short)4, (short)5, (short)5, (short)6, (short)6, (short)7, (short)7, (short)4);
                mpb.index((short)0, (short)4, (short)1, (short)5, (short)2, (short)6, (short)3, (short)7);
                return builder.end();
        }

        private float angleX, angleY, angleZ;
        private btPairCachingGhostObject frustumObject;
        private BulletEntity frustumEntity;
        private final Array<BulletEntity> visibleEntities = new Array<BulletEntity>();
        private btPersistentManifoldArray tempManifoldArr;
        private PerspectiveCamera frustumCam;
        private PerspectiveCamera overviewCam;

        @Override
        public void create () {
                super.create();

                instructions = ""Tap to toggle view\nLong press to toggle debug mode\nSwipe for next test\nCtrl+drag to rotate\nScroll to zoom"";

                tempManifoldArr = new btPersistentManifoldArray();

                world.addConstructor(""collisionBox"", new BulletConstructor(world.getConstructor(""box"").model));

                // Create the entities
                final float dX = BOX_X_MAX - BOX_X_MIN;
                final float dY = BOX_Y_MAX - BOX_Y_MIN;
                final float dZ = BOX_Z_MAX - BOX_Z_MIN;
                for (int i = 0; i < BOXCOUNT; i++)
                        world.add(""collisionBox"", BOX_X_MIN + dX * (float)Math.random(), BOX_Y_MIN + dY * (float)Math.random(),
                                BOX_Z_MIN + dZ * (float)Math.random()).setColor(Color.GRAY);

                frustumCam = new PerspectiveCamera(camera.fieldOfView, camera.viewportWidth, camera.viewportHeight);
                frustumCam.far = Vector3.len(BOX_X_MAX, BOX_Y_MAX, BOX_Z_MAX);
                frustumCam.update();

                overviewCam = camera;
                overviewCam.position.set(BOX_X_MAX, BOX_Y_MAX, BOX_Z_MAX);
                overviewCam.lookAt(Vector3.Zero);
                overviewCam.far = 150f;
                overviewCam.update();

                final Model frustumModel = createFrustumModel(frustumCam.frustum.planePoints);
                disposables.add(frustumModel);
                frustumObject = createFrustumObject(frustumCam.frustum.planePoints);
                world.add(frustumEntity = new BulletEntity(frustumModel, frustumObject, 0, 0, 0));
                frustumEntity.setColor(Color.BLUE);
        }

        @Override
        public BulletWorld createWorld () {
                // No need to use dynamics for this test
                btDbvtBroadphase broadphase = new btDbvtBroadphase();
                btDefaultCollisionConfiguration  [MASK]  = new btDefaultCollisionConfiguration();
                btCollisionDispatcher dispatcher = new btCollisionDispatcher( [MASK] );
                btCollisionWorld collisionWorld = new btCollisionWorld(dispatcher, broadphase,  [MASK] );
                return new BulletWorld( [MASK] , dispatcher, broadphase, null, collisionWorld);
        }

        @Override
        public void update () {
                super.update();
                // Not using dynamics, so update the collision world manually
                if (USE_BULLET_FRUSTUM_CULLING) {
                        if (world.performanceCounter != null) world.performanceCounter.start();
                        world.collisionWorld.performDiscreteCollisionDetection();
                        if (world.performanceCounter != null) world.performanceCounter.stop();
                }
        }

        @Override
        public void render () {
                final float dt = Gdx.graphics.getDeltaTime();
                frustumEntity.transform.idt();
                frustumEntity.transform.rotate(Vector3.X, angleX = (angleX + dt * SPEED_X) % 360);
                frustumEntity.transform.rotate(Vector3.Y, angleY = (angleY + dt * SPEED_Y) % 360);
                frustumEntity.transform.rotate(Vector3.Z, angleZ = (angleZ + dt * SPEED_Z) % 360);

                // Transform the ghost object
                frustumEntity.body.setWorldTransform(frustumEntity.transform);
                // Transform the frustum cam
                frustumCam.direction.set(0, 0, -1);
                frustumCam.up.set(0, 1, 0);
                frustumCam.position.set(0, 0, 0);
                frustumCam.rotate(frustumEntity.transform);
                frustumCam.update();

                super.render();

                performance.append("" visible: "").append(visibleEntities.size);
        }

        @Override
        protected void renderWorld () {
                if (world.performanceCounter != null) world.performanceCounter.start();
                if (USE_BULLET_FRUSTUM_CULLING)
                        getEntitiesCollidingWithObject(world, frustumObject, visibleEntities, tempManifoldArr);
                else {
                        visibleEntities.clear();
                        for (int i = 0; i < world.entities.size; i++) {
                                final BulletEntity e = world.entities.get(i);
                                if (e == frustumEntity) continue;
                                e.modelInstance.transform.getTranslation(tmpV);
                                if (frustumCam.frustum.sphereInFrustum(tmpV, 1)) visibleEntities.add(e);
                        }
                }
                if (world.performanceCounter != null) world.performanceCounter.stop();

                for (int i = 0; i < visibleEntities.size; i++)
                        visibleEntities.get(i).setColor(Color.RED);

                modelBatch.begin(camera);
                if ((state & CULL_FRUSTUM) == CULL_FRUSTUM) {
                        world.render(modelBatch, environment, visibleEntities);
                        world.render(modelBatch, environment, frustumEntity);
                } else
                        world.render(modelBatch, environment);
                modelBatch.end();

                for (int i = 0; i < visibleEntities.size; i++)
                        visibleEntities.get(i).setColor(Color.GRAY);
        }

        @Override
        protected void beginRender (boolean lighting) {
                super.beginRender(false);
        }

        @Override
        public void dispose () {
                frustumObject = null;

                super.dispose();

                if (tempManifoldArr != null) tempManifoldArr.dispose();
                tempManifoldArr = null;
        }

        @Override
        public boolean tap (float x, float y, int count, int button) {
                state = (state + 1) % 3;
                if ((state & FRUSTUM_CAM) == FRUSTUM_CAM)
                        camera = frustumCam;
                else
                        camera = overviewCam;
                return true;
        }

        // Simple helper class to keep a reference to the collision shape
        public static class TestPairCachingGhostObject extends btPairCachingGhostObject {
                public btCollisionShape shape;

                @Override
                public void setCollisionShape (btCollisionShape collisionShape) {
                        shape = collisionShape;
                        super.setCollisionShape(collisionShape);
                }

                @Override
                public void dispose () {
                        super.dispose();
                        if (shape != null) shape.dispose();
                        shape = null;
                }
        }
}
","collisionConfig
"
"package jadx.core.dex.instructions;

import java.util.List;
import java.util.Objects;

import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jadx.api.plugins.input.data.ICodeReader;
import jadx.api.plugins.input.data.IMethodProto;
import jadx.api.plugins.input.data.IMethodRef;
import jadx.api.plugins.input.insns.InsnData;
import jadx.api.plugins.input.insns.custom.IArrayPayload;
import jadx.api.plugins.input.insns.custom.ICustomPayload;
import jadx.api.plugins.input.insns.custom.ISwitchPayload;
import jadx.core.Consts;
import jadx.core.dex.attributes.AType;
import jadx.core.dex.attributes.nodes.JadxError;
import jadx.core.dex.info.FieldInfo;
import jadx.core.dex.info.MethodInfo;
import jadx.core.dex.instructions.args.ArgType;
import jadx.core.dex.instructions.args.InsnArg;
import jadx.core.dex.instructions.args.LiteralArg;
import jadx.core.dex.instructions.args.RegisterArg;
import jadx.core.dex.nodes.FieldNode;
import jadx.core.dex.nodes.InsnNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.nodes.RootNode;
import jadx.core.utils.Utils;
import jadx.core.utils.exceptions.DecodeException;
import jadx.core.utils.exceptions.JadxRuntimeException;
import jadx.core.utils.input.InsnDataUtils;

public class InsnDecoder {
	private static final Logger LOG = LoggerFactory.getLogger(InsnDecoder.class);

	private final MethodNode method;
	private final RootNode root;

	public InsnDecoder(MethodNode mthNode) {
		this.method = mthNode;
		this.root = method.root();
	}

	public InsnNode[] process(ICodeReader codeReader) {
		InsnNode[] instructions = new InsnNode[codeReader.getUnitsCount()];
		codeReader.visitInstructions(rawInsn -> {
			int offset = rawInsn.getOffset();
			InsnNode insn;
			try {
				rawInsn.decode();
				insn = decode(rawInsn);
			} catch (Exception e) {
				method.addError(""Failed to decode insn: "" + rawInsn + "", method: "" + method, e);
				insn = new InsnNode(InsnType.NOP, 0);
				insn.addAttr(AType.JADX_ERROR, new JadxError(""decode failed: "" + e.getMessage(), e));
			}
			insn.setOffset(offset);
			instructions[offset] = insn;
		});
		return instructions;
	}

	@NotNull
	protected InsnNode decode(InsnData insn) throws DecodeException {
		switch (insn.getOpcode()) {
			case NOP:
				return new InsnNode(InsnType.NOP, 0);

			// move-result will be process in invoke and filled-new-array instructions
			case MOVE_RESULT:
				return insn(InsnType.MOVE_RESULT, InsnArg.reg(insn, 0, ArgType.UNKNOWN));

			case CONST:
				LiteralArg narrowLitArg = InsnArg.lit(insn, ArgType.NARROW);
				return insn(InsnType.CONST, InsnArg.reg(insn, 0, narrowLitArg.getType()), narrowLitArg);

			case CONST_WIDE:
				LiteralArg wideLitArg = InsnArg.lit(insn, ArgType.WIDE);
				return insn(InsnType.CONST, InsnArg.reg(insn, 0, wideLitArg.getType()), wideLitArg);

			case CONST_STRING:
				InsnNode constStrInsn = new ConstStringNode(insn.getIndexAsString());
				constStrInsn.setResult(InsnArg.reg(insn, 0, ArgType.STRING));
				return constStrInsn;

			case CONST_CLASS: {
				ArgType clsType = ArgType.parse(insn.getIndexAsType());
				InsnNode constClsInsn = new ConstClassNode(clsType);
				constClsInsn.setResult(InsnArg.reg(insn, 0, ArgType.generic(Consts.CLASS_CLASS, clsType)));
				return constClsInsn;
			}

			case MOVE:
				return insn(InsnType.MOVE,
						InsnArg.reg(insn, 0, ArgType.NARROW),
						InsnArg.reg(insn, 1, ArgType.NARROW));

			case MOVE_MULTI:
				int len = insn.getRegsCount();
				InsnNode mmv = new InsnNode(InsnType.MOVE_MULTI, len);
				for (int i = 0; i < len; i++) {
					mmv.addArg(InsnArg.reg(insn, i, ArgType.UNKNOWN));
				}
				return mmv;

			case MOVE_WIDE:
				return insn(InsnType.MOVE,
						InsnArg.reg(insn, 0, ArgType.WIDE),
						InsnArg.reg(insn, 1, ArgType.WIDE));

			case MOVE_OBJECT:
				return insn(InsnType.MOVE,
						InsnArg.reg(insn, 0, ArgType.UNKNOWN_OBJECT),
						InsnArg.reg(insn, 1, ArgType.UNKNOWN_OBJECT));

			case ADD_INT:
				return arith(insn, ArithOp.ADD, ArgType.INT);

			case ADD_DOUBLE:
				return arith(insn, ArithOp.ADD, ArgType.DOUBLE);

			case ADD_FLOAT:
				return arith(insn, ArithOp.ADD, ArgType.FLOAT);

			case ADD_LONG:
				return arith(insn, ArithOp.ADD, ArgType.LONG);

			case ADD_INT_LIT:
				return arithLit(insn, ArithOp.ADD, ArgType.INT);

			case SUB_INT:
				return arith(insn, ArithOp.SUB, ArgType.INT);

			case RSUB_INT:
				return new ArithNode(ArithOp.SUB,
						InsnArg.reg(insn, 0, ArgType.INT),
						InsnArg.lit(insn, ArgType.INT),
						InsnArg.reg(insn, 1, ArgType.INT));

			case SUB_LONG:
				return arith(insn, ArithOp.SUB, ArgType.LONG);

			case SUB_FLOAT:
				return arith(insn, ArithOp.SUB, ArgType.FLOAT);

			case SUB_DOUBLE:
				return arith(insn, ArithOp.SUB, ArgType.DOUBLE);

			case MUL_INT:
				return arith(insn, ArithOp.MUL, ArgType.INT);

			case MUL_DOUBLE:
				return arith(insn, ArithOp.MUL, ArgType.DOUBLE);

			case MUL_FLOAT:
				return arith(insn, ArithOp.MUL, ArgType.FLOAT);

			case MUL_LONG:
				return arith(insn, ArithOp.MUL, ArgType.LONG);

			case MUL_INT_LIT:
				return arithLit(insn, ArithOp.MUL, ArgType.INT);

			case DIV_INT:
				return arith(insn, ArithOp.DIV, ArgType.INT);

			case REM_INT:
				return arith(insn, ArithOp.REM, ArgType.INT);

			case REM_LONG:
				return arith(insn, ArithOp.REM, ArgType.LONG);

			case REM_FLOAT:
				return arith(insn, ArithOp.REM, ArgType.FLOAT);

			case REM_DOUBLE:
				return arith(insn, ArithOp.REM, ArgType.DOUBLE);

			case DIV_DOUBLE:
				return arith(insn, ArithOp.DIV, ArgType.DOUBLE);

			case DIV_FLOAT:
				return arith(insn, ArithOp.DIV, ArgType.FLOAT);

			case DIV_LONG:
				return arith(insn, ArithOp.DIV, ArgType.LONG);

			case DIV_INT_LIT:
				return arithLit(insn, ArithOp.DIV, ArgType.INT);

			case REM_INT_LIT:
				return arithLit(insn, ArithOp.REM, ArgType.INT);

			case AND_INT:
				return arith(insn, ArithOp.AND, ArgType.INT);

			case AND_INT_LIT:
				return arithLit(insn, ArithOp.AND, ArgType.INT);

			case XOR_INT_LIT:
				return arithLit(insn, ArithOp.XOR, ArgType.INT);

			case AND_LONG:
				return arith(insn, ArithOp.AND, ArgType.LONG);

			case OR_INT:
				return arith(insn, ArithOp.OR, ArgType.INT);

			case OR_INT_LIT:
				return arithLit(insn, ArithOp.OR, ArgType.INT);

			case XOR_INT:
				return arith(insn, ArithOp.XOR, ArgType.INT);

			case OR_LONG:
				return arith(insn, ArithOp.OR, ArgType.LONG);

			case XOR_LONG:
				return arith(insn, ArithOp.XOR, ArgType.LONG);

			case USHR_INT:
				return arith(insn, ArithOp.USHR, ArgType.INT);

			case USHR_LONG:
				return arith(insn, ArithOp.USHR, ArgType.LONG);

			case SHL_INT:
				return arith(insn, ArithOp.SHL, ArgType.INT);

			case SHL_LONG:
				return arith(insn, ArithOp.SHL, ArgType.LONG);

			case SHR_INT:
				return arith(insn, ArithOp.SHR, ArgType.INT);

			case SHR_LONG:
				return arith(insn, ArithOp.SHR, ArgType.LONG);

			case SHL_INT_LIT:
				return arithLit(insn, ArithOp.SHL, ArgType.INT);
			case SHR_INT_LIT:
				return arithLit(insn, ArithOp.SHR, ArgType.INT);
			case USHR_INT_LIT:
				return arithLit(insn, ArithOp.USHR, ArgType.INT);

			case NEG_INT:
				return neg(insn, ArgType.INT);
			case NEG_LONG:
				return neg(insn, ArgType.LONG);
			case NEG_FLOAT:
				return neg(insn, ArgType.FLOAT);
			case NEG_DOUBLE:
				return neg(insn, ArgType.DOUBLE);

			case NOT_INT:
				return not(insn, ArgType.INT);
			case NOT_LONG:
				return not(insn, ArgType.LONG);

			case INT_TO_BYTE:
				return cast(insn, ArgType.INT, ArgType.BYTE);
			case INT_TO_CHAR:
				return cast(insn, ArgType.INT, ArgType.CHAR);
			case INT_TO_SHORT:
				return cast(insn, ArgType.INT, ArgType.SHORT);
			case INT_TO_FLOAT:
				return cast(insn, ArgType.INT, ArgType.FLOAT);
			case INT_TO_DOUBLE:
				return cast(insn, ArgType.INT, ArgType.DOUBLE);
			case INT_TO_LONG:
				return cast(insn, ArgType.INT, ArgType.LONG);

			case FLOAT_TO_INT:
				return cast(insn, ArgType.FLOAT, ArgType.INT);
			case FLOAT_TO_DOUBLE:
				return cast(insn, ArgType.FLOAT, ArgType.DOUBLE);
			case FLOAT_TO_LONG:
				return cast(insn, ArgType.FLOAT, ArgType.LONG);

			case DOUBLE_TO_INT:
				return cast(insn, ArgType.DOUBLE, ArgType.INT);
			case DOUBLE_TO_FLOAT:
				return cast(insn, ArgType.DOUBLE, ArgType.FLOAT);
			case DOUBLE_TO_LONG:
				return cast(insn, ArgType.DOUBLE, ArgType.LONG);

			case LONG_TO_INT:
				return cast(insn, ArgType.LONG, ArgType.INT);
			case LONG_TO_FLOAT:
				return cast(insn, ArgType.LONG, ArgType.FLOAT);
			case LONG_TO_DOUBLE:
				return cast(insn, ArgType.LONG, ArgType.DOUBLE);

			case IF_EQ:
			case IF_EQZ:
				return new IfNode(insn, IfOp.EQ);

			case IF_NE:
			case IF_NEZ:
				return new IfNode(insn, IfOp.NE);

			case IF_GT:
			case IF_GTZ:
				return new IfNode(insn, IfOp.GT);

			case IF_GE:
			case IF_GEZ:
				return new IfNode(insn, IfOp.GE);

			case IF_LT:
			case IF_LTZ:
				return new IfNode(insn, IfOp.LT);

			case IF_LE:
			case IF_LEZ:
				return new IfNode(insn, IfOp.LE);

			case CMP_LONG:
				return cmp(insn, InsnType.CMP_L, ArgType.LONG);
			case CMPL_FLOAT:
				return cmp(insn, InsnType.CMP_L, ArgType.FLOAT);
			case CMPL_DOUBLE:
				return cmp(insn, InsnType.CMP_L, ArgType.DOUBLE);

			case CMPG_FLOAT:
				return cmp(insn, InsnType.CMP_G, ArgType.FLOAT);
			case CMPG_DOUBLE:
				return cmp(insn, InsnType.CMP_G, ArgType.DOUBLE);

			case GOTO:
				return new GotoNode(insn.getTarget());

			case THROW:
				return insn(InsnType.THROW, null, InsnArg.reg(insn, 0, ArgType.THROWABLE));

			case MOVE_EXCEPTION:
				return insn(InsnType.MOVE_EXCEPTION, InsnArg.reg(insn, 0, ArgType.UNKNOWN_OBJECT_NO_ARRAY));

			case RETURN_VOID:
				return new InsnNode(InsnType.RETURN, 0);

			case RETURN:
				return insn(InsnType.RETURN,
						null,
						InsnArg.reg(insn, 0, method.getReturnType()));

			case INSTANCE_OF:
				InsnNode instInsn = new IndexInsnNode(InsnType.INSTANCE_OF, ArgType.parse(insn.getIndexAsType()), 1);
				instInsn.setResult(InsnArg.reg(insn, 0, ArgType.BOOLEAN));
				instInsn.addArg(InsnArg.reg(insn, 1, ArgType.UNKNOWN_OBJECT));
				return instInsn;

			case CHECK_CAST:
				ArgType castType = ArgType.parse(insn.getIndexAsType());
				InsnNode checkCastInsn = new IndexInsnNode(InsnType.CHECK_CAST, castType, 1);
				checkCastInsn.setResult(InsnArg.reg(insn, 0, castType));
				checkCastInsn.addArg(InsnArg.reg(insn, insn.getRegsCount() == 2 ? 1 : 0, ArgType.UNKNOWN_OBJECT));
				return checkCastInsn;

			case IGET:
				FieldInfo igetFld = FieldInfo.fromRef(root, insn.getIndexAsField());
				InsnNode igetInsn = new IndexInsnNode(InsnType.IGET, igetFld, 1);
				igetInsn.setResult(InsnArg.reg(insn, 0, tryResolveFieldType(igetFld)));
				igetInsn.addArg(InsnArg.reg(insn, 1, igetFld.getDeclClass().getType()));
				return igetInsn;

			case IPUT:
				FieldInfo iputFld = FieldInfo.fromRef(root, insn.getIndexAsField());
				InsnNode iputInsn = new IndexInsnNode(InsnType.IPUT, iputFld, 2);
				iputInsn.addArg(InsnArg.reg(insn, 0, tryResolveFieldType(iputFld)));
				iputInsn.addArg(InsnArg.reg(insn, 1, iputFld.getDeclClass().getType()));
				return iputInsn;

			case SGET:
				FieldInfo sgetFld = FieldInfo.fromRef(root, insn.getIndexAsField());
				InsnNode sgetInsn = new IndexInsnNode(InsnType.SGET, sgetFld, 0);
				sgetInsn.setResult(InsnArg.reg(insn, 0, tryResolveFieldType(sgetFld)));
				return sgetInsn;

			case SPUT:
				FieldInfo sputFld = FieldInfo.fromRef(root, insn.getIndexAsField());
				InsnNode sputInsn = new IndexInsnNode(InsnType.SPUT, sputFld, 1);
				sputInsn.addArg(InsnArg.reg(insn, 0, tryResolveFieldType(sputFld)));
				return sputInsn;

			case ARRAY_LENGTH:
				InsnNode arrLenInsn = new InsnNode(InsnType.ARRAY_LENGTH, 1);
				arrLenInsn.setResult(InsnArg.reg(insn, 0, ArgType.INT));
				arrLenInsn.addArg(InsnArg.reg(insn, 1, ArgType.array(ArgType.UNKNOWN)));
				return arrLenInsn;

			case AGET:
				return arrayGet(insn, ArgType.INT_FLOAT, ArgType.NARROW_NUMBERS_NO_BOOL);
			case AGET_BOOLEAN:
				return arrayGet(insn, ArgType.BOOLEAN);
			case AGET_BYTE:
				return arrayGet(insn, ArgType.BYTE, ArgType.NARROW_INTEGRAL);
			case AGET_BYTE_BOOLEAN:
				return arrayGet(insn, ArgType.BYTE_BOOLEAN);
			case AGET_CHAR:
				return arrayGet(insn, ArgType.CHAR);
			case AGET_SHORT:
				return arrayGet(insn, ArgType.SHORT);
			case AGET_WIDE:
				return arrayGet(insn, ArgType.WIDE);
			case AGET_OBJECT:
				return arrayGet(insn, ArgType.UNKNOWN_OBJECT);

			case APUT:
				return arrayPut(insn, ArgType.INT_FLOAT, ArgType.NARROW_NUMBERS_NO_BOOL);
			case APUT_BOOLEAN:
				return arrayPut(insn, ArgType.BOOLEAN);
			case APUT_BYTE:
				return arrayPut(insn, ArgType.BYTE);
			case APUT_BYTE_BOOLEAN:
				return arrayPut(insn, ArgType.BYTE_BOOLEAN);
			case APUT_CHAR:
				return arrayPut(insn, ArgType.CHAR);
			case APUT_SHORT:
				return arrayPut(insn, ArgType.SHORT);
			case APUT_WIDE:
				return arrayPut(insn, ArgType.WIDE);
			case APUT_OBJECT:
				return arrayPut(insn, ArgType.UNKNOWN_OBJECT);

			case INVOKE_STATIC:
				return invoke(insn, InvokeType.STATIC, false);

			case INVOKE_STATIC_RANGE:
				return invoke(insn, InvokeType.STATIC, true);

			case INVOKE_DIRECT:
				return invoke(insn, InvokeType.DIRECT, false);
			case INVOKE_INTERFACE:
				return invoke(insn, InvokeType.INTERFACE, false);
			case INVOKE_SUPER:
				return invoke(insn, InvokeType.SUPER, false);
			case INVOKE_VIRTUAL:
				return invoke(insn, InvokeType.VIRTUAL, false);
			case INVOKE_CUSTOM:
				return invokeCustom(insn, false);
			case INVOKE_SPECIAL:
				return invokeSpecial(insn);
			case INVOKE_POLYMORPHIC:
				return invokePolymorphic(insn, false);

			case INVOKE_DIRECT_RANGE:
				return invoke(insn, InvokeType.DIRECT, true);
			case INVOKE_INTERFACE_RANGE:
				return invoke(insn, InvokeType.INTERFACE, true);
			case INVOKE_SUPER_RANGE:
				return invoke(insn, InvokeType.SUPER, true);
			case INVOKE_VIRTUAL_RANGE:
				return invoke(insn, InvokeType.VIRTUAL, true);
			case INVOKE_CUSTOM_RANGE:
				return invokeCustom(insn, true);
			case INVOKE_POLYMORPHIC_RANGE:
				return invokePolymorphic(insn, true);

			case NEW_INSTANCE:
				ArgType clsType = ArgType.parse(insn.getIndexAsType());
				IndexInsnNode newInstInsn = new IndexInsnNode(InsnType.NEW_INSTANCE, clsType, 0);
				newInstInsn.setResult(InsnArg.reg(insn, 0, clsType));
				return newInstInsn;

			case NEW_ARRAY:
				return makeNewArray(insn);

			case FILL_ARRAY_DATA:
				return new FillArrayInsn(InsnArg.reg(insn, 0, ArgType.UNKNOWN_ARRAY), insn.getTarget());
			case FILL_ARRAY_DATA_PAYLOAD:
				return new FillArrayData(((IArrayPayload) Objects.requireNonNull(insn.getPayload())));

			case FILLED_NEW_ARRAY:
				return filledNewArray(insn, false);
			case FILLED_NEW_ARRAY_RANGE:
				return filledNewArray(insn, true);

			case PACKED_SWITCH:
				return makeSwitch(insn, true);
			case SPARSE_SWITCH:
				return makeSwitch(insn, false);

			case PACKED_SWITCH_PAYLOAD:
			case SPARSE_SWITCH_PAYLOAD:
				return new SwitchData(((ISwitchPayload) insn.getPayload()));

			case MONITOR_ENTER:
				return insn(InsnType.MONITOR_ENTER,
						null,
						InsnArg.reg(insn, 0, ArgType.UNKNOWN_OBJECT));

			case MONITOR_EXIT:
				return insn(InsnType.MONITOR_EXIT,
						null,
						InsnArg.reg(insn, 0, ArgType.UNKNOWN_OBJECT));

			default:
				throw new DecodeException(""Unknown instruction: '"" + insn + '\'');
		}
	}

	@NotNull
	private SwitchInsn makeSwitch(InsnData insn, boolean packed) {
		SwitchInsn swInsn = new SwitchInsn(InsnArg.reg(insn, 0, ArgType.UNKNOWN), insn.getTarget(), packed);
		ICustomPayload payload = insn.getPayload();
		if (payload != null) {
			swInsn.attachSwitchData(new SwitchData((ISwitchPayload) payload), insn.getTarget());
		}
		return swInsn;
	}

	private InsnNode makeNewArray(InsnData insn) {
		ArgType indexType = ArgType.parse(insn.getIndexAsType());
		int dim = (int) insn.getLiteral();
		ArgType arrType;
		if (dim == 0) {
			arrType = indexType;
		} else {
			if (indexType.isArray()) {
				// java bytecode can pass array as a base type
				arrType = indexType;
			} else {
				arrType = ArgType.array(indexType, dim);
			}
		}
		int regsCount = insn.getRegsCount();
		NewArrayNode newArr = new NewArrayNode(arrType, regsCount - 1);
		newArr.setResult(InsnArg.reg(insn, 0, arrType));
		for (int i = 1; i < regsCount; i++) {
			newArr.addArg(InsnArg.typeImmutableReg(insn, i, ArgType.INT));
		}
		return newArr;
	}

	private ArgType tryResolveFieldType(FieldInfo igetFld) {
		FieldNode  [MASK]  = root.resolveField(igetFld);
		if ( [MASK]  != null) {
			return  [MASK] .getType();
		}
		return igetFld.getType();
	}

	private InsnNode filledNewArray(InsnData insn, boolean isRange) {
		ArgType arrType = ArgType.parse(insn.getIndexAsType());
		ArgType elType = arrType.getArrayElement();
		boolean typeImmutable = elType.isPrimitive();
		int regsCount = insn.getRegsCount();
		InsnArg[] regs = new InsnArg[regsCount];
		if (isRange) {
			int r = insn.getReg(0);
			for (int i = 0; i < regsCount; i++) {
				regs[i] = InsnArg.reg(r, elType, typeImmutable);
				r++;
			}
		} else {
			for (int i = 0; i < regsCount; i++) {
				int regNum = insn.getReg(i);
				regs[i] = InsnArg.reg(regNum, elType, typeImmutable);
			}
		}
		InsnNode node = new FilledNewArrayNode(elType, regs.length);
		// node.setResult(resReg == -1 ? null : InsnArg.reg(resReg, arrType));
		for (InsnArg arg : regs) {
			node.addArg(arg);
		}
		return node;
	}

	private InsnNode cmp(InsnData insn, InsnType itype, ArgType argType) {
		InsnNode inode = new InsnNode(itype, 2);
		inode.setResult(InsnArg.reg(insn, 0, ArgType.INT));
		inode.addArg(InsnArg.reg(insn, 1, argType));
		inode.addArg(InsnArg.reg(insn, 2, argType));
		return inode;
	}

	private InsnNode cast(InsnData insn, ArgType from, ArgType to) {
		InsnNode inode = new IndexInsnNode(InsnType.CAST, to, 1);
		inode.setResult(InsnArg.reg(insn, 0, to));
		inode.addArg(InsnArg.reg(insn, 1, from));
		return inode;
	}

	private InsnNode invokeCustom(InsnData insn, boolean isRange) {
		return InvokeCustomBuilder.build(method, insn, isRange);
	}

	private InsnNode invokePolymorphic(InsnData insn, boolean isRange) {
		IMethodRef mthRef = InsnDataUtils.getMethodRef(insn);
		if (mthRef == null) {
			throw new JadxRuntimeException(""Failed to load method reference for insn: "" + insn);
		}
		MethodInfo callMth = MethodInfo.fromRef(root, mthRef);
		IMethodProto proto = insn.getIndexAsProto(insn.getTarget());

		// expand call args
		List<ArgType> args = Utils.collectionMap(proto.getArgTypes(), ArgType::parse);
		ArgType returnType = ArgType.parse(proto.getReturnType());
		MethodInfo effectiveCallMth = MethodInfo.fromDetails(root, callMth.getDeclClass(),
				callMth.getName(), args, returnType);
		return new InvokePolymorphicNode(effectiveCallMth, insn, proto, callMth, isRange);
	}

	private InsnNode invokeSpecial(InsnData insn) {
		IMethodRef mthRef = InsnDataUtils.getMethodRef(insn);
		if (mthRef == null) {
			throw new JadxRuntimeException(""Failed to load method reference for insn: "" + insn);
		}
		MethodInfo mthInfo = MethodInfo.fromRef(root, mthRef);
		// convert 'special' to 'direct/super' same as dx
		InvokeType type;
		if (mthInfo.isConstructor() || Objects.equals(mthInfo.getDeclClass(), method.getParentClass().getClassInfo())) {
			type = InvokeType.DIRECT;
		} else {
			type = InvokeType.SUPER;
		}
		return new InvokeNode(mthInfo, insn, type, false);
	}

	private InsnNode invoke(InsnData insn, InvokeType type, boolean isRange) {
		IMethodRef mthRef = InsnDataUtils.getMethodRef(insn);
		if (mthRef == null) {
			throw new JadxRuntimeException(""Failed to load method reference for insn: "" + insn);
		}
		MethodInfo mthInfo = MethodInfo.fromRef(root, mthRef);
		return new InvokeNode(mthInfo, insn, type, isRange);
	}

	private InsnNode arrayGet(InsnData insn, ArgType argType) {
		return arrayGet(insn, argType, argType);
	}

	private InsnNode arrayGet(InsnData insn, ArgType arrElemType, ArgType resType) {
		InsnNode inode = new InsnNode(InsnType.AGET, 2);
		inode.setResult(InsnArg.typeImmutableIfKnownReg(insn, 0, resType));
		inode.addArg(InsnArg.typeImmutableIfKnownReg(insn, 1, ArgType.array(arrElemType)));
		inode.addArg(InsnArg.reg(insn, 2, ArgType.NARROW_INTEGRAL));
		return inode;
	}

	private InsnNode arrayPut(InsnData insn, ArgType argType) {
		return arrayPut(insn, argType, argType);
	}

	private InsnNode arrayPut(InsnData insn, ArgType arrElemType, ArgType argType) {
		InsnNode inode = new InsnNode(InsnType.APUT, 3);
		inode.addArg(InsnArg.typeImmutableIfKnownReg(insn, 1, ArgType.array(arrElemType)));
		inode.addArg(InsnArg.reg(insn, 2, ArgType.NARROW_INTEGRAL));
		inode.addArg(InsnArg.typeImmutableIfKnownReg(insn, 0, argType));
		return inode;
	}

	private InsnNode arith(InsnData insn, ArithOp op, ArgType type) {
		return ArithNode.build(insn, op, type);
	}

	private InsnNode arithLit(InsnData insn, ArithOp op, ArgType type) {
		return ArithNode.buildLit(insn, op, type);
	}

	private InsnNode neg(InsnData insn, ArgType type) {
		InsnNode inode = new InsnNode(InsnType.NEG, 1);
		inode.setResult(InsnArg.reg(insn, 0, type));
		inode.addArg(InsnArg.reg(insn, 1, type));
		return inode;
	}

	private InsnNode not(InsnData insn, ArgType type) {
		InsnNode inode = new InsnNode(InsnType.NOT, 1);
		inode.setResult(InsnArg.reg(insn, 0, type));
		inode.addArg(InsnArg.reg(insn, 1, type));
		return inode;
	}

	private InsnNode insn(InsnType type, RegisterArg res) {
		InsnNode node = new InsnNode(type, 0);
		node.setResult(res);
		return node;
	}

	private InsnNode insn(InsnType type, RegisterArg res, InsnArg arg) {
		InsnNode node = new InsnNode(type, 1);
		node.setResult(res);
		node.addArg(arg);
		return node;
	}
}
","fieldNode
"
"package com.google.android.exoplayer2.upstream;

import static com.google.android.exoplayer2.util.Util.castNonNull;
import static java.lang.Math.min;

import android.content.ContentResolver;
import android.content.Context;
import android.content.res.AssetFileDescriptor;
import android.net.Uri;
import android.os.Bundle;
import android.provider.MediaStore;
import androidx.annotation.Nullable;
import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.PlaybackException;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.channels.FileChannel;

/**
* A {@link DataSource} for reading from a content URI.
*
* @deprecated com.google.android.exoplayer2 is deprecated. Please migrate to androidx.media3 (which
* contains the same ExoPlayer code). See <a
* href=""https://developer.android.com/guide/topics/media/media3/getting-started/migration-guide"">the
* migration guide</a> for more details, including a script to help with the migration.
*/
@Deprecated
public final class ContentDataSource extends BaseDataSource {

/** Thrown when an {@link IOException} is encountered reading from a content URI. */
public static class ContentDataSourceException extends DataSourceException {

/**
* @deprecated Use {@link #ContentDataSourceException(IOException, int)}.
*/
@Deprecated
public ContentDataSourceException(IOException cause) {
this(cause, PlaybackException.ERROR_CODE_IO_UNSPECIFIED);
}

/** Creates a new instance. */
public ContentDataSourceException(
@Nullable IOException cause, @PlaybackException.ErrorCode int errorCode) {
super(cause, errorCode);
}
}

private final ContentResolver resolver;

@Nullable private Uri uri;
@Nullable private AssetFileDescriptor assetFileDescriptor;
@Nullable private FileInputStream inputStream;
private long bytesRemaining;
private boolean opened;

/**
* @param context A context.
*/
public ContentDataSource(Context context) {
super(/* isNetwork= */ false);
this.resolver = context.getContentResolver();
}

@Override
@SuppressWarnings(""InlinedApi"") // We are inlining EXTRA_ACCEPT_ORIGINAL_MEDIA_FORMAT.
public long open(DataSpec dataSpec) throws ContentDataSourceException {
try {
Uri uri = dataSpec.uri.normalizeScheme();
this.uri = uri;

transferInitializing(dataSpec);

AssetFileDescriptor assetFileDescriptor;
if (""content"".equals(uri.getScheme())) {
Bundle providerOptions = new Bundle();
// We don't want compatible media transcoding.
providerOptions.putBoolean(MediaStore.EXTRA_ACCEPT_ORIGINAL_MEDIA_FORMAT, true);
assetFileDescriptor =
resolver.openTypedAssetFileDescriptor(uri, /* mimeType= */ ""*/*"", providerOptions);
} else {
// This path supports file URIs, although support may be removed in the future. See
// [Internal ref: b/195384732].
assetFileDescriptor = resolver.openAssetFileDescriptor(uri, ""r"");
}
this.assetFileDescriptor = assetFileDescriptor;
if (assetFileDescriptor == null) {
// assetFileDescriptor may be null if the provider recently crashed.
throw new ContentDataSourceException(
new IOException(""Could not open file descriptor for: "" + uri),
PlaybackException.ERROR_CODE_IO_UNSPECIFIED);
}

long assetFileDescriptorLength = assetFileDescriptor.getLength();
FileInputStream inputStream = new FileInputStream(assetFileDescriptor.getFileDescriptor());
this.inputStream = inputStream;

if (assetFileDescriptorLength != AssetFileDescriptor.UNKNOWN_LENGTH
&& dataSpec.position > assetFileDescriptorLength) {
throw new ContentDataSourceException(
/* cause= */ null, PlaybackException.ERROR_CODE_IO_READ_POSITION_OUT_OF_RANGE);
}
long assetFileDescriptorOffset = assetFileDescriptor.getStartOffset();
long [MASK] =
inputStream.skip(assetFileDescriptorOffset + dataSpec.position)
- assetFileDescriptorOffset;
if ( [MASK] != dataSpec.position) {
// We expect the skip to be satisfied in full. If it isn't then we're probably trying to
// read beyond the end of the last resource in the file.
throw new ContentDataSourceException(
/* cause= */ null, PlaybackException.ERROR_CODE_IO_READ_POSITION_OUT_OF_RANGE);
}
if (assetFileDescriptorLength == AssetFileDescriptor.UNKNOWN_LENGTH) {
// The asset must extend to the end of the file. We can try and resolve the length with
// FileInputStream.getChannel().size().
FileChannel channel = inputStream.getChannel();
long channelSize = channel.size();
if (channelSize == 0) {
bytesRemaining = C.LENGTH_UNSET;
} else {
bytesRemaining = channelSize - channel.position();
if (bytesRemaining < 0) {
// The skip above was satisfied in full, but skipped beyond the end of the file.
throw new ContentDataSourceException(
/* cause= */ null, PlaybackException.ERROR_CODE_IO_READ_POSITION_OUT_OF_RANGE);
}
}
} else {
bytesRemaining = assetFileDescriptorLength - [MASK] ;
if (bytesRemaining < 0) {
throw new ContentDataSourceException(
/* cause= */ null, PlaybackException.ERROR_CODE_IO_READ_POSITION_OUT_OF_RANGE);
}
}
} catch (ContentDataSourceException e) {
throw e;
} catch (IOException e) {
throw new ContentDataSourceException(
e,
e instanceof FileNotFoundException
? PlaybackException.ERROR_CODE_IO_FILE_NOT_FOUND
: PlaybackException.ERROR_CODE_IO_UNSPECIFIED);
}

if (dataSpec.length != C.LENGTH_UNSET) {
bytesRemaining =
bytesRemaining == C.LENGTH_UNSET ? dataSpec.length : min(bytesRemaining, dataSpec.length);
}
opened = true;
transferStarted(dataSpec);
return dataSpec.length != C.LENGTH_UNSET ? dataSpec.length : bytesRemaining;
}

@Override
public int read(byte[] buffer, int offset, int length) throws ContentDataSourceException {
if (length == 0) {
return 0;
} else if (bytesRemaining == 0) {
return C.RESULT_END_OF_INPUT;
}

int bytesRead;
try {
int bytesToRead =
bytesRemaining == C.LENGTH_UNSET ? length : (int) min(bytesRemaining, length);
bytesRead = castNonNull(inputStream).read(buffer, offset, bytesToRead);
} catch (IOException e) {
throw new ContentDataSourceException(e, PlaybackException.ERROR_CODE_IO_UNSPECIFIED);
}

if (bytesRead == -1) {
return C.RESULT_END_OF_INPUT;
}
if (bytesRemaining != C.LENGTH_UNSET) {
bytesRemaining -= bytesRead;
}
bytesTransferred(bytesRead);
return bytesRead;
}

@Override
@Nullable
public Uri getUri() {
return uri;
}

@SuppressWarnings(""Finally"")
@Override
public void close() throws ContentDataSourceException {
uri = null;
try {
if (inputStream != null) {
inputStream.close();
}
} catch (IOException e) {
throw new ContentDataSourceException(e, PlaybackException.ERROR_CODE_IO_UNSPECIFIED);
} finally {
inputStream = null;
try {
if (assetFileDescriptor != null) {
assetFileDescriptor.close();
}
} catch (IOException e) {
throw new ContentDataSourceException(e, PlaybackException.ERROR_CODE_IO_UNSPECIFIED);
} finally {
assetFileDescriptor = null;
if (opened) {
opened = false;
transferEnded();
}
}
}
}
}

","skipped
"
"package proguard.classfile.editor;

import proguard.classfile.*;
import proguard.classfile.attribute.*;
import proguard.classfile.attribute.annotation.*;
import proguard.classfile.attribute.annotation.target.*;
import proguard.classfile.attribute.annotation.target.visitor.*;
import proguard.classfile.attribute.annotation.visitor.TypeAnnotationVisitor;
import proguard.classfile.attribute.preverification.*;
import proguard.classfile.attribute.preverification.visitor.*;
import proguard.classfile.attribute.visitor.*;
import proguard.classfile.instruction.*;
import proguard.classfile.instruction.visitor.InstructionVisitor;
import proguard.classfile.util.SimplifiedVisitor;
import proguard.classfile.visitor.ClassPrinter;
import proguard.util.ArrayUtil;

import java.util.Arrays;

/**
* This AttributeVisitor accumulates instructions and exceptions, and then
* copies them into code attributes that it visits.
*
* @author Eric Lafortune
*/
public class CodeAttributeComposer
extends SimplifiedVisitor
implements AttributeVisitor,
InstructionVisitor,
ExceptionInfoVisitor,
StackMapFrameVisitor,
VerificationTypeVisitor,
LineNumberInfoVisitor,
LocalVariableInfoVisitor,
LocalVariableTypeInfoVisitor,
TypeAnnotationVisitor,
TargetInfoVisitor,
LocalVariableTargetElementVisitor
{
//*
private static final boolean DEBUG = false;
/*/
public static boolean DEBUG = false;
//*/


private static final int MAXIMUM_LEVELS = 32;
private static final int INVALID = -1;


private final boolean allowExternalBranchTargets;
private final boolean allowExternalExceptionHandlers;
private final boolean shrinkInstructions;

private int maximumCodeLength;
private int codeLength;
private int exceptionTableLength;
private int lineNumberTableLength;
private int level = -1;

private byte[] code = new byte[ClassConstants.TYPICAL_CODE_LENGTH];
private int[] oldInstructionOffsets = new int[ClassConstants.TYPICAL_CODE_LENGTH];

private final int[] codeFragmentOffsets = new int[MAXIMUM_LEVELS];
private final int[] codeFragmentLengths = new int[MAXIMUM_LEVELS];
private final int[][] instructionOffsetMap = new int[MAXIMUM_LEVELS][ClassConstants.TYPICAL_CODE_LENGTH + 1];

private ExceptionInfo[] exceptionTable = new ExceptionInfo[ClassConstants.TYPICAL_EXCEPTION_TABLE_LENGTH];
private LineNumberInfo[] lineNumberTable = new LineNumberInfo[ClassConstants.TYPICAL_LINE_NUMBER_TABLE_LENGTH];

private int expectedStackMapFrameOffset;

private final StackSizeUpdater stackSizeUpdater = new StackSizeUpdater();
private final VariableSizeUpdater variableSizeUpdater = new VariableSizeUpdater();
private final InstructionWriter instructionWriter = new InstructionWriter();


/**
* Creates a new CodeAttributeComposer that doesn't allow external branch
* targets or exception handlers and that automatically shrinks
* instructions.
*/
public CodeAttributeComposer()
{
this(false, false, true);
}


/**
* Creates a new CodeAttributeComposer.
* @param allowExternalBranchTargets specifies whether branch targets
* can lie outside the code fragment
* of the branch instructions.
* @param allowExternalExceptionHandlers specifies whether exception
* handlers can lie outside the code
* fragment in which exceptions are
* defined.
* @param shrinkInstructions specifies whether instructions
* should automatically be shrunk
* before being written.
*/
public CodeAttributeComposer(boolean allowExternalBranchTargets,
boolean allowExternalExceptionHandlers,
boolean shrinkInstructions)
{
this.allowExternalBranchTargets = allowExternalBranchTargets;
this.allowExternalExceptionHandlers = allowExternalExceptionHandlers;
this.shrinkInstructions = shrinkInstructions;
}


/**
* Starts a new code definition.
*/
public void reset()
{
maximumCodeLength = 0;
codeLength = 0;
exceptionTableLength = 0;
lineNumberTableLength = 0;
level = -1;

// Make sure the instruction writer has at least the same buffer size
// as the local arrays.
instructionWriter.reset(code.length);
}


/**
* Starts a new code fragment. Branch instructions that are added are
* assumed to be relative within such code fragments.
* @param maximumCodeFragmentLength the maximum length of the code that will
* be added as part of this fragment (more
* precisely, the maximum old instruction
* offset or label that is specified, plus
* one).
*/
public void beginCodeFragment(int maximumCodeFragmentLength)
{
level++;

if (level >= MAXIMUM_LEVELS)
{
throw new IllegalArgumentException(""Maximum number of code fragment levels exceeded [""+level+""]"");
}

// Make sure there is sufficient space for adding the code fragment.
// It's only a rough initial estimate for the code length, not even
// necessarily a length expressed in bytes.
maximumCodeLength += maximumCodeFragmentLength;

ensureCodeLength(maximumCodeLength);

// Try to reuse the previous array for this code fragment.
if (instructionOffsetMap[level].length <= maximumCodeFragmentLength)
{
instructionOffsetMap[level] = new int[maximumCodeFragmentLength + 1];
}

// Initialize the offset map.
for (int index = 0; index <= maximumCodeFragmentLength; index++)
{
instructionOffsetMap[level][index] = INVALID;
}

// Remember the location of the code fragment.
codeFragmentOffsets[level] = codeLength;
codeFragmentLengths[level] = maximumCodeFragmentLength;
}


/**
* Appends the given instruction with the given old offset.
* Branch instructions must fit, for instance by enabling automatic
* shrinking of instructions.
* @param oldInstructionOffset the old offset of the instruction, to which
* branches and other references in the current
* code fragment are pointing.
* @param instruction the instruction to be appended.
*/
public void appendInstruction(int oldInstructionOffset,
Instruction instruction)
{
if (shrinkInstructions)
{
instruction = instruction.shrink();
}

if (DEBUG)
{
println(""[""+codeLength+""] <- "", instruction.toString(oldInstructionOffset));
}

// Make sure the code and offset arrays are large enough.
int newCodeLength = codeLength + instruction.length(codeLength);

ensureCodeLength(newCodeLength);

// Remember the old offset of the appended instruction.
oldInstructionOffsets[codeLength] = oldInstructionOffset;

// Fill out the new offset of the appended instruction.
instructionOffsetMap[level][oldInstructionOffset] = codeLength;

// Write the instruction. The instruction writer may widen it later on,
// if necessary.
instruction.accept(null,
null,
new CodeAttribute(0, 0, 0, 0, code, 0, null, 0, null),
codeLength,
instructionWriter);
//instruction.write(code, codeLength);

// Continue appending at the next instruction offset.
codeLength = newCodeLength;
}


/**
* Appends the given label with the given old offset.
* @param oldInstructionOffset the old offset of the label, to which
* branches and other references in the current
* code fragment are pointing.
*/
public void appendLabel(int oldInstructionOffset)
{
if (DEBUG)
{
println(""[""+codeLength+""] <- "", ""["" + oldInstructionOffset + ""] (label)"");
}

// Make sure the code and offset arrays are large enough.
ensureCodeLength(codeLength + 1);

// Remember the old offset of the following instruction.
oldInstructionOffsets[codeLength] = oldInstructionOffset;

// Fill out the new offset of the following instruction.
instructionOffsetMap[level][oldInstructionOffset] = codeLength;
}


/**
* Appends the given instruction without defined offsets.
* @param instructions the instructions to be appended.
*/
public void appendInstructions(Instruction[] instructions)
{
for (int index = 0; index < instructions.length; index++)
{
appendInstruction(instructions[index]);
}
}


/**
* Appends the given instruction without a defined offset.
* Branch instructions should have a label, to allow computing the
* new relative offset.
* Branch instructions must fit, for instance by enabling automatic
* shrinking of instructions.
* @param instruction the instruction to be appended.
*/
public void appendInstruction(Instruction instruction)
{
if (shrinkInstructions)
{
instruction = instruction.shrink();
}

if (DEBUG)
{
println(""[""+codeLength+""] <- "", instruction.toString());
}

// Make sure the code array is large enough.
int newCodeLength = codeLength + instruction.length(codeLength);

ensureCodeLength(newCodeLength);

// Write the instruction. The instruction writer may widen it later on,
// if necessary.
instruction.accept(null,
null,
new CodeAttribute(0, 0, 0, 0, code, 0, null, 0, null),
codeLength,
instructionWriter);
//instruction.write(code, codeLength);

// Continue appending at the next instruction offset.
codeLength = newCodeLength;
}


/**
* Appends the given exception to the exception table.
* @param exceptionInfo the exception to be appended.
*/
public void appendException(ExceptionInfo exceptionInfo)
{
if (DEBUG)
{
print("" "", ""Exception [""+exceptionInfo.u2startPC+"" -> ""+exceptionInfo.u2endPC+"": ""+exceptionInfo.u2handlerPC+""]"");
}

// Remap the exception right away.
visitExceptionInfo(null, null, null, exceptionInfo);

if (DEBUG)
{
System.out.println("" -> [""+exceptionInfo.u2startPC+"" -> ""+exceptionInfo.u2endPC+"": ""+exceptionInfo.u2handlerPC+""]"");
}

// Don't add the exception if its instruction range is empty.
if (exceptionInfo.u2startPC == exceptionInfo.u2endPC)
{
if (DEBUG)
{
println("" "", "" (not added because of empty instruction range)"");
}

return;
}

// Add the exception.
exceptionTable =
(ExceptionInfo[])ArrayUtil.add(exceptionTable,
exceptionTableLength++,
exceptionInfo);
}


/**
* Inserts the given line number at the appropriate position in the line
* number table.
* @param lineNumberInfo the line number to be inserted.
* @return the index where the line number was actually inserted.
*/
public int insertLineNumber(LineNumberInfo lineNumberInfo)
{
return insertLineNumber(0, lineNumberInfo);
}


/**
* Inserts the given line number at the appropriate position in the line
* number table.
* @param minimumIndex the minimum index where the line number may be
* inserted.
* @param lineNumberInfo the line number to be inserted.
* @return the index where the line number was inserted.
*/
public int insertLineNumber(int minimumIndex, LineNumberInfo lineNumberInfo)
{
if (DEBUG)
{
print("" "", ""Line number [""+lineNumberInfo.u2startPC+""]"");
}

// Remap the line number right away.
visitLineNumberInfo(null, null, null, lineNumberInfo);

if (DEBUG)
{
System.out.println("" -> [""+lineNumberInfo.u2startPC+""] line ""+lineNumberInfo.u2lineNumber+(lineNumberInfo.getSource()==null ? """":"" [""+lineNumberInfo.getSource()+""]""));
}

lineNumberTable =
(LineNumberInfo[])ArrayUtil.extendArray(lineNumberTable,
lineNumberTableLength + 1);

// Find the insertion index, starting from the end.
// Don't insert before a negative line number, in case of a tie.
int index = lineNumberTableLength++;
while (index > minimumIndex &&
(lineNumberTable[index - 1].u2startPC > lineNumberInfo.u2startPC ||
lineNumberTable[index - 1].u2startPC >= lineNumberInfo.u2startPC &&
lineNumberTable[index - 1].u2lineNumber >= 0))
{
lineNumberTable[index] = lineNumberTable[--index];
}

lineNumberTable[index] = lineNumberInfo;

return index;
}


/**
* Appends the given line number to the line number table.
* @param lineNumberInfo the line number to be appended.
*/
public void appendLineNumber(LineNumberInfo lineNumberInfo)
{
if (DEBUG)
{
print("" "", ""Line number [""+lineNumberInfo.u2startPC+""]"");
}

// Remap the line number right away.
visitLineNumberInfo(null, null, null, lineNumberInfo);

if (DEBUG)
{
System.out.println("" -> [""+lineNumberInfo.u2startPC+""] line ""+lineNumberInfo.u2lineNumber+(lineNumberInfo.getSource()==null ? """":"" [""+lineNumberInfo.getSource()+""]""));
}

// Add the line number.
lineNumberTable =
(LineNumberInfo[])ArrayUtil.add(lineNumberTable,
lineNumberTableLength++,
lineNumberInfo);
}


/**
* Wraps up the current code fragment, continuing with the previous one on
* the stack.
*/
public void endCodeFragment()
{
if (level < 0)
{
throw new IllegalArgumentException(""Code fragment not begun [""+level+""]"");
}

// Remap the instructions of the code fragment.
int instructionOffset = codeFragmentOffsets[level];
while (instructionOffset < codeLength)
{
// Get the next instruction.
Instruction instruction = InstructionFactory.create(code, instructionOffset);

// Does this instruction still have to be remapped?
if (oldInstructionOffsets[instructionOffset] >= 0)
{
// Adapt the instruction for its new offset.
instruction.accept(null, null, null, instructionOffset, this);

// Write the instruction back. The instruction writer may still
// widen it later on, if necessary.
instruction.accept(null,
null,
new CodeAttribute(0, 0, 0, 0, code, 0, null, 0, null),
instructionOffset,
instructionWriter);
//instruction.write(code, codeLength);
}

// Continue remapping at the next instruction offset.
instructionOffset += instruction.length(instructionOffset);
}

// Correct the estimated maximum code length, now that we know the
// actual length of this code fragment.
maximumCodeLength += codeLength - codeFragmentOffsets[level] -
codeFragmentLengths[level];

// Try to remap the exception handlers that couldn't be remapped before.
if (allowExternalExceptionHandlers)
{
for (int index = 0; index < exceptionTableLength; index++)
{
ExceptionInfo exceptionInfo = exceptionTable[index];

// Unmapped exception handlers are still negated.
int handlerPC = -exceptionInfo.u2handlerPC;
if (handlerPC > 0)
{
if (remappableExceptionHandler(handlerPC))
{
exceptionInfo.u2handlerPC = newInstructionOffset(handlerPC);
}
else if (level == 0)
{
throw new IllegalStateException(""Couldn't remap exception handler offset [""+handlerPC+""]"");
}
}
}
}

level--;
}


// Implementations for AttributeVisitor.

public void visitAnyAttribute(Clazz clazz, Attribute attribute) {}


public void visitCodeAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute)
{
if (DEBUG)
{
System.out.println(""CodeAttributeComposer: putting results in [""+clazz.getName()+"".""+method.getName(clazz)+method.getDescriptor(clazz)+""]"");
}

if (level != -1)
{
throw new IllegalArgumentException(""Code fragment not ended [""+level+""]"");
}

level++;

// Make sure the code attribute has sufficient space for the composed
// code.
if (codeAttribute.u4codeLength < codeLength)
{
codeAttribute.code = new byte[codeLength];
}

// Copy the composed code over into the code attribute.
codeAttribute.u4codeLength = codeLength;
System.arraycopy(code, 0, codeAttribute.code, 0, codeLength);

// Remove exceptions with empty code blocks (done before).
//exceptionTableLength =
// removeEmptyExceptions(exceptionTable, exceptionTableLength);

// Make sure the exception table has sufficient space for the composed
// exceptions.
if (codeAttribute.exceptionTable.length < exceptionTableLength)
{
codeAttribute.exceptionTable = new ExceptionInfo[exceptionTableLength];
}

// Copy the exception table.
codeAttribute.u2exceptionTableLength = exceptionTableLength;
System.arraycopy(exceptionTable, 0, codeAttribute.exceptionTable, 0, exceptionTableLength);

// Update the maximum stack size and local variable frame size.
stackSizeUpdater.visitCodeAttribute(clazz, method, codeAttribute);
variableSizeUpdater.visitCodeAttribute(clazz, method, codeAttribute);

// Add a new line number table for the line numbers, if necessary.
if (lineNumberTableLength > 0 &&
codeAttribute.getAttribute(clazz, ClassConstants.ATTR_LineNumberTable) == null)
{
int attributeNameIndex =
new ConstantPoolEditor((ProgramClass)clazz)
.addUtf8Constant(ClassConstants.ATTR_LineNumberTable);

new AttributesEditor((ProgramClass)clazz, (ProgramMember)method, codeAttribute, false)
.addAttribute(new LineNumberTableAttribute(attributeNameIndex, 0, null));
}

// Copy the line number table and the local variable table.
codeAttribute.attributesAccept(clazz, method, this);

// Remap the exception table (done before).
//codeAttribute.exceptionsAccept(clazz, method, this);

// Remove exceptions with empty code blocks (done before).
//codeAttribute.u2exceptionTableLength =
// removeEmptyExceptions(codeAttribute.exceptionTable,
// codeAttribute.u2exceptionTableLength);

// Make sure instructions are widened if necessary.
instructionWriter.visitCodeAttribute(clazz, method, codeAttribute);

level--;

if (DEBUG)
{
codeAttribute.accept(clazz, method, new ClassPrinter());
}
}


public void visitStackMapAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, StackMapAttribute stackMapAttribute)
{
// Remap all stack map entries.
expectedStackMapFrameOffset = -1;
stackMapAttribute.stackMapFramesAccept(clazz, method, codeAttribute, this);
}


public void visitStackMapTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, StackMapTableAttribute stackMapTableAttribute)
{
// Remap all stack map table entries.
expectedStackMapFrameOffset = 0;
stackMapTableAttribute.stackMapFramesAccept(clazz, method, codeAttribute, this);
}


public void visitLineNumberTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, LineNumberTableAttribute lineNumberTableAttribute)
{
// Didn't we get line number new definitions?
if (lineNumberTableLength == 0)
{
// Remap all line number table entries of the existing table.
lineNumberTableAttribute.lineNumbersAccept(clazz, method, codeAttribute, this);
}
else
{
// Remove line numbers with empty code blocks.
// Actually, we'll do this elsewhere, to allow processing the
// line numbers of inlined methods.
//lineNumberTableLength =
// removeEmptyLineNumbers(lineNumberTable,
// lineNumberTableLength,
// codeAttribute.u4codeLength);

// Copy the line number table.
lineNumberTableAttribute.lineNumberTable = new LineNumberInfo[lineNumberTableLength];
lineNumberTableAttribute.u2lineNumberTableLength = lineNumberTableLength;
System.arraycopy(lineNumberTable, 0, lineNumberTableAttribute.lineNumberTable, 0, lineNumberTableLength);
}
}

public void visitLocalVariableTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, LocalVariableTableAttribute localVariableTableAttribute)
{
// Remap all local variable table entries.
localVariableTableAttribute.localVariablesAccept(clazz, method, codeAttribute, this);

// Remove local variables with empty code blocks.
localVariableTableAttribute.u2localVariableTableLength =
removeEmptyLocalVariables(localVariableTableAttribute.localVariableTable,
localVariableTableAttribute.u2localVariableTableLength,
codeAttribute.u2maxLocals);
}


public void visitLocalVariableTypeTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, LocalVariableTypeTableAttribute localVariableTypeTableAttribute)
{
// Remap all local variable table entries.
localVariableTypeTableAttribute.localVariablesAccept(clazz, method, codeAttribute, this);

// Remove local variables with empty code blocks.
localVariableTypeTableAttribute.u2localVariableTypeTableLength =
removeEmptyLocalVariableTypes(localVariableTypeTableAttribute.localVariableTypeTable,
localVariableTypeTableAttribute.u2localVariableTypeTableLength,
codeAttribute.u2maxLocals);
}


public void visitAnyTypeAnnotationsAttribute(Clazz clazz, TypeAnnotationsAttribute typeAnnotationsAttribute)
{
typeAnnotationsAttribute.typeAnnotationsAccept(clazz, this);
}


// Implementations for InstructionVisitor.

public void visitAnyInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, Instruction instruction) {}


public void visitBranchInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, BranchInstruction branchInstruction)
{
try
{
// Adjust the branch offset.
branchInstruction.branchOffset =
newBranchOffset(offset, branchInstruction.branchOffset);

// Don't remap this instruction again.
oldInstructionOffsets[offset] = -1;
}
catch (IllegalArgumentException e)
{
if (level == 0 || !allowExternalBranchTargets)
{
throw e;
}
}
}


public void visitAnySwitchInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, SwitchInstruction switchInstruction)
{
try
{
// TODO: We're assuming we can adjust no offsets or all offsets at once.
// Adjust the default jump offset.
switchInstruction.defaultOffset =
newBranchOffset(offset, switchInstruction.defaultOffset);

// Adjust the jump offsets.
updateJumpOffsets(offset,
switchInstruction.jumpOffsets);

// Don't remap this instruction again.
oldInstructionOffsets[offset] = -1;
}
catch (IllegalArgumentException e)
{
if (level == 0 || !allowExternalBranchTargets)
{
throw e;
}
}
}


// Implementations for ExceptionInfoVisitor.

public void visitExceptionInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, ExceptionInfo exceptionInfo)
{
// Remap the code offsets. Note that the instruction offset map also has
// an entry for the first offset after the code, for u2endPC.
exceptionInfo.u2startPC = newInstructionOffset(exceptionInfo.u2startPC);
exceptionInfo.u2endPC = newInstructionOffset(exceptionInfo.u2endPC);

// See if we can remap the handler right away. Unmapped exception
// handlers are negated, in order to mark them as external.
int handlerPC = exceptionInfo.u2handlerPC;
exceptionInfo.u2handlerPC =
!allowExternalExceptionHandlers ||
remappableExceptionHandler(handlerPC) ?
newInstructionOffset(handlerPC) :
-handlerPC;
}


// Implementations for StackMapFrameVisitor.

public void visitAnyStackMapFrame(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, StackMapFrame stackMapFrame)
{
// Remap the stack map frame offset.
int stackMapFrameOffset = newInstructionOffset(offset);

int offsetDelta = stackMapFrameOffset;

// Compute the offset delta if the frame is part of a stack map frame
// table (for JDK 6.0) instead of a stack map (for Java Micro Edition).
if (expectedStackMapFrameOffset >= 0)
{
offsetDelta -= expectedStackMapFrameOffset;

expectedStackMapFrameOffset = stackMapFrameOffset + 1;
}

stackMapFrame.u2offsetDelta = offsetDelta;
}


public void visitSameOneFrame(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, SameOneFrame sameOneFrame)
{
// Remap the stack map frame offset.
visitAnyStackMapFrame(clazz, method, codeAttribute, offset, sameOneFrame);

// Remap the verification type offset.
sameOneFrame.stackItemAccept(clazz, method, codeAttribute, offset, this);
}


public void visitMoreZeroFrame(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, MoreZeroFrame moreZeroFrame)
{
// Remap the stack map frame offset.
visitAnyStackMapFrame(clazz, method, codeAttribute, offset, moreZeroFrame);

// Remap the verification type offsets.
moreZeroFrame.additionalVariablesAccept(clazz, method, codeAttribute, offset, this);
}


public void visitFullFrame(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, FullFrame fullFrame)
{
// Remap the stack map frame offset.
visitAnyStackMapFrame(clazz, method, codeAttribute, offset, fullFrame);

// Remap the verification type offsets.
fullFrame.variablesAccept(clazz, method, codeAttribute, offset, this);
fullFrame.stackAccept(clazz, method, codeAttribute, offset, this);
}


// Implementations for VerificationTypeVisitor.

public void visitAnyVerificationType(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, VerificationType verificationType) {}


public void visitUninitializedType(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, UninitializedType uninitializedType)
{
// Remap the offset of the 'new' instruction.
uninitializedType.u2newInstructionOffset = newInstructionOffset(uninitializedType.u2newInstructionOffset);
}


// Implementations for LineNumberInfoVisitor.

public void visitLineNumberInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, LineNumberInfo lineNumberInfo)
{
// Remap the code offset.
lineNumberInfo.u2startPC = newInstructionOffset(lineNumberInfo.u2startPC);
}


// Implementations for LocalVariableInfoVisitor.

public void visitLocalVariableInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, LocalVariableInfo localVariableInfo)
{
// Remap the code offset and length.
// TODO: The local variable frame might not be strictly preserved.
int startPC = newInstructionOffset(localVariableInfo.u2startPC);
int endPC = newInstructionOffset(localVariableInfo.u2startPC +
localVariableInfo.u2length);

localVariableInfo.u2startPC = startPC;
localVariableInfo.u2length = endPC - startPC;
}

// Implementations for LocalVariableTypeInfoVisitor.

public void visitLocalVariableTypeInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, LocalVariableTypeInfo localVariableTypeInfo)
{
// Remap the code offset and length.
// TODO: The local variable frame might not be strictly preserved.
int startPC = newInstructionOffset(localVariableTypeInfo.u2startPC);
int endPC = newInstructionOffset(localVariableTypeInfo.u2startPC +
localVariableTypeInfo.u2length);

localVariableTypeInfo.u2startPC = startPC;
localVariableTypeInfo.u2length = endPC - startPC;
}


// Implementations for TypeAnnotationVisitor.

public void visitTypeAnnotation(Clazz clazz, TypeAnnotation typeAnnotation)
{
// Update all local variable targets.
typeAnnotation.targetInfoAccept(clazz, this);
}


// Implementations for TargetInfoVisitor.

public void visitAnyTargetInfo(Clazz clazz, TypeAnnotation typeAnnotation, TargetInfo targetInfo) {}


public void visitLocalVariableTargetInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, TypeAnnotation typeAnnotation, LocalVariableTargetInfo localVariableTargetInfo)
{
// Update the offsets of the variables.
localVariableTargetInfo.targetElementsAccept(clazz, method, codeAttribute, typeAnnotation, this);
}


public void visitOffsetTargetInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, TypeAnnotation typeAnnotation, OffsetTargetInfo offsetTargetInfo)
{
// Update the offset.
offsetTargetInfo.u2offset = newInstructionOffset(offsetTargetInfo.u2offset);
}


// Implementations for LocalVariableTargetElementVisitor.

public void visitLocalVariableTargetElement(Clazz clazz, Method method, CodeAttribute codeAttribute, TypeAnnotation typeAnnotation, LocalVariableTargetInfo localVariableTargetInfo, LocalVariableTargetElement localVariableTargetElement)
{
// Remap the code offset and length.
int startPC = newInstructionOffset(localVariableTargetElement.u2startPC);
int endPC = newInstructionOffset(localVariableTargetElement.u2startPC +
localVariableTargetElement.u2length);

localVariableTargetElement.u2startPC = startPC;
localVariableTargetElement.u2length = endPC - startPC;
}

// Small utility methods.

/**
* Make sure the code arrays have at least the given size.
*/
private void ensureCodeLength(int newCodeLength)
{
if (code.length < newCodeLength)
{
// Add 20% to avoid extending the arrays too often.
newCodeLength = newCodeLength * 6 / 5;

code = ArrayUtil.extendArray(code, newCodeLength);
oldInstructionOffsets = ArrayUtil.extendArray(oldInstructionOffsets, newCodeLength);

instructionWriter.extend(newCodeLength);
}
}


/**
* Adjusts the given jump offsets for the instruction at the given offset.
*/
private void updateJumpOffsets(int offset, int[] jumpOffsets)
{
for (int index = 0; index < jumpOffsets.length; index++)
{
jumpOffsets[index] = newBranchOffset(offset, jumpOffsets[index]);
}
}


/**
* Computes the new branch offset for the instruction at the given new offset
* with the given old branch offset.
*/
private int newBranchOffset(int newInstructionOffset, int oldBranchOffset)
{
if (newInstructionOffset < 0 ||
newInstructionOffset > codeLength)
{
throw new IllegalArgumentException(""Invalid instruction offset [""+newInstructionOffset +""] in code with length [""+codeLength+""]"");
}

int oldInstructionOffset = oldInstructionOffsets[newInstructionOffset];

// For ordinary branch instructions, we can compute the offset
// relative to the instruction itself.
return newInstructionOffset(oldInstructionOffset + oldBranchOffset) -
newInstructionOffset;
}


/**
* Computes the new instruction offset for the instruction at the given old
* offset.
*/
private int newInstructionOffset(int oldInstructionOffset)
{
if (oldInstructionOffset < 0 ||
oldInstructionOffset > codeFragmentLengths[level])
{
throw new IllegalArgumentException(""Instruction offset [""+oldInstructionOffset +""] out of range in code fragment with length [""+codeFragmentLengths[level]+""] at level ""+level);
}

int newInstructionOffset = instructionOffsetMap[level][oldInstructionOffset];
if (newInstructionOffset == INVALID)
{
throw new IllegalArgumentException(""Invalid instruction offset [""+oldInstructionOffset +""] in code fragment at level ""+level);
}

return newInstructionOffset;
}


/**
* Returns whether the given old exception handler can be remapped in the
* current code fragment.
*/
private boolean remappableExceptionHandler(int oldInstructionOffset)
{
// Can we index in the array?
if (oldInstructionOffset > codeFragmentLengths[level])
{
return false;
}

// Do we have a valid new instruction offset, but not yet right after
// the code? That offset is only labeled for mapping try blocks, not
// for mapping handlers.
int newInstructionOffset =
instructionOffsetMap[level][oldInstructionOffset];

return newInstructionOffset > INVALID &&
newInstructionOffset < codeLength;
}


/**
* Returns the given list of exceptions, without the ones that have empty
* code blocks.
*/
private int removeEmptyExceptions(ExceptionInfo[] exceptionInfos,
int exceptionInfoCount)
{
// Overwrite all empty exceptions.
int newIndex = 0;
for (int index = 0; index < exceptionInfoCount; index++)
{
ExceptionInfo exceptionInfo = exceptionInfos[index];
if (exceptionInfo.u2startPC < exceptionInfo.u2endPC)
{
exceptionInfos[newIndex++] = exceptionInfo;
}
}

// Clear the unused array entries.
Arrays.fill(exceptionInfos, newIndex, exceptionInfoCount, null);

return newIndex;
}


/**
* Returns the given list of line numbers, without the ones that have empty
* code blocks or that exceed the code size.
*/
private int removeEmptyLineNumbers(LineNumberInfo[] lineNumberInfos,
int lineNumberInfoCount,
int codeLength)
{
// Overwrite all empty line number entries.
int newIndex = 0;
for (int index = 0; index < lineNumberInfoCount; index++)
{
LineNumberInfo lineNumberInfo = lineNumberInfos[index];
int startPC = lineNumberInfo.u2startPC;
if (startPC < codeLength &&
(index == 0 || startPC > lineNumberInfos[index-1].u2startPC))
{
lineNumberInfos[newIndex++] = lineNumberInfo;
}
}

// Clear the unused array entries.
Arrays.fill(lineNumberInfos, newIndex, lineNumberInfoCount, null);

return newIndex;
}


/**
* Returns the given list of local variables, without the ones that have empty
* code blocks or that exceed the actual number of local variables.
*/
private int removeEmptyLocalVariables(LocalVariableInfo[] localVariableInfos,
int localVariableInfoCount,
int maxLocals)
{
// Overwrite all empty local variable entries.
int newIndex = 0;
for (int index = 0; index < localVariableInfoCount; index++)
{
LocalVariableInfo localVariableInfo = localVariableInfos[index];
if (localVariableInfo.u2length > 0 &&
localVariableInfo.u2index < maxLocals)
{
localVariableInfos[newIndex++] = localVariableInfo;
}
}

// Clear the unused array entries.
Arrays.fill(localVariableInfos, newIndex, localVariableInfoCount, null);

return newIndex;
}


/**
* Returns the given list of local variable types, without the ones that
* have empty code blocks or that exceed the actual number of local variables.
*/
private int removeEmptyLocalVariableTypes(LocalVariableTypeInfo[] localVariableTypeInfos,
int localVariableTypeInfoCount,
int maxLocals)
{
// Overwrite all empty local variable type entries.
int newIndex = 0;
for (int index = 0; index < localVariableTypeInfoCount; index++)
{
LocalVariableTypeInfo localVariableTypeInfo = localVariableTypeInfos[index];
if (localVariableTypeInfo.u2length > 0 &&
localVariableTypeInfo.u2index < maxLocals)
{
localVariableTypeInfos[newIndex++] = localVariableTypeInfo;
}
}

// Clear the unused array entries.
Arrays.fill(localVariableTypeInfos, newIndex, localVariableTypeInfoCount, null);

return newIndex;
}


private void println(String string1, String string2)
{
print(string1, string2);

System.out.println();
}

private void print(String string1, String string2)
{
System.out.print(string1);

for (int index = 0; index < level; index++)
{
System.out.print("" "");
}

System.out.print(string2);
}


public static void main(String[] args)
{
CodeAttributeComposer [MASK] = new CodeAttributeComposer();

[MASK] .beginCodeFragment(4);
[MASK] .appendInstruction(0, new SimpleInstruction(InstructionConstants.OP_ICONST_0));
[MASK] .appendInstruction(1, new VariableInstruction(InstructionConstants.OP_ISTORE, 0));
[MASK] .appendInstruction(2, new BranchInstruction(InstructionConstants.OP_GOTO, 1));

[MASK] .beginCodeFragment(4);
[MASK] .appendInstruction(0, new VariableInstruction(InstructionConstants.OP_IINC, 0, 1));
[MASK] .appendInstruction(1, new VariableInstruction(InstructionConstants.OP_ILOAD, 0));
[MASK] .appendInstruction(2, new SimpleInstruction(InstructionConstants.OP_ICONST_5));
[MASK] .appendInstruction(3, new BranchInstruction(InstructionConstants.OP_IFICMPLT, -3));
[MASK] .endCodeFragment();

[MASK] .appendInstruction(3, new SimpleInstruction(InstructionConstants.OP_RETURN));
[MASK] .endCodeFragment();
}
}

","composer
"