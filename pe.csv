X,y,GCB (with random number of tokens),GCB (ideal tokens),ChatGPT,Gemini,Code-LLaMa
"package jadx.gui.settings.ui;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ItemEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JSpinner;
import javax.swing.JSplitPane;
import javax.swing.JTextField;
import javax.swing.KeyStroke;
import javax.swing.ScrollPaneConstants;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.WindowConstants;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;

import say.swing.JFontChooser;

import jadx.api.CommentsLevel;
import jadx.api.DecompilationMode;
import jadx.api.JadxArgs;
import jadx.api.JadxArgs.UseKotlinMethodsForVarNames;
import jadx.api.JadxDecompiler;
import jadx.api.args.GeneratedRenamesMappingFileMode;
import jadx.api.args.IntegerFormat;
import jadx.api.args.ResourceNameSource;
import jadx.api.plugins.events.JadxEvents;
import jadx.api.plugins.gui.ISettingsGroup;
import jadx.gui.settings.JadxSettings;
import jadx.gui.settings.JadxSettingsAdapter;
import jadx.gui.settings.LineNumbersMode;
import jadx.gui.settings.ui.cache.CacheSettingsGroup;
import jadx.gui.settings.ui.plugins.PluginSettings;
import jadx.gui.settings.ui.shortcut.ShortcutsSettingsGroup;
import jadx.gui.ui.MainWindow;
import jadx.gui.ui.codearea.EditorTheme;
import jadx.gui.utils.FontUtils;
import jadx.gui.utils.LafManager;
import jadx.gui.utils.LangLocale;
import jadx.gui.utils.NLS;
import jadx.gui.utils.UiUtils;
import jadx.gui.utils.ui.ActionHandler;
import jadx.gui.utils.ui.DocumentUpdateListener;

public class JadxSettingsWindow extends JDialog {
	private static final long serialVersionUID = -1804570470377354148L;

	private static final Logger LOG = LoggerFactory.getLogger(JadxSettingsWindow.class);

	private final transient MainWindow mainWindow;
	private final transient JadxSettings settings;
	private final transient String startSettings;
	private final transient String startSettingsHash;
	private final transient LangLocale prevLang;

	private transient boolean needReload = false;
	private transient SettingsTree tree;

	public JadxSettingsWindow(MainWindow mainWindow, JadxSettings settings) {
		this.mainWindow = mainWindow;
		this.settings = settings;
		this.startSettings = JadxSettingsAdapter.makeString(settings);
		this.startSettingsHash = calcSettingsHash();
		this.prevLang = settings.getLangLocale();

		initUI();

		setTitle(NLS.str(""preferences.title""));
		setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
		setModalityType(ModalityType.APPLICATION_MODAL);
		pack();
		UiUtils.setWindowIcons(this);
		setLocationRelativeTo(null);
		if (!mainWindow.getSettings().loadWindowPos(this)) {
			setSize(700, 800);
		}
		mainWindow.events().addListener(JadxEvents.RELOAD_SETTINGS_WINDOW, r -> UiUtils.uiRun(this::reloadUI));
		mainWindow.events().addListener(JadxEvents.RELOAD_PROJECT, r -> UiUtils.uiRun(this::reloadUI));
	}

	private void reloadUI() {
		int[] selection = tree.getSelectionRows();
		getContentPane().removeAll();
		initUI();
		// wait for other events to process
		UiUtils.uiRun(() -> {
			tree.setSelectionRows(selection);
			SwingUtilities.updateComponentTreeUI(this);
		});
	}

	private void initUI() {
		JPanel wrapGroupPanel = new JPanel(new BorderLayout(10, 10));

		List<ISettingsGroup> groups = new ArrayList<>();
		groups.add(makeDecompilationGroup());
		groups.add(makeDeobfuscationGroup());
		groups.add(makeRenameGroup());
		groups.add(new CacheSettingsGroup(this));
		groups.add(makeAppearanceGroup());
		groups.add(new ShortcutsSettingsGroup(this, settings));
		groups.add(makeSearchResGroup());
		groups.add(makeProjectGroup());
		groups.add(new PluginSettings(mainWindow, settings).build());
		groups.add(makeOtherGroup());

		tree = new SettingsTree();
		tree.init(wrapGroupPanel, groups);
		JScrollPane leftPane = new JScrollPane(tree);
		leftPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 3, 3));

		JScrollPane rightPane = new JScrollPane(wrapGroupPanel);
		rightPane.getVerticalScrollBar().setUnitIncrement(16);
		rightPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		rightPane.setBorder(BorderFactory.createEmptyBorder(10, 3, 3, 10));

		JSplitPane splitPane = new JSplitPane();
		splitPane.setResizeWeight(0.2);
		splitPane.setLeftComponent(leftPane);
		splitPane.setRightComponent(rightPane);

		Container contentPane = getContentPane();
		contentPane.add(splitPane, BorderLayout.CENTER);
		contentPane.add(buildButtonsPane(), BorderLayout.PAGE_END);

		KeyStroke strokeEsc = KeyStroke.getKeyStroke(""ESCAPE"");
		InputMap inputMap = getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
		inputMap.put(strokeEsc, ""ESCAPE"");
		getRootPane().getActionMap().put(""ESCAPE"", new ActionHandler(this::cancel));
	}

	private JPanel buildButtonsPane() {
		JButton saveBtn = new JButton(NLS.str(""preferences.save""));
		saveBtn.addActionListener(event -> save());

		JButton cancelButton = new JButton(NLS.str(""preferences.cancel""));
		cancelButton.addActionListener(event -> cancel());

		JButton resetBtn = new JButton(NLS.str(""preferences.reset""));
		resetBtn.addActionListener(event -> reset());

		JButton copyBtn = new JButton(NLS.str(""preferences.copy""));
		copyBtn.addActionListener(event -> copySettings());

		JPanel buttonPane = new JPanel();
		buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.LINE_AXIS));
		buttonPane.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
		buttonPane.add(resetBtn);
		buttonPane.add(copyBtn);
		buttonPane.add(Box.createHorizontalGlue());
		buttonPane.add(saveBtn);
		buttonPane.add(Box.createRigidArea(new Dimension(10, 0)));
		buttonPane.add(cancelButton);

		getRootPane().setDefaultButton(saveBtn);
		return buttonPane;
	}

	private static void enableComponents(Container container, boolean enable) {
		for (Component component : container.getComponents()) {
			if (component instanceof Container) {
				enableComponents((Container) component, enable);
			}
			component.setEnabled(enable);
		}
	}

	private SettingsGroup makeDeobfuscationGroup() {
		JCheckBox  [MASK]  = new JCheckBox();
		 [MASK] .setSelected(settings.isDeobfuscationOn());
		 [MASK] .addItemListener(e -> {
			settings.setDeobfuscationOn(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		SpinnerNumberModel minLenModel = new SpinnerNumberModel(settings.getDeobfuscationMinLength(), 0, Integer.MAX_VALUE, 1);
		JSpinner minLenSpinner = new JSpinner(minLenModel);
		minLenSpinner.addChangeListener(e -> {
			settings.setDeobfuscationMinLength((Integer) minLenSpinner.getValue());
			needReload();
		});

		SpinnerNumberModel maxLenModel = new SpinnerNumberModel(settings.getDeobfuscationMaxLength(), 0, Integer.MAX_VALUE, 1);
		JSpinner maxLenSpinner = new JSpinner(maxLenModel);
		maxLenSpinner.addChangeListener(e -> {
			settings.setDeobfuscationMaxLength((Integer) maxLenSpinner.getValue());
			needReload();
		});

		JComboBox<ResourceNameSource> resNamesSource = new JComboBox<>(ResourceNameSource.values());
		resNamesSource.setSelectedItem(settings.getResourceNameSource());
		resNamesSource.addActionListener(e -> {
			settings.setResourceNameSource((ResourceNameSource) resNamesSource.getSelectedItem());
			needReload();
		});

		JComboBox<GeneratedRenamesMappingFileMode> generatedRenamesMappingFileModeCB =
				new JComboBox<>(GeneratedRenamesMappingFileMode.values());
		generatedRenamesMappingFileModeCB.setSelectedItem(settings.getGeneratedRenamesMappingFileMode());
		generatedRenamesMappingFileModeCB.addActionListener(e -> {
			GeneratedRenamesMappingFileMode newValue =
					(GeneratedRenamesMappingFileMode) generatedRenamesMappingFileModeCB.getSelectedItem();
			if (newValue != settings.getGeneratedRenamesMappingFileMode()) {
				settings.setGeneratedRenamesMappingFileMode(newValue);
				needReload();
			}
		});

		SettingsGroup deobfGroup = new SettingsGroup(NLS.str(""preferences.deobfuscation""));
		deobfGroup.addRow(NLS.str(""preferences.deobfuscation_on""),  [MASK] );
		deobfGroup.addRow(NLS.str(""preferences.deobfuscation_min_len""), minLenSpinner);
		deobfGroup.addRow(NLS.str(""preferences.deobfuscation_max_len""), maxLenSpinner);
		deobfGroup.addRow(NLS.str(""preferences.deobfuscation_res_name_source""), resNamesSource);
		deobfGroup.addRow(NLS.str(""preferences.generated_renames_mapping_file_mode""), generatedRenamesMappingFileModeCB);
		deobfGroup.end();

		Collection<JComponent> connectedComponents = Arrays.asList(minLenSpinner, maxLenSpinner);
		 [MASK] .addItemListener(e -> enableComponentList(connectedComponents, e.getStateChange() == ItemEvent.SELECTED));
		enableComponentList(connectedComponents, settings.isDeobfuscationOn());
		return deobfGroup;
	}

	private SettingsGroup makeRenameGroup() {
		JCheckBox renameCaseSensitive = new JCheckBox();
		renameCaseSensitive.setSelected(settings.isRenameCaseSensitive());
		renameCaseSensitive.addItemListener(e -> {
			settings.updateRenameFlag(JadxArgs.RenameEnum.CASE, e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox renameValid = new JCheckBox();
		renameValid.setSelected(settings.isRenameValid());
		renameValid.addItemListener(e -> {
			settings.updateRenameFlag(JadxArgs.RenameEnum.VALID, e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox renamePrintable = new JCheckBox();
		renamePrintable.setSelected(settings.isRenamePrintable());
		renamePrintable.addItemListener(e -> {
			settings.updateRenameFlag(JadxArgs.RenameEnum.PRINTABLE, e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox deobfSourceAlias = new JCheckBox();
		deobfSourceAlias.setSelected(settings.isDeobfuscationUseSourceNameAsAlias());
		deobfSourceAlias.addItemListener(e -> {
			settings.setDeobfuscationUseSourceNameAsAlias(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		SettingsGroup group = new SettingsGroup(NLS.str(""preferences.rename""));
		group.addRow(NLS.str(""preferences.rename_case""), renameCaseSensitive);
		group.addRow(NLS.str(""preferences.rename_valid""), renameValid);
		group.addRow(NLS.str(""preferences.rename_printable""), renamePrintable);
		group.addRow(NLS.str(""preferences.deobfuscation_source_alias""), deobfSourceAlias);
		return group;
	}

	private void enableComponentList(Collection<JComponent> connectedComponents, boolean enabled) {
		connectedComponents.forEach(comp -> comp.setEnabled(enabled));
	}

	private SettingsGroup makeProjectGroup() {
		JCheckBox autoSave = new JCheckBox();
		autoSave.setSelected(settings.isAutoSaveProject());
		autoSave.addItemListener(e -> settings.setAutoSaveProject(e.getStateChange() == ItemEvent.SELECTED));

		SettingsGroup group = new SettingsGroup(NLS.str(""preferences.project""));
		group.addRow(NLS.str(""preferences.autoSave""), autoSave);

		return group;
	}

	private SettingsGroup makeAppearanceGroup() {
		JComboBox<LangLocale> languageCbx = new JComboBox<>(NLS.getLangLocales());
		for (LangLocale locale : NLS.getLangLocales()) {
			if (locale.equals(settings.getLangLocale())) {
				languageCbx.setSelectedItem(locale);
				break;
			}
		}
		languageCbx.addActionListener(e -> settings.setLangLocale((LangLocale) languageCbx.getSelectedItem()));

		JButton fontBtn = new JButton(NLS.str(""preferences.select_font""));
		JButton smaliFontBtn = new JButton(NLS.str(""preferences.select_smali_font""));

		EditorTheme[] editorThemes = EditorTheme.getAllThemes();
		JComboBox<EditorTheme> themesCbx = new JComboBox<>(editorThemes);
		for (EditorTheme theme : editorThemes) {
			if (theme.getPath().equals(settings.getEditorThemePath())) {
				themesCbx.setSelectedItem(theme);
				break;
			}
		}
		themesCbx.addActionListener(e -> {
			int i = themesCbx.getSelectedIndex();
			EditorTheme editorTheme = editorThemes[i];
			settings.setEditorThemePath(editorTheme.getPath());
			mainWindow.loadSettings();
		});

		JComboBox<String> lafCbx = new JComboBox<>(LafManager.getThemes());
		lafCbx.setSelectedItem(settings.getLafTheme());
		lafCbx.addActionListener(e -> {
			settings.setLafTheme((String) lafCbx.getSelectedItem());
			mainWindow.loadSettings();
		});

		SettingsGroup group = new SettingsGroup(NLS.str(""preferences.appearance""));
		group.addRow(NLS.str(""preferences.language""), languageCbx);
		group.addRow(NLS.str(""preferences.laf_theme""), lafCbx);
		group.addRow(NLS.str(""preferences.theme""), themesCbx);
		JLabel fontLabel = group.addRow(getFontLabelStr(), fontBtn);
		JLabel smaliFontLabel = group.addRow(getSmaliFontLabelStr(), smaliFontBtn);

		fontBtn.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				JFontChooser fontChooser = new JFontChooser();
				fontChooser.setSelectedFont(settings.getFont());
				int result = fontChooser.showDialog(JadxSettingsWindow.this);
				if (result == JFontChooser.OK_OPTION) {
					Font font = fontChooser.getSelectedFont();
					LOG.debug(""Selected Font: {}"", font);
					settings.setFont(font);
					mainWindow.loadSettings();
					fontLabel.setText(getFontLabelStr());
				}
			}
		});

		smaliFontBtn.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				JFontChooser fontChooser = new JPreferredFontChooser();
				fontChooser.setSelectedFont(settings.getSmaliFont());
				int result = fontChooser.showDialog(JadxSettingsWindow.this);
				if (result == JFontChooser.OK_OPTION) {
					Font font = fontChooser.getSelectedFont();
					LOG.debug(""Selected Font: {} for smali"", font);
					settings.setSmaliFont(font);
					mainWindow.loadSettings();
					smaliFontLabel.setText(getSmaliFontLabelStr());
				}
			}
		});
		return group;
	}

	private String getFontLabelStr() {
		Font font = settings.getFont();
		String fontStyleName = FontUtils.convertFontStyleToString(font.getStyle());
		return NLS.str(""preferences.font"") + "": "" + font.getFontName() + ' ' + fontStyleName + ' ' + font.getSize();
	}

	private String getSmaliFontLabelStr() {
		Font font = settings.getSmaliFont();
		String fontStyleName = FontUtils.convertFontStyleToString(font.getStyle());
		return NLS.str(""preferences.smali_font"") + "": "" + font.getFontName() + ' ' + fontStyleName + ' ' + font.getSize();
	}

	private SettingsGroup makeDecompilationGroup() {
		JCheckBox useDx = new JCheckBox();
		useDx.setSelected(settings.isUseDx());
		useDx.addItemListener(e -> {
			settings.setUseDx(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JComboBox<DecompilationMode> decompilationModeComboBox = new JComboBox<>(DecompilationMode.values());
		decompilationModeComboBox.setSelectedItem(settings.getDecompilationMode());
		decompilationModeComboBox.addActionListener(e -> {
			settings.setDecompilationMode((DecompilationMode) decompilationModeComboBox.getSelectedItem());
			needReload();
		});

		JCheckBox showInconsistentCode = new JCheckBox();
		showInconsistentCode.setSelected(settings.isShowInconsistentCode());
		showInconsistentCode.addItemListener(e -> {
			settings.setShowInconsistentCode(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox resourceDecode = new JCheckBox();
		resourceDecode.setSelected(settings.isSkipResources());
		resourceDecode.addItemListener(e -> {
			settings.setSkipResources(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		// fix for #1331
		int threadsCountValue = settings.getThreadsCount();
		int threadsCountMax = Math.max(2, Math.max(threadsCountValue, Runtime.getRuntime().availableProcessors() * 2));
		SpinnerNumberModel spinnerModel = new SpinnerNumberModel(threadsCountValue, 1, threadsCountMax, 1);
		JSpinner threadsCount = new JSpinner(spinnerModel);
		threadsCount.addChangeListener(e -> {
			settings.setThreadsCount((Integer) threadsCount.getValue());
			needReload();
		});

		JButton editExcludedPackages = new JButton(NLS.str(""preferences.excludedPackages.button""));
		editExcludedPackages.addActionListener(event -> {

			String oldExcludedPackages = settings.getExcludedPackages();
			String result = JOptionPane.showInputDialog(this, NLS.str(""preferences.excludedPackages.editDialog""),
					settings.getExcludedPackages());
			if (result != null) {
				settings.setExcludedPackages(result);
				if (!oldExcludedPackages.equals(result)) {
					needReload();
				}
			}
		});

		JCheckBox autoStartJobs = new JCheckBox();
		autoStartJobs.setSelected(settings.isAutoStartJobs());
		autoStartJobs.addItemListener(e -> settings.setAutoStartJobs(e.getStateChange() == ItemEvent.SELECTED));

		JCheckBox escapeUnicode = new JCheckBox();
		escapeUnicode.setSelected(settings.isEscapeUnicode());
		escapeUnicode.addItemListener(e -> {
			settings.setEscapeUnicode(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox replaceConsts = new JCheckBox();
		replaceConsts.setSelected(settings.isReplaceConsts());
		replaceConsts.addItemListener(e -> {
			settings.setReplaceConsts(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox respectBytecodeAccessModifiers = new JCheckBox();
		respectBytecodeAccessModifiers.setSelected(settings.isRespectBytecodeAccessModifiers());
		respectBytecodeAccessModifiers.addItemListener(e -> {
			settings.setRespectBytecodeAccessModifiers(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox useImports = new JCheckBox();
		useImports.setSelected(settings.isUseImports());
		useImports.addItemListener(e -> {
			settings.setUseImports(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox useDebugInfo = new JCheckBox();
		useDebugInfo.setSelected(settings.isDebugInfo());
		useDebugInfo.addItemListener(e -> {
			settings.setDebugInfo(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox inlineAnonymous = new JCheckBox();
		inlineAnonymous.setSelected(settings.isInlineAnonymousClasses());
		inlineAnonymous.addItemListener(e -> {
			settings.setInlineAnonymousClasses(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox inlineMethods = new JCheckBox();
		inlineMethods.setSelected(settings.isInlineMethods());
		inlineMethods.addItemListener(e -> {
			settings.setInlineMethods(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox inlineKotlinLambdas = new JCheckBox();
		inlineKotlinLambdas.setSelected(settings.isAllowInlineKotlinLambda());
		inlineKotlinLambdas.addItemListener(e -> {
			settings.setAllowInlineKotlinLambda(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox moveInnerClasses = new JCheckBox();
		moveInnerClasses.setSelected(settings.isMoveInnerClasses());
		moveInnerClasses.addItemListener(e -> {
			settings.setMoveInnerClasses(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox extractFinally = new JCheckBox();
		extractFinally.setSelected(settings.isExtractFinally());
		extractFinally.addItemListener(e -> {
			settings.setExtractFinally(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox fsCaseSensitive = new JCheckBox();
		fsCaseSensitive.setSelected(settings.isFsCaseSensitive());
		fsCaseSensitive.addItemListener(e -> {
			settings.setFsCaseSensitive(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JComboBox<UseKotlinMethodsForVarNames> kotlinRenameVars = new JComboBox<>(UseKotlinMethodsForVarNames.values());
		kotlinRenameVars.setSelectedItem(settings.getUseKotlinMethodsForVarNames());
		kotlinRenameVars.addActionListener(e -> {
			settings.setUseKotlinMethodsForVarNames((UseKotlinMethodsForVarNames) kotlinRenameVars.getSelectedItem());
			needReload();
		});

		JComboBox<CommentsLevel> commentsLevel = new JComboBox<>(CommentsLevel.values());
		commentsLevel.setSelectedItem(settings.getCommentsLevel());
		commentsLevel.addActionListener(e -> {
			settings.setCommentsLevel((CommentsLevel) commentsLevel.getSelectedItem());
			needReload();
		});

		JComboBox<IntegerFormat> integerFormat = new JComboBox<>(IntegerFormat.values());
		integerFormat.setSelectedItem(settings.getIntegerFormat());
		integerFormat.addActionListener(e -> {
			settings.setIntegerFormat((IntegerFormat) integerFormat.getSelectedItem());
			needReload();
		});

		SettingsGroup other = new SettingsGroup(NLS.str(""preferences.decompile""));
		other.addRow(NLS.str(""preferences.threads""), threadsCount);
		other.addRow(NLS.str(""preferences.excludedPackages""),
				NLS.str(""preferences.excludedPackages.tooltip""), editExcludedPackages);
		other.addRow(NLS.str(""preferences.start_jobs""), autoStartJobs);
		other.addRow(NLS.str(""preferences.decompilationMode""), decompilationModeComboBox);
		other.addRow(NLS.str(""preferences.showInconsistentCode""), showInconsistentCode);
		other.addRow(NLS.str(""preferences.escapeUnicode""), escapeUnicode);
		other.addRow(NLS.str(""preferences.replaceConsts""), replaceConsts);
		other.addRow(NLS.str(""preferences.respectBytecodeAccessModifiers""), respectBytecodeAccessModifiers);
		other.addRow(NLS.str(""preferences.useImports""), useImports);
		other.addRow(NLS.str(""preferences.useDebugInfo""), useDebugInfo);
		other.addRow(NLS.str(""preferences.inlineAnonymous""), inlineAnonymous);
		other.addRow(NLS.str(""preferences.inlineMethods""), inlineMethods);
		other.addRow(NLS.str(""preferences.inlineKotlinLambdas""), inlineKotlinLambdas);
		other.addRow(NLS.str(""preferences.moveInnerClasses""), moveInnerClasses);
		other.addRow(NLS.str(""preferences.extractFinally""), extractFinally);
		other.addRow(NLS.str(""preferences.fsCaseSensitive""), fsCaseSensitive);
		other.addRow(NLS.str(""preferences.useDx""), useDx);
		other.addRow(NLS.str(""preferences.skipResourcesDecode""), resourceDecode);
		other.addRow(NLS.str(""preferences.useKotlinMethodsForVarNames""), kotlinRenameVars);
		other.addRow(NLS.str(""preferences.commentsLevel""), commentsLevel);
		other.addRow(NLS.str(""preferences.integerFormat""), integerFormat);
		return other;
	}

	private SettingsGroup makeOtherGroup() {
		JComboBox<LineNumbersMode> lineNumbersMode = new JComboBox<>(LineNumbersMode.values());
		lineNumbersMode.setSelectedItem(settings.getLineNumbersMode());
		lineNumbersMode.addActionListener(e -> {
			settings.setLineNumbersMode((LineNumbersMode) lineNumbersMode.getSelectedItem());
			mainWindow.loadSettings();
		});

		JCheckBox jumpOnDoubleClick = new JCheckBox();
		jumpOnDoubleClick.setSelected(settings.isJumpOnDoubleClick());
		jumpOnDoubleClick.addItemListener(e -> settings.setJumpOnDoubleClick(e.getStateChange() == ItemEvent.SELECTED));

		JCheckBox useAltFileDialog = new JCheckBox();
		useAltFileDialog.setSelected(settings.isUseAlternativeFileDialog());
		useAltFileDialog.addItemListener(e -> settings.setUseAlternativeFileDialog(e.getStateChange() == ItemEvent.SELECTED));

		JCheckBox update = new JCheckBox();
		update.setSelected(settings.isCheckForUpdates());
		update.addItemListener(e -> settings.setCheckForUpdates(e.getStateChange() == ItemEvent.SELECTED));

		JCheckBox cfg = new JCheckBox();
		cfg.setSelected(settings.isCfgOutput());
		cfg.addItemListener(e -> {
			settings.setCfgOutput(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		JCheckBox rawCfg = new JCheckBox();
		rawCfg.setSelected(settings.isRawCfgOutput());
		rawCfg.addItemListener(e -> {
			settings.setRawCfgOutput(e.getStateChange() == ItemEvent.SELECTED);
			needReload();
		});

		SettingsGroup group = new SettingsGroup(NLS.str(""preferences.other""));
		group.addRow(NLS.str(""preferences.lineNumbersMode""), lineNumbersMode);
		group.addRow(NLS.str(""preferences.jumpOnDoubleClick""), jumpOnDoubleClick);
		group.addRow(NLS.str(""preferences.useAlternativeFileDialog""), useAltFileDialog);
		group.addRow(NLS.str(""preferences.check_for_updates""), update);
		group.addRow(NLS.str(""preferences.cfg""), cfg);
		group.addRow(NLS.str(""preferences.raw_cfg""), rawCfg);
		return group;
	}

	private SettingsGroup makeSearchResGroup() {
		JSpinner resultsPerPage = new JSpinner(
				new SpinnerNumberModel(settings.getSearchResultsPerPage(), 0, Integer.MAX_VALUE, 1));
		resultsPerPage.addChangeListener(ev -> settings.setSearchResultsPerPage((Integer) resultsPerPage.getValue()));

		JSpinner sizeLimit = new JSpinner(
				new SpinnerNumberModel(settings.getSrhResourceSkipSize(), 0, Integer.MAX_VALUE, 1));
		sizeLimit.addChangeListener(ev -> settings.setSrhResourceSkipSize((Integer) sizeLimit.getValue()));

		JTextField fileExtField = new JTextField();
		fileExtField.getDocument().addDocumentListener(new DocumentUpdateListener((ev) -> {
			String ext = fileExtField.getText();
			settings.setSrhResourceFileExt(ext);
		}));
		fileExtField.setText(settings.getSrhResourceFileExt());

		SettingsGroup searchGroup = new SettingsGroup(NLS.str(""preferences.search_group_title""));
		searchGroup.addRow(NLS.str(""preferences.search_results_per_page""), resultsPerPage);
		searchGroup.addRow(NLS.str(""preferences.res_skip_file""), sizeLimit);
		searchGroup.addRow(NLS.str(""preferences.res_file_ext""), fileExtField);
		return searchGroup;
	}

	private void save() {
		settings.sync();
		enableComponents(this, false);
		SwingUtilities.invokeLater(() -> {
			if (shouldReload()) {
				mainWindow.getShortcutsController().loadSettings();
				mainWindow.reopen();
			}
			if (!settings.getLangLocale().equals(prevLang)) {
				JOptionPane.showMessageDialog(
						this,
						NLS.str(""msg.language_changed"", settings.getLangLocale()),
						NLS.str(""msg.language_changed_title"", settings.getLangLocale()),
						JOptionPane.INFORMATION_MESSAGE);
			}
			dispose();
		});
	}

	private void cancel() {
		JadxSettingsAdapter.fill(settings, startSettings);
		mainWindow.loadSettings();
		dispose();
	}

	private void reset() {
		int res = JOptionPane.showConfirmDialog(
				JadxSettingsWindow.this,
				NLS.str(""preferences.reset_message""),
				NLS.str(""preferences.reset_title""),
				JOptionPane.YES_NO_OPTION);
		if (res == JOptionPane.YES_OPTION) {
			String defaults = JadxSettingsAdapter.makeString(JadxSettings.makeDefault());
			JadxSettingsAdapter.fill(settings, defaults);
			mainWindow.loadSettings();
			needReload();
			getContentPane().removeAll();
			initUI();
			pack();
			repaint();
		}
	}

	private void copySettings() {
		JsonObject settingsJson = JadxSettingsAdapter.makeJsonObject(this.settings);
		// remove irrelevant preferences
		settingsJson.remove(""windowPos"");
		settingsJson.remove(""mainWindowExtendedState"");
		settingsJson.remove(""lastSaveProjectPath"");
		settingsJson.remove(""lastOpenFilePath"");
		settingsJson.remove(""lastSaveFilePath"");
		settingsJson.remove(""recentProjects"");
		String settingsText = new GsonBuilder().setPrettyPrinting().create().toJson(settingsJson);
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		StringSelection selection = new StringSelection(settingsText);
		clipboard.setContents(selection, selection);
		JOptionPane.showMessageDialog(
				JadxSettingsWindow.this,
				NLS.str(""preferences.copy_message""));
	}

	public void needReload() {
		needReload = true;
	}

	private boolean shouldReload() {
		return needReload || !startSettingsHash.equals(calcSettingsHash());
	}

	@SuppressWarnings(""resource"")
	private String calcSettingsHash() {
		JadxDecompiler decompiler = mainWindow.getWrapper().getCurrentDecompiler().orElse(null);
		return settings.toJadxArgs().makeCodeArgsHash(decompiler);
	}

	public MainWindow getMainWindow() {
		return mainWindow;
	}

	@Override
	public void dispose() {
		settings.saveWindowPos(this);
		super.dispose();
	}
}
","deobfOn
",toggleEnabled,deobfuscationOn/deobfscOn,deobfuscationCheckBox,deobfuscationOn,loses context with code that long
"package com.google.devtools.build.lib.worker;

import com.google.common.base.Throwables;
import com.google.common.base.VerifyException;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.eventbus.EventBus;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import javax.annotation.Nonnull;
import javax.annotation.concurrent.ThreadSafe;
import org.apache.commons.pool2.impl.EvictionPolicy;
import org.apache.commons.pool2.impl.GenericKeyedObjectPool;

/** Implementation of WorkerPool. */
@ThreadSafe
public class WorkerPoolImpl implements WorkerPool {
  /** Unless otherwise specified, the max number of workers per WorkerKey. */
  private static final int DEFAULT_MAX_WORKERS = 4;
  /** Unless otherwise specified, the max number of multiplex workers per WorkerKey. */
  private static final int DEFAULT_MAX_MULTIPLEX_WORKERS = 8;

  private final WorkerPoolConfig workerPoolConfig;
  /** Map of singleplex worker pools, one per mnemonic. */
  private final ImmutableMap<String, SimpleWorkerPool> workerPools;
  /** Map of multiplex worker pools, one per mnemonic. */
  private final ImmutableMap<String, SimpleWorkerPool> multiplexPools;

  /** Set of worker ids which are going to be destroyed after they are returned to the pool */
  private ImmutableSet<Integer> doomedWorkers = ImmutableSet.of();

  public WorkerPoolImpl(WorkerPoolConfig workerPoolConfig) {
    this.workerPoolConfig = workerPoolConfig;

    ImmutableMap<String, Integer> config =
        createConfigFromOptions(workerPoolConfig.getWorkerMaxInstances(), DEFAULT_MAX_WORKERS);
    ImmutableMap<String, Integer> multiplexConfig =
        createConfigFromOptions(
            workerPoolConfig.getWorkerMaxMultiplexInstances(), DEFAULT_MAX_MULTIPLEX_WORKERS);

    workerPools = createWorkerPools(workerPoolConfig.getWorkerFactory(), config);
    multiplexPools = createWorkerPools(workerPoolConfig.getWorkerFactory(), multiplexConfig);
  }

  public WorkerPoolConfig getWorkerPoolConfig() {
    return workerPoolConfig;
  }

  /**
   * Creates a configuration for a worker pool from the options given. If the same mnemonic occurs
   * more than once in the options, the last value passed wins.
   */
  @Nonnull
  private static ImmutableMap<String, Integer> createConfigFromOptions(
      List<Entry<String, Integer>> options, int defaultMaxWorkers) {
    LinkedHashMap<String, Integer> newConfigBuilder = new LinkedHashMap<>();
    for (Map.Entry<String, Integer> entry : options) {
      if (entry.getValue() != null) {
        newConfigBuilder.put(entry.getKey(), entry.getValue());
      } else if (entry.getKey() != null) {
        newConfigBuilder.put(entry.getKey(), defaultMaxWorkers);
      }
    }
    if (!newConfigBuilder.containsKey("""")) {
      // Empty string gives the number of workers for any type of worker not explicitly specified.
      // If no value is given, use the default.
      newConfigBuilder.put("""", defaultMaxWorkers);
    }
    return ImmutableMap.copyOf(newConfigBuilder);
  }

  private static ImmutableMap<String, SimpleWorkerPool> createWorkerPools(
      WorkerFactory factory, Map<String, Integer> config) {
    ImmutableMap.Builder<String, SimpleWorkerPool>  [MASK]  = ImmutableMap.builder();
    config.forEach(
        (key, value) ->  [MASK] .put(key, new SimpleWorkerPool(factory, value)));
    return  [MASK] .build();
  }

  private SimpleWorkerPool getPool(WorkerKey key) {
    if (key.isMultiplex()) {
      return multiplexPools.getOrDefault(key.getMnemonic(), multiplexPools.get(""""));
    } else {
      return workerPools.getOrDefault(key.getMnemonic(), workerPools.get(""""));
    }
  }

  @Override
  public int getMaxTotalPerKey(WorkerKey key) {
    return getPool(key).getMaxTotalPerKey(key);
  }

  public int getNumIdlePerKey(WorkerKey key) {
    return getPool(key).getNumIdle(key);
  }

  @Override
  public int getNumActive(WorkerKey key) {
    return getPool(key).getNumActive(key);
  }

  // TODO (b/242835648) filter throwed exceptions better
  @Override
  public void evictWithPolicy(EvictionPolicy<Worker> evictionPolicy) throws InterruptedException {
    for (SimpleWorkerPool pool : workerPools.values()) {
      evictWithPolicy(evictionPolicy, pool);
    }
    for (SimpleWorkerPool pool : multiplexPools.values()) {
      evictWithPolicy(evictionPolicy, pool);
    }
  }

  private void evictWithPolicy(EvictionPolicy<Worker> evictionPolicy, SimpleWorkerPool pool)
      throws InterruptedException {
    try {
        pool.setEvictionPolicy(evictionPolicy);
        pool.evict();
      } catch (Throwable t) {
        Throwables.propagateIfPossible(t, InterruptedException.class);
      throw new VerifyException(""unexpected"", t);
    }
  }

  /**
   * Gets a worker from worker pool. Could wait if no idle workers are available.
   *
   * @param key worker key
   * @return a worker
   */
  @Override
  public Worker borrowObject(WorkerKey key) throws IOException, InterruptedException {
    Worker result;
    try {
      result = getPool(key).borrowObject(key);
    } catch (Throwable t) {
      Throwables.propagateIfPossible(t, IOException.class, InterruptedException.class);
      throw new RuntimeException(""unexpected"", t);
    }
    return result;
  }

  @Override
  public void returnObject(WorkerKey key, Worker obj) {
    if (doomedWorkers.contains(obj.getWorkerId())) {
      obj.setDoomed(true);
    }
    getPool(key).returnObject(key, obj);
  }

  @Override
  public void invalidateObject(WorkerKey key, Worker obj) throws InterruptedException {
    if (doomedWorkers.contains(obj.getWorkerId())) {
      obj.setDoomed(true);
    }
    try {
      getPool(key).invalidateObject(key, obj);
    } catch (Throwable t) {
      Throwables.propagateIfPossible(t, InterruptedException.class);
      throw new RuntimeException(""unexpected"", t);
    }
  }

  @Override
  public synchronized void setDoomedWorkers(ImmutableSet<Integer> workerIds) {
    this.doomedWorkers = workerIds;
  }

  /** Clear set of doomed workers. Also reset all shrunk subtrahend of all worker pools. */
  @Override
  public synchronized void clearDoomedWorkers() {
    this.doomedWorkers = ImmutableSet.of();
    for (SimpleWorkerPool pool : workerPools.values()) {
      pool.clearShrunkBy();
    }
    for (SimpleWorkerPool pool : multiplexPools.values()) {
      pool.clearShrunkBy();
    }
  }

  ImmutableSet<Integer> getDoomedWorkers() {
    return doomedWorkers;
  }

  @Override
  public void setEventBus(EventBus eventBus) {
    for (SimpleWorkerPool pool : workerPools.values()) {
      pool.setEventBus(eventBus);
    }
    for (SimpleWorkerPool pool : multiplexPools.values()) {
      pool.setEventBus(eventBus);
    }
  }

  /**
   * Closes all the worker pools, destroying the workers in the process. This waits for any
   * currently-ongoing work to finish.
   */
  @Override
  public void close() {
    workerPools.values().forEach(GenericKeyedObjectPool::close);
    multiplexPools.values().forEach(GenericKeyedObjectPool::close);
  }

  /**
   * Describes the configuration of worker pool, e.g. number of maximal instances and priority of
   * the workers.
   */
  public static class WorkerPoolConfig {
    private final WorkerFactory workerFactory;
    private final List<Entry<String, Integer>> workerMaxInstances;
    private final List<Entry<String, Integer>> workerMaxMultiplexInstances;

    public WorkerPoolConfig(
        WorkerFactory workerFactory,
        List<Entry<String, Integer>> workerMaxInstances,
        List<Entry<String, Integer>> workerMaxMultiplexInstances) {
      this.workerFactory = workerFactory;
      this.workerMaxInstances = workerMaxInstances;
      this.workerMaxMultiplexInstances = workerMaxMultiplexInstances;
    }

    public WorkerFactory getWorkerFactory() {
      return workerFactory;
    }

    public List<Entry<String, Integer>> getWorkerMaxInstances() {
      return workerMaxInstances;
    }

    public List<Entry<String, Integer>> getWorkerMaxMultiplexInstances() {
      return workerMaxMultiplexInstances;
    }

    @Override
    public boolean equals(Object o) {
      if (this == o) {
        return true;
      }
      if (!(o instanceof WorkerPoolConfig)) {
        return false;
      }
      WorkerPoolConfig that = (WorkerPoolConfig) o;
      return workerFactory.equals(that.workerFactory)
          && workerMaxInstances.equals(that.workerMaxInstances)
          && workerMaxMultiplexInstances.equals(that.workerMaxMultiplexInstances);
    }

    @Override
    public int hashCode() {
      return Objects.hash(workerFactory, workerMaxInstances, workerMaxMultiplexInstances);
    }
  }
}
","workerPoolsBuilder
",workerPoolMap,newWorkPPoolBuilder,builder,pools,
"package com.badlogic.gdx.backends.android;

import android.opengl.GLSurfaceView.EGLConfigChooser;
import android.util.Log;
import android.view.SurfaceHolder;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.backends.android.surfaceview.GLSurfaceView20;
import com.badlogic.gdx.backends.android.surfaceview.ResolutionStrategy;
import com.badlogic.gdx.utils.GdxRuntimeException;

/** A subclass of {@link AndroidGraphics} specialized for live wallpaper applications.
 * 
 * @author mzechner */
public final class AndroidGraphicsLiveWallpaper extends AndroidGraphics {

        public AndroidGraphicsLiveWallpaper (AndroidLiveWallpaper lwp, AndroidApplicationConfiguration config,
                ResolutionStrategy  [MASK] ) {
                super(lwp, config,  [MASK] , false);
        }

        // jw: I replaced GL..SurfaceViewLW classes with their original counterparts, if it will work
        // on known devices, on opengl 1.0 and 2.0, and all possible SDK versions.. You can remove
        // GL..SurfaceViewLW family of classes completely (there is no use for them).

        // -> specific for live wallpapers
        // jw: synchronized access to current wallpaper surface holder
        SurfaceHolder getSurfaceHolder () {
                synchronized (((AndroidLiveWallpaper)app).service.sync) {
                        return ((AndroidLiveWallpaper)app).service.getSurfaceHolder();
                }
        }

        // <- specific for live wallpapers

        // Grabbed from AndroidGraphics superclass and modified to override
        // getHolder in created GLSurfaceView20 instances
        @Override
        protected GLSurfaceView20 createGLSurfaceView (AndroidApplicationBase application,
                final ResolutionStrategy  [MASK] ) {
                if (!checkGL20()) throw new GdxRuntimeException(""libGDX requires OpenGL ES 2.0"");

                EGLConfigChooser configChooser = getEglConfigChooser();
                GLSurfaceView20 view = new GLSurfaceView20(application.getContext(),  [MASK] ) {
                        @Override
                        public SurfaceHolder getHolder () {
                                return getSurfaceHolder();
                        }
                };

                if (configChooser != null)
                        view.setEGLConfigChooser(configChooser);
                else
                        view.setEGLConfigChooser(config.r, config.g, config.b, config.a, config.depth, config.stencil);
                view.setRenderer(this);
                return view;
        }

        // kill the GLThread managed by GLSurfaceView (only for GLSurfaceView because GLSurffaceViewCupcake stops thread in
        // onPause events - which is not as easy and safe for GLSurfaceView)
        public void onDestroyGLSurfaceView () {
                if (view != null) {
                        try {
                                // onDetachedFromWindow stops GLThread by calling mGLThread.requestExitAndWait()
                                view.onDetachedFromWindow();
                                if (AndroidLiveWallpaperService.DEBUG) Log.d(AndroidLiveWallpaperService.TAG,
                                        "" > AndroidLiveWallpaper - onDestroy() stopped GLThread managed by GLSurfaceView"");
                        } catch (Throwable t) {
                                // error while scheduling exit of GLThread, GLThread will remain live and wallpaper service
                                // wouldn't be able to shutdown completely
                                Log.e(AndroidLiveWallpaperService.TAG,
                                        ""failed to destroy GLSurfaceView's thread! GLSurfaceView.onDetachedFromWindow impl changed since API lvl 16!"");
                                t.printStackTrace();
                        }
                }
        }

        @Override
        void resume () {
                synchronized (synch) {
                        running = true;
                        resume = true;

                        while (resume) {
                                try {
                                        requestRendering();
                                        synch.wait();
                                } catch (InterruptedException ignored) {
                                        Gdx.app.log(""AndroidGraphics"", ""waiting for resume synchronization failed!"");
                                }
                        }
                }
        }

        @Override
        public void onDrawFrame (javax.microedition.khronos.opengles.GL10 gl) {
                long time = System.nanoTime();
                // After pause deltaTime can have somewhat huge value that destabilizes the mean, so let's cut it off
                if (!resume) {
                        deltaTime = (time - lastFrameTime) / 1000000000.0f;
                } else {
                        deltaTime = 0;
                }
                lastFrameTime = time;

                boolean lrunning = false;
                boolean lpause = false;
                boolean ldestroy = false;
                boolean lresume = false;

                synchronized (synch) {
                        lrunning = running;
                        lpause = pause;
                        ldestroy = destroy;
                        lresume = resume;

                        if (resume) {
                                resume = false;
                                synch.notifyAll();
                        }

                        if (pause) {
                                pause = false;
                                synch.notifyAll();
                        }

                        if (destroy) {
                                destroy = false;
                                synch.notifyAll();
                        }
                }

                if (lresume) {
                        // ((AndroidAudio)app.getAudio()).resume(); // jw: moved to AndroidLiveWallpaper.onResume
                        app.getApplicationListener().resume();
                        Gdx.app.log(""AndroidGraphics"", ""resumed"");
                }

                // HACK: added null check to handle set wallpaper from preview null
                // error in renderer
                // jw: this hack is not working always, renderer ends with error for some devices - because of uninitialized gl context
                // jw: now it shouldn't be necessary - after wallpaper backend refactoring:)
                if (lrunning) {

                        // jw: changed
                        synchronized (app.getRunnables()) {
                                app.getExecutedRunnables().clear();
                                app.getExecutedRunnables().addAll(app.getRunnables());
                                app.getRunnables().clear();

                                for (int i = 0; i < app.getExecutedRunnables().size; i++) {
                                        try {
                                                app.getExecutedRunnables().get(i).run();
                                        } catch (Throwable t) {
                                                t.printStackTrace();
                                        }
                                }
                        }
                        /*
                         * synchronized (app.runnables) { for (int i = 0; i < app.runnables.size; i++) { app.runnables.get(i).run(); }
                         * app.runnables.clear(); }
                         */

                        app.getInput().processEvents();
                        frameId++;
                        app.getApplicationListener().render();
                }

                // jw: never called on lvp, why? see description in AndroidLiveWallpaper.onPause
                if (lpause) {
                        app.getApplicationListener().pause();
                        // ((AndroidAudio)app.getAudio()).pause(); jw: moved to AndroidLiveWallpaper.onPause
                        Gdx.app.log(""AndroidGraphics"", ""paused"");
                }

                // jw: never called on lwp, why? see description in AndroidLiveWallpaper.onPause
                if (ldestroy) {
                        app.getApplicationListener().dispose();
                        // ((AndroidAudio)app.getAudio()).dispose(); jw: moved to AndroidLiveWallpaper.onDestroy
                        Gdx.app.log(""AndroidGraphics"", ""destroyed"");
                }

                if (time - frameStart > 1000000000) {
                        fps = frames;
                        frames = 0;
                        frameStart = time;
                }
                frames++;
        }

        @Override
        protected void logManagedCachesStatus () {
                // to prevent creating too many string buffers in live wallpapers
                if (AndroidLiveWallpaperService.DEBUG) {
                        super.logManagedCachesStatus();
                }
        }
}
","resolutionStrategy
","resolutionStrategy
",resolutionStrategy,resolutionStrategy ,resolutionStrategy,
"package com.blankj.base_transform.util;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

/**
 * <pre>
 *     author: Blankj
 *     blog  : http://blankj.com
 *     time  : 2016/08/27
 *     desc  : utils about zip or jar
 * </pre>
 */
public final class ZipUtils {

    private static final int BUFFER_LEN = 8192;

    private ZipUtils() {
        throw new UnsupportedOperationException(""u can't instantiate me..."");
    }

    /**
     * Zip the files.
     *
     * @param srcFiles    The source of files.
     * @param zipFilePath The path of ZIP file.
     * @return {@code true}: success<br>{@code false}: fail
     * @throws IOException if an I/O error has occurred
     */
    public static boolean zipFiles(final Collection<String> srcFiles,
                                   final String zipFilePath)
            throws IOException {
        return zipFiles(srcFiles, zipFilePath, null);
    }

    /**
     * Zip the files.
     *
     * @param srcFilePaths The paths of source files.
     * @param zipFilePath  The path of ZIP file.
     * @param comment      The comment.
     * @return {@code true}: success<br>{@code false}: fail
     * @throws IOException if an I/O error has occurred
     */
    public static boolean zipFiles(final Collection<String> srcFilePaths,
                                   final String zipFilePath,
                                   final String comment)
            throws IOException {
        if (srcFilePaths == null || zipFilePath == null) return false;
        ZipOutputStream zos = null;
        try {
            zos = new ZipOutputStream(new FileOutputStream(zipFilePath));
            for (String srcFile : srcFilePaths) {
                if (!zipFile(getFileByPath(srcFile), """", zos, comment)) return false;
            }
            return true;
        } finally {
            if (zos != null) {
                zos.finish();
                zos.close();
            }
        }
    }

    /**
     * Zip the files.
     *
     * @param srcFiles The source of files.
     * @param zipFile  The ZIP file.
     * @return {@code true}: success<br>{@code false}: fail
     * @throws IOException if an I/O error has occurred
     */
    public static boolean zipFiles(final Collection<File> srcFiles, final File zipFile)
            throws IOException {
        return zipFiles(srcFiles, zipFile, null);
    }

    /**
     * Zip the files.
     *
     * @param srcFiles The source of files.
     * @param zipFile  The ZIP file.
     * @param comment  The comment.
     * @return {@code true}: success<br>{@code false}: fail
     * @throws IOException if an I/O error has occurred
     */
    public static boolean zipFiles(final Collection<File> srcFiles,
                                   final File zipFile,
                                   final String comment)
            throws IOException {
        if (srcFiles == null || zipFile == null) return false;
        ZipOutputStream zos = null;
        try {
            zos = new ZipOutputStream(new FileOutputStream(zipFile));
            for (File srcFile : srcFiles) {
                if (!zipFile(srcFile, """", zos, comment)) return false;
            }
            return true;
        } finally {
            if (zos != null) {
                zos.finish();
                zos.close();
            }
        }
    }

    /**
     * Zip the file.
     *
     * @param srcFilePath The path of source file.
     * @param zipFilePath The path of ZIP file.
     * @return {@code true}: success<br>{@code false}: fail
     * @throws IOException if an I/O error has occurred
     */
    public static boolean zipFile(final String srcFilePath,
                                  final String zipFilePath)
            throws IOException {
        return zipFile(getFileByPath(srcFilePath), getFileByPath(zipFilePath), null);
    }

    /**
     * Zip the file.
     *
     * @param srcFilePath The path of source file.
     * @param zipFilePath The path of ZIP file.
     * @param comment     The comment.
     * @return {@code true}: success<br>{@code false}: fail
     * @throws IOException if an I/O error has occurred
     */
    public static boolean zipFile(final String srcFilePath,
                                  final String zipFilePath,
                                  final String comment)
            throws IOException {
        return zipFile(getFileByPath(srcFilePath), getFileByPath(zipFilePath), comment);
    }

    /**
     * Zip the file.
     *
     * @param srcFile The source of file.
     * @param zipFile The ZIP file.
     * @return {@code true}: success<br>{@code false}: fail
     * @throws IOException if an I/O error has occurred
     */
    public static boolean zipFile(final File srcFile,
                                  final File zipFile)
            throws IOException {
        return zipFile(srcFile, zipFile, null);
    }

    /**
     * Zip the file.
     *
     * @param srcFile The source of file.
     * @param zipFile The ZIP file.
     * @param comment The comment.
     * @return {@code true}: success<br>{@code false}: fail
     * @throws IOException if an I/O error has occurred
     */
    public static boolean zipFile(final File srcFile,
                                  final File zipFile,
                                  final String comment)
            throws IOException {
        if (srcFile == null || zipFile == null) return false;
        ZipOutputStream zos = null;
        try {
            zos = new ZipOutputStream(new FileOutputStream(zipFile));
            return zipFile(srcFile, """", zos, comment);
        } finally {
            if (zos != null) {
                zos.close();
            }
        }
    }

    private static boolean zipFile(final File srcFile,
                                   String rootPath,
                                   final ZipOutputStream zos,
                                   final String comment)
            throws IOException {
        rootPath = rootPath + (isSpace(rootPath) ? """" : File.separator) + srcFile.getName();
        if (srcFile.isDirectory()) {
            File[] fileList = srcFile.listFiles();
            if (fileList == null || fileList.length <= 0) {
                ZipEntry entry = new ZipEntry(rootPath + '/');
                entry.setComment(comment);
                zos.putNextEntry(entry);
                zos.closeEntry();
            } else {
                for (File file : fileList) {
                    if (!zipFile(file, rootPath, zos, comment)) return false;
                }
            }
        } else {
            InputStream is = null;
            try {
                is = new BufferedInputStream(new FileInputStream(srcFile));
                ZipEntry entry = new ZipEntry(rootPath);
                entry.setComment(comment);
                zos.putNextEntry(entry);
                byte buffer[] = new byte[BUFFER_LEN];
                int len;
                while ((len = is.read(buffer, 0, BUFFER_LEN)) != -1) {
                    zos.write(buffer, 0, len);
                }
                zos.closeEntry();
            } finally {
                if (is != null) {
                    is.close();
                }
            }
        }
        return true;
    }

    /**
     * Unzip the file.
     *
     * @param zipFilePath The path of ZIP file.
     * @param destDirPath The path of destination directory.
     * @return the unzipped files
     * @throws IOException if unzip unsuccessfully
     */
    public static List<File> unzipFile(final String zipFilePath,
                                       final String destDirPath)
            throws IOException {
        return unzipFileByKeyword(zipFilePath, destDirPath, null);
    }

    /**
     * Unzip the file.
     *
     * @param zipFile The ZIP file.
     * @param destDir The destination directory.
     * @return the unzipped files
     * @throws IOException if unzip unsuccessfully
     */
    public static List<File> unzipFile(final File zipFile,
                                       final File destDir)
            throws IOException {
        return unzipFileByKeyword(zipFile, destDir, null);
    }

    /**
     * Unzip the file by keyword.
     *
     * @param zipFilePath The path of ZIP file.
     * @param destDirPath The path of destination directory.
     * @param keyword     The keyboard.
     * @return the unzipped files
     * @throws IOException if unzip unsuccessfully
     */
    public static List<File> unzipFileByKeyword(final String zipFilePath,
                                                final String destDirPath,
                                                final String keyword)
            throws IOException {
        return unzipFileByKeyword(getFileByPath(zipFilePath), getFileByPath(destDirPath), keyword);
    }

    /**
     * Unzip the file by keyword.
     *
     * @param zipFile The ZIP file.
     * @param destDir The destination directory.
     * @param keyword The keyboard.
     * @return the unzipped files
     * @throws IOException if unzip unsuccessfully
     */
    public static List<File> unzipFileByKeyword(final File zipFile,
                                                final File destDir,
                                                final String keyword)
            throws IOException {
        if (zipFile == null || destDir == null) return null;
        List<File> files = new ArrayList<>();
        ZipFile zip = new ZipFile(zipFile);
        Enumeration<?> entries = zip.entries();
        try {
            if (isSpace(keyword)) {
                while (entries.hasMoreElements()) {
                    ZipEntry entry = ((ZipEntry) entries.nextElement());
                    String  [MASK]  = entry.getName();
                    if ( [MASK] .contains(""../"")) {
                        System.err.println("" [MASK] : "" +  [MASK]  + "" is dangerous!"");
                        continue;
                    }
                    if (!unzipChildFile(destDir, files, zip, entry,  [MASK] )) return files;
                }
            } else {
                while (entries.hasMoreElements()) {
                    ZipEntry entry = ((ZipEntry) entries.nextElement());
                    String  [MASK]  = entry.getName();
                    if ( [MASK] .contains(""../"")) {
                        System.out.println("" [MASK] : "" +  [MASK]  + "" is dangerous!"");
                        continue;
                    }
                    if ( [MASK] .contains(keyword)) {
                        if (!unzipChildFile(destDir, files, zip, entry,  [MASK] )) return files;
                    }
                }
            }
        } finally {
            zip.close();
        }
        return files;
    }

    private static boolean unzipChildFile(final File destDir,
                                          final List<File> files,
                                          final ZipFile zip,
                                          final ZipEntry entry,
                                          final String name) throws IOException {
        File file = new File(destDir, name);
        files.add(file);
        if (entry.isDirectory()) {
            return createOrExistsDir(file);
        } else {
            if (!createOrExistsFile(file)) return false;
            InputStream in = null;
            OutputStream out = null;
            try {
                in = new BufferedInputStream(zip.getInputStream(entry));
                out = new BufferedOutputStream(new FileOutputStream(file));
                byte buffer[] = new byte[BUFFER_LEN];
                int len;
                while ((len = in.read(buffer)) != -1) {
                    out.write(buffer, 0, len);
                }
            } finally {
                if (in != null) {
                    in.close();
                }
                if (out != null) {
                    out.close();
                }
            }
        }
        return true;
    }

    /**
     * Return the files' path in ZIP file.
     *
     * @param zipFilePath The path of ZIP file.
     * @return the files' path in ZIP file
     * @throws IOException if an I/O error has occurred
     */
    public static List<String> getFilesPath(final String zipFilePath)
            throws IOException {
        return getFilesPath(getFileByPath(zipFilePath));
    }

    /**
     * Return the files' path in ZIP file.
     *
     * @param zipFile The ZIP file.
     * @return the files' path in ZIP file
     * @throws IOException if an I/O error has occurred
     */
    public static List<String> getFilesPath(final File zipFile)
            throws IOException {
        if (zipFile == null) return null;
        List<String> paths = new ArrayList<>();
        ZipFile zip = new ZipFile(zipFile);
        Enumeration<?> entries = zip.entries();
        while (entries.hasMoreElements()) {
            String  [MASK]  = ((ZipEntry) entries.nextElement()).getName();
            if ( [MASK] .contains(""../"")) {
                System.out.println("" [MASK] : "" +  [MASK]  + "" is dangerous!"");
                paths.add( [MASK] );
            } else {
                paths.add( [MASK] );
            }
        }
        zip.close();
        return paths;
    }

    /**
     * Return the files' comment in ZIP file.
     *
     * @param zipFilePath The path of ZIP file.
     * @return the files' comment in ZIP file
     * @throws IOException if an I/O error has occurred
     */
    public static List<String> getComments(final String zipFilePath)
            throws IOException {
        return getComments(getFileByPath(zipFilePath));
    }

    /**
     * Return the files' comment in ZIP file.
     *
     * @param zipFile The ZIP file.
     * @return the files' comment in ZIP file
     * @throws IOException if an I/O error has occurred
     */
    public static List<String> getComments(final File zipFile)
            throws IOException {
        if (zipFile == null) return null;
        List<String> comments = new ArrayList<>();
        ZipFile zip = new ZipFile(zipFile);
        Enumeration<?> entries = zip.entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = ((ZipEntry) entries.nextElement());
            comments.add(entry.getComment());
        }
        zip.close();
        return comments;
    }

    private static boolean createOrExistsDir(final File file) {
        return file != null && (file.exists() ? file.isDirectory() : file.mkdirs());
    }

    private static boolean createOrExistsFile(final File file) {
        if (file == null) return false;
        if (file.exists()) return file.isFile();
        if (!createOrExistsDir(file.getParentFile())) return false;
        try {
            return file.createNewFile();
        } catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    private static File getFileByPath(final String filePath) {
        return isSpace(filePath) ? null : new File(filePath);
    }

    private static boolean isSpace(final String s) {
        if (s == null) return true;
        for (int i = 0, len = s.length(); i < len; ++i) {
            if (!Character.isWhitespace(s.charAt(i))) {
                return false;
            }
        }
        return true;
    }
}
","entryName
",zipEntryName,entryName,entryName,entryName,
"
package io.netty.handler.traffic;

import static io.netty.util.internal.ObjectUtil.checkNotNull;
import static io.netty.util.internal.ObjectUtil.checkNotNullWithIAE;
import io.netty.util.internal.logging.InternalLogger;
import io.netty.util.internal.logging.InternalLoggerFactory;

import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;


/**
 * Counts the number of read and written bytes for rate-limiting traffic.
 * <p>
 * It computes the statistics for both inbound and outbound traffic periodically at the given
 * {@code checkInterval}, and calls the {@link AbstractTrafficShapingHandler#doAccounting(TrafficCounter)} method back.
 * If the {@code checkInterval} is {@code 0}, no accounting will be done and statistics will only be computed at each
 * receive or write operation.
 * </p>
 */
public class TrafficCounter {

    private static final InternalLogger logger = InternalLoggerFactory.getInstance(TrafficCounter.class);

    /**
     * @return the time in ms using nanoTime, so not real EPOCH time but elapsed time in ms.
     */
    public static long milliSecondFromNano() {
        return System.nanoTime() / 1000000;
    }

    /**
     * Current written bytes
     */
    private final AtomicLong currentWrittenBytes = new AtomicLong();

    /**
     * Current read bytes
     */
    private final AtomicLong currentReadBytes = new AtomicLong();

    /**
     * Last writing time during current check interval
     */
    private long writingTime;

    /**
     * Last reading delay during current check interval
     */
    private long readingTime;

    /**
     * Long life written bytes
     */
    private final AtomicLong cumulativeWrittenBytes = new AtomicLong();

    /**
     * Long life read bytes
     */
    private final AtomicLong cumulativeReadBytes = new AtomicLong();

    /**
     * Last Time where cumulative bytes where reset to zero: this time is a real EPOC time (informative only)
     */
    private long lastCumulativeTime;

    /**
     * Last writing bandwidth
     */
    private long lastWriteThroughput;

    /**
     * Last reading bandwidth
     */
    private long lastReadThroughput;

    /**
     * Last Time Check taken
     */
    final AtomicLong lastTime = new AtomicLong();

    /**
     * Last written bytes number during last check interval
     */
    private volatile long lastWrittenBytes;

    /**
     * Last read bytes number during last check interval
     */
    private volatile long lastReadBytes;

    /**
     * Last future writing time during last check interval
     */
    private volatile long lastWritingTime;

    /**
     * Last reading time during last check interval
     */
    private volatile long lastReadingTime;

    /**
     * Real written bytes
     */
    private final AtomicLong realWrittenBytes = new AtomicLong();

    /**
     * Real writing bandwidth
     */
    private long realWriteThroughput;

    /**
     * Delay between two captures
     */
    final AtomicLong checkInterval = new AtomicLong(
            AbstractTrafficShapingHandler.DEFAULT_CHECK_INTERVAL);

    // default 1 s

    /**
     * Name of this Monitor
     */
    final String name;

    /**
     * The associated TrafficShapingHandler
     */
    final AbstractTrafficShapingHandler trafficShapingHandler;

    /**
     * Executor that will run the monitor
     */
    final ScheduledExecutorService executor;
    /**
     * Monitor created once in start()
     */
    Runnable monitor;
    /**
     * used in stop() to cancel the timer
     */
    volatile ScheduledFuture<?> scheduledFuture;

    /**
     * Is Monitor active
     */
    volatile boolean monitorActive;

    /**
     * Class to implement monitoring at fix delay
     *
     */
    private final class TrafficMonitoringTask implements Runnable {
        @Override
        public void run() {
            if (!monitorActive) {
                return;
            }
            resetAccounting(milliSecondFromNano());
            if (trafficShapingHandler != null) {
                trafficShapingHandler.doAccounting(TrafficCounter.this);
            }
        }
    }

    /**
     * Start the monitoring process.
     */
    public synchronized void start() {
        if (monitorActive) {
            return;
        }
        lastTime.set(milliSecondFromNano());
        long localCheckInterval = checkInterval.get();
        // if executor is null, it means it is piloted by a GlobalChannelTrafficCounter, so no executor
        if (localCheckInterval > 0 && executor != null) {
            monitorActive = true;
            monitor = new TrafficMonitoringTask();
            scheduledFuture =
                executor.scheduleAtFixedRate(monitor, 0, localCheckInterval, TimeUnit.MILLISECONDS);
        }
    }

    /**
     * Stop the monitoring process.
     */
    public synchronized void stop() {
        if (!monitorActive) {
            return;
        }
        monitorActive = false;
        resetAccounting(milliSecondFromNano());
        if (trafficShapingHandler != null) {
            trafficShapingHandler.doAccounting(this);
        }
        if (scheduledFuture != null) {
            scheduledFuture.cancel(true);
        }
    }

    /**
     * Reset the accounting on Read and Write.
     *
     * @param newLastTime the milliseconds unix timestamp that we should be considered up-to-date for.
     */
    synchronized void resetAccounting(long newLastTime) {
        long interval = newLastTime - lastTime.getAndSet(newLastTime);
        if (interval == 0) {
            // nothing to do
            return;
        }
        if (logger.isDebugEnabled() && interval > checkInterval() << 1) {
            logger.debug(""Acct schedule not ok: "" + interval + "" > 2*"" + checkInterval() + "" from "" + name);
        }
        lastReadBytes = currentReadBytes.getAndSet(0);
        lastWrittenBytes = currentWrittenBytes.getAndSet(0);
        lastReadThroughput = lastReadBytes * 1000 / interval;
        // nb byte / checkInterval in ms * 1000 (1s)
        lastWriteThroughput = lastWrittenBytes * 1000 / interval;
        // nb byte / checkInterval in ms * 1000 (1s)
        realWriteThroughput = realWrittenBytes.getAndSet(0) * 1000 / interval;
        lastWritingTime = Math.max(lastWritingTime, writingTime);
        lastReadingTime = Math.max(lastReadingTime, readingTime);
    }

    /**
     * Constructor with the {@link AbstractTrafficShapingHandler} that hosts it, the {@link ScheduledExecutorService}
     * to use, its name, the checkInterval between two computations in milliseconds.
     *
     * @param executor
     *            the underlying executor service for scheduling checks, might be null when used
     * from {@link GlobalChannelTrafficCounter}.
     * @param name
     *            the name given to this monitor.
     * @param checkInterval
     *            the checkInterval in millisecond between two computations.
     */
    public TrafficCounter(ScheduledExecutorService executor, String name, long checkInterval) {

        this.name = checkNotNull(name, ""name"");
        trafficShapingHandler = null;
        this.executor = executor;

        init(checkInterval);
    }

    /**
     * Constructor with the {@link AbstractTrafficShapingHandler} that hosts it, the Timer to use, its
     * name, the checkInterval between two computations in millisecond.
     *
     * @param trafficShapingHandler
     *            the associated AbstractTrafficShapingHandler.
     * @param executor
     *            the underlying executor service for scheduling checks, might be null when used
     * from {@link GlobalChannelTrafficCounter}.
     * @param name
     *            the name given to this monitor.
     * @param checkInterval
     *            the checkInterval in millisecond between two computations.
     */
    public TrafficCounter(
            AbstractTrafficShapingHandler trafficShapingHandler, ScheduledExecutorService executor,
            String name, long checkInterval) {
        this.name = checkNotNull(name, ""name"");
        this.trafficShapingHandler = checkNotNullWithIAE(trafficShapingHandler, ""trafficShapingHandler"");
        this.executor = executor;

        init(checkInterval);
    }

    private void init(long checkInterval) {
        // absolute time: informative only
        lastCumulativeTime = System.currentTimeMillis();
        writingTime = milliSecondFromNano();
        readingTime = writingTime;
        lastWritingTime = writingTime;
        lastReadingTime = writingTime;
        configure(checkInterval);
    }

    /**
     * Change checkInterval between two computations in millisecond.
     *
     * @param newCheckInterval The new check interval (in milliseconds)
     */
    public void configure(long newCheckInterval) {
        long  [MASK]  = newCheckInterval / 10 * 10;
        if (checkInterval.getAndSet( [MASK] ) !=  [MASK] ) {
            if ( [MASK]  <= 0) {
                stop();
                // No more active monitoring
                lastTime.set(milliSecondFromNano());
            } else {
                // Restart
                stop();
                start();
            }
        }
    }

    /**
     * Computes counters for Read.
     *
     * @param recv
     *            the size in bytes to read
     */
    void bytesRecvFlowControl(long recv) {
        currentReadBytes.addAndGet(recv);
        cumulativeReadBytes.addAndGet(recv);
    }

    /**
     * Computes counters for Write.
     *
     * @param write
     *            the size in bytes to write
     */
    void bytesWriteFlowControl(long write) {
        currentWrittenBytes.addAndGet(write);
        cumulativeWrittenBytes.addAndGet(write);
    }

    /**
     * Computes counters for Real Write.
     *
     * @param write
     *            the size in bytes to write
     */
    void bytesRealWriteFlowControl(long write) {
        realWrittenBytes.addAndGet(write);
    }

    /**
     * @return the current checkInterval between two computations of traffic counter
     *         in millisecond.
     */
    public long checkInterval() {
        return checkInterval.get();
    }

    /**
     * @return the Read Throughput in bytes/s computes in the last check interval.
     */
    public long lastReadThroughput() {
        return lastReadThroughput;
    }

    /**
     * @return the Write Throughput in bytes/s computes in the last check interval.
     */
    public long lastWriteThroughput() {
        return lastWriteThroughput;
    }

    /**
     * @return the number of bytes read during the last check Interval.
     */
    public long lastReadBytes() {
        return lastReadBytes;
    }

    /**
     * @return the number of bytes written during the last check Interval.
     */
    public long lastWrittenBytes() {
        return lastWrittenBytes;
    }

    /**
     * @return the current number of bytes read since the last checkInterval.
     */
    public long currentReadBytes() {
        return currentReadBytes.get();
    }

    /**
     * @return the current number of bytes written since the last check Interval.
     */
    public long currentWrittenBytes() {
        return currentWrittenBytes.get();
    }

    /**
     * @return the Time in millisecond of the last check as of System.currentTimeMillis().
     */
    public long lastTime() {
        return lastTime.get();
    }

    /**
     * @return the cumulativeWrittenBytes
     */
    public long cumulativeWrittenBytes() {
        return cumulativeWrittenBytes.get();
    }

    /**
     * @return the cumulativeReadBytes
     */
    public long cumulativeReadBytes() {
        return cumulativeReadBytes.get();
    }

    /**
     * @return the lastCumulativeTime in millisecond as of System.currentTimeMillis()
     * when the cumulative counters were reset to 0.
     */
    public long lastCumulativeTime() {
        return lastCumulativeTime;
    }

    /**
     * @return the realWrittenBytes
     */
    public AtomicLong getRealWrittenBytes() {
        return realWrittenBytes;
    }

    /**
     * @return the realWriteThroughput
     */
    public long getRealWriteThroughput() {
        return realWriteThroughput;
    }

    /**
     * Reset both read and written cumulative bytes counters and the associated absolute time
     * from System.currentTimeMillis().
     */
    public void resetCumulativeTime() {
        lastCumulativeTime = System.currentTimeMillis();
        cumulativeReadBytes.set(0);
        cumulativeWrittenBytes.set(0);
    }

    /**
     * @return the name of this TrafficCounter.
     */
    public String name() {
        return name;
    }

    /**
     * Returns the time to wait (if any) for the given length message, using the given limitTraffic and the max wait
     * time.
     *
     * @param size
     *            the recv size
     * @param limitTraffic
     *            the traffic limit in bytes per second.
     * @param maxTime
     *            the max time in ms to wait in case of excess of traffic.
     * @return the current time to wait (in ms) if needed for Read operation.
     */
    @Deprecated
    public long readTimeToWait(final long size, final long limitTraffic, final long maxTime) {
        return readTimeToWait(size, limitTraffic, maxTime, milliSecondFromNano());
    }

    /**
     * Returns the time to wait (if any) for the given length message, using the given limitTraffic and the max wait
     * time.
     *
     * @param size
     *            the recv size
     * @param limitTraffic
     *            the traffic limit in bytes per second
     * @param maxTime
     *            the max time in ms to wait in case of excess of traffic.
     * @param now the current time
     * @return the current time to wait (in ms) if needed for Read operation.
     */
    public long readTimeToWait(final long size, final long limitTraffic, final long maxTime, final long now) {
        bytesRecvFlowControl(size);
        if (size == 0 || limitTraffic == 0) {
            return 0;
        }
        final long lastTimeCheck = lastTime.get();
        long sum = currentReadBytes.get();
        long localReadingTime = readingTime;
        long lastRB = lastReadBytes;
        final long interval = now - lastTimeCheck;
        long pastDelay = Math.max(lastReadingTime - lastTimeCheck, 0);
        if (interval > AbstractTrafficShapingHandler.MINIMAL_WAIT) {
            // Enough interval time to compute shaping
            long time = sum * 1000 / limitTraffic - interval + pastDelay;
            if (time > AbstractTrafficShapingHandler.MINIMAL_WAIT) {
                if (logger.isDebugEnabled()) {
                    logger.debug(""Time: "" + time + ':' + sum + ':' + interval + ':' + pastDelay);
                }
                if (time > maxTime && now + time - localReadingTime > maxTime) {
                    time = maxTime;
                }
                readingTime = Math.max(localReadingTime, now + time);
                return time;
            }
            readingTime = Math.max(localReadingTime, now);
            return 0;
        }
        // take the last read interval check to get enough interval time
        long lastsum = sum + lastRB;
        long lastinterval = interval + checkInterval.get();
        long time = lastsum * 1000 / limitTraffic - lastinterval + pastDelay;
        if (time > AbstractTrafficShapingHandler.MINIMAL_WAIT) {
            if (logger.isDebugEnabled()) {
                logger.debug(""Time: "" + time + ':' + lastsum + ':' + lastinterval + ':' + pastDelay);
            }
            if (time > maxTime && now + time - localReadingTime > maxTime) {
                time = maxTime;
            }
            readingTime = Math.max(localReadingTime, now + time);
            return time;
        }
        readingTime = Math.max(localReadingTime, now);
        return 0;
    }

    /**
     * Returns the time to wait (if any) for the given length message, using the given limitTraffic and
     * the max wait time.
     *
     * @param size
     *            the write size
     * @param limitTraffic
     *            the traffic limit in bytes per second.
     * @param maxTime
     *            the max time in ms to wait in case of excess of traffic.
     * @return the current time to wait (in ms) if needed for Write operation.
     */
    @Deprecated
    public long writeTimeToWait(final long size, final long limitTraffic, final long maxTime) {
        return writeTimeToWait(size, limitTraffic, maxTime, milliSecondFromNano());
    }

    /**
     * Returns the time to wait (if any) for the given length message, using the given limitTraffic and
     * the max wait time.
     *
     * @param size
     *            the write size
     * @param limitTraffic
     *            the traffic limit in bytes per second.
     * @param maxTime
     *            the max time in ms to wait in case of excess of traffic.
     * @param now the current time
     * @return the current time to wait (in ms) if needed for Write operation.
     */
    public long writeTimeToWait(final long size, final long limitTraffic, final long maxTime, final long now) {
        bytesWriteFlowControl(size);
        if (size == 0 || limitTraffic == 0) {
            return 0;
        }
        final long lastTimeCheck = lastTime.get();
        long sum = currentWrittenBytes.get();
        long lastWB = lastWrittenBytes;
        long localWritingTime = writingTime;
        long pastDelay = Math.max(lastWritingTime - lastTimeCheck, 0);
        final long interval = now - lastTimeCheck;
        if (interval > AbstractTrafficShapingHandler.MINIMAL_WAIT) {
            // Enough interval time to compute shaping
            long time = sum * 1000 / limitTraffic - interval + pastDelay;
            if (time > AbstractTrafficShapingHandler.MINIMAL_WAIT) {
                if (logger.isDebugEnabled()) {
                    logger.debug(""Time: "" + time + ':' + sum + ':' + interval + ':' + pastDelay);
                }
                if (time > maxTime && now + time - localWritingTime > maxTime) {
                    time = maxTime;
                }
                writingTime = Math.max(localWritingTime, now + time);
                return time;
            }
            writingTime = Math.max(localWritingTime, now);
            return 0;
        }
        // take the last write interval check to get enough interval time
        long lastsum = sum + lastWB;
        long lastinterval = interval + checkInterval.get();
        long time = lastsum * 1000 / limitTraffic - lastinterval + pastDelay;
        if (time > AbstractTrafficShapingHandler.MINIMAL_WAIT) {
            if (logger.isDebugEnabled()) {
                logger.debug(""Time: "" + time + ':' + lastsum + ':' + lastinterval + ':' + pastDelay);
            }
            if (time > maxTime && now + time - localWritingTime > maxTime) {
                time = maxTime;
            }
            writingTime = Math.max(localWritingTime, now + time);
            return time;
        }
        writingTime = Math.max(localWritingTime, now);
        return 0;
    }

    @Override
    public String toString() {
        return new StringBuilder(165).append(""Monitor "").append(name)
                .append("" Current Speed Read: "").append(lastReadThroughput >> 10).append("" KB/s, "")
                .append(""Asked Write: "").append(lastWriteThroughput >> 10).append("" KB/s, "")
                .append(""Real Write: "").append(realWriteThroughput >> 10).append("" KB/s, "")
                .append(""Current Read: "").append(currentReadBytes.get() >> 10).append("" KB, "")
                .append(""Current asked Write: "").append(currentWrittenBytes.get() >> 10).append("" KB, "")
                .append(""Current real Write: "").append(realWrittenBytes.get() >> 10).append("" KB"").toString();
    }
}
","newInterval
",oldInter,oldCheckInterval,checkInterval,limitTraffic,
"
package org.apache.dubbo.rpc.cluster.router.condition.config.model;

import org.apache.dubbo.rpc.cluster.router.AbstractRouterRule;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static org.apache.dubbo.rpc.cluster.Constants.CONDITIONS_KEY;

public class ConditionRouterRule extends AbstractRouterRule {
    private List<String>  [MASK] ;

    @SuppressWarnings(""unchecked"")
    public static ConditionRouterRule parseFromMap(Map<String, Object> map) {
        ConditionRouterRule conditionRouterRule = new ConditionRouterRule();
        conditionRouterRule.parseFromMap0(map);

        Object  [MASK]  = map.get(CONDITIONS_KEY);
        if ( [MASK]  != null && List.class.isAssignableFrom( [MASK] .getClass())) {
            conditionRouterRule.setConditions(((List<Object>)  [MASK] ).stream()
                    .map(String::valueOf).collect(Collectors.toList()));
        }

        return conditionRouterRule;
    }

    public ConditionRouterRule() {
    }

    public List<String> getConditions() {
        return  [MASK] ;
    }

    public void setConditions(List<String>  [MASK] ) {
        this. [MASK]  =  [MASK] ;
    }
}
","conditions
",conditions,"conditions
",conditionList,conditions,
"
package com.google.android.exoplayer2.transformer;

import static java.lang.Math.pow;

/**
 * Image comparison tool that calculates the Mean Structural Similarity (MSSIM) of two images,
 * developed by Wang, Bovik, Sheikh, and Simoncelli.
 *
 * <p>MSSIM divides the image into windows, calculates SSIM of each, then returns the average.
 *
 * <p>See <a href=https://ece.uwaterloo.ca/~z70wang/publications/ssim.pdf>the SSIM paper</a>.
 *
 * @deprecated com.google.android.exoplayer2 is deprecated. Please migrate to androidx.media3 (which
 *     contains the same ExoPlayer code). See <a
 *     href=""https://developer.android.com/guide/topics/media/media3/getting-started/migration-guide"">the
 *     migration guide</a> for more details, including a script to help with the migration.
 */
@Deprecated
public final class MssimCalculator {
  // Referred to as 'L' in the SSIM paper, this constant defines the maximum pixel values. The
  // range of pixel values is 0 to 255 (8 bit unsigned range).
  private static final int PIXEL_MAX_VALUE = 255;

  // K1 and K2, as defined in the SSIM paper.
  private static final double K1 = 0.01;
  private static final double K2 = 0.03;

  // C1 and C2 stabilize the SSIM value when either (referenceMean^2 +  [MASK] ^2) or
  // (referenceVariance + distortedVariance) is close to 0. See the SSIM formula in
  // `getWindowSsim` for how these values impact each other in the calculation.
  private static final double C1 = pow(PIXEL_MAX_VALUE * K1, 2);
  private static final double C2 = pow(PIXEL_MAX_VALUE * K2, 2);

  private static final int WINDOW_SIZE = 8;

  private MssimCalculator() {}

  /**
   * Calculates the Mean Structural Similarity (MSSIM) between two images with window skipping.
   *
   * @see #calculate(byte[], byte[], int, int, boolean)
   */
  public static double calculate(
      byte[] referenceBuffer, byte[] distortedBuffer, int width, int height) {
    return calculate(
        referenceBuffer, distortedBuffer, width, height, /* enableWindowSkipping= */ true);
  }

  /**
   * Calculates the Mean Structural Similarity (MSSIM) between two images.
   *
   * <p>The images are split into a grid of windows. For each window, the structural similarity
   * (SSIM) is calculated. The MSSIM returned from this method is the mean of these SSIM values. If
   * window skipping is enabled, only every other row and column are considered, thereby only one in
   * four windows are evaluated.
   *
   * @param referenceBuffer The luma channel (Y) buffer of the reference image.
   * @param distortedBuffer The luma channel (Y) buffer of the distorted image.
   * @param width The image width in pixels.
   * @param height The image height in pixels.
   * @param enableWindowSkipping Whether to skip every other row and column when evaluating windows
   *     for SSIM calculation.
   * @return The MSSIM score between the input images.
   */
  public static double calculate(
      byte[] referenceBuffer,
      byte[] distortedBuffer,
      int width,
      int height,
      boolean enableWindowSkipping) {
    double totalSsim = 0;
    int windowsCount = 0;

    int dimensionIncrement = WINDOW_SIZE * (enableWindowSkipping ? 2 : 1);

    for (int currentWindowY = 0; currentWindowY < height; currentWindowY += dimensionIncrement) {
      int windowHeight = computeWindowSize(currentWindowY, height);
      for (int currentWindowX = 0; currentWindowX < width; currentWindowX += dimensionIncrement) {
        windowsCount++;
        int windowWidth = computeWindowSize(currentWindowX, width);
        int bufferIndexOffset =
            get1dIndex(currentWindowX, currentWindowY, /* stride= */ width, /* offset= */ 0);
        double referenceMean =
            getMean(
                referenceBuffer, bufferIndexOffset, /* stride= */ width, windowWidth, windowHeight);
        double  [MASK]  =
            getMean(
                distortedBuffer, bufferIndexOffset, /* stride= */ width, windowWidth, windowHeight);

        double[] variances =
            getVariancesAndCovariance(
                referenceBuffer,
                distortedBuffer,
                referenceMean,
                 [MASK] ,
                bufferIndexOffset,
                /* stride= */ width,
                windowWidth,
                windowHeight);
        double referenceVariance = variances[0];
        double distortedVariance = variances[1];
        double referenceDistortedCovariance = variances[2];

        totalSsim +=
            getWindowSsim(
                referenceMean,
                 [MASK] ,
                referenceVariance,
                distortedVariance,
                referenceDistortedCovariance);
      }
    }

    if (windowsCount == 0) {
      return 1.0d;
    }

    return totalSsim / windowsCount;
  }

  /**
   * Returns the window size at the provided start coordinate, uses {@link #WINDOW_SIZE} if there is
   * enough space, otherwise the number of pixels between {@code start} and {@code dimension}.
   */
  private static int computeWindowSize(int start, int dimension) {
    if (start + WINDOW_SIZE <= dimension) {
      return WINDOW_SIZE;
    }
    return dimension - start;
  }

  /** Returns the SSIM of a window. */
  private static double getWindowSsim(
      double referenceMean,
      double  [MASK] ,
      double referenceVariance,
      double distortedVariance,
      double referenceDistortedCovariance) {

    // Uses equation 13 on page 6 from the linked paper.
    double numerator =
        (((2 * referenceMean *  [MASK] ) + C1) * ((2 * referenceDistortedCovariance) + C2));
    double denominator =
        ((referenceMean * referenceMean) + ( [MASK]  *  [MASK] ) + C1)
            * (referenceVariance + distortedVariance + C2);
    return numerator / denominator;
  }

  /** Returns the mean of the pixels in the window. */
  private static double getMean(
      byte[] pixelBuffer, int bufferIndexOffset, int stride, int windowWidth, int windowHeight) {
    double total = 0;
    for (int y = 0; y < windowHeight; y++) {
      for (int x = 0; x < windowWidth; x++) {
        total += pixelBuffer[get1dIndex(x, y, stride, bufferIndexOffset)] & 0xFF;
      }
    }
    return total / (windowWidth * windowHeight);
  }

  /** Calculates the variances and covariance of the pixels in the window for both buffers. */
  private static double[] getVariancesAndCovariance(
      byte[] referenceBuffer,
      byte[] distortedBuffer,
      double referenceMean,
      double  [MASK] ,
      int bufferIndexOffset,
      int stride,
      int windowWidth,
      int windowHeight) {
    double referenceVariance = 0;
    double distortedVariance = 0;
    double referenceDistortedCovariance = 0;
    for (int y = 0; y < windowHeight; y++) {
      for (int x = 0; x < windowWidth; x++) {
        int index = get1dIndex(x, y, stride, bufferIndexOffset);
        double referencePixelDeviation = (referenceBuffer[index] & 0xFF) - referenceMean;
        double distortedPixelDeviation = (distortedBuffer[index] & 0xFF) -  [MASK] ;
        referenceVariance += referencePixelDeviation * referencePixelDeviation;
        distortedVariance += distortedPixelDeviation * distortedPixelDeviation;
        referenceDistortedCovariance += referencePixelDeviation * distortedPixelDeviation;
      }
    }

    int normalizationFactor = windowWidth * windowHeight - 1;

    return new double[] {
      referenceVariance / normalizationFactor,
      distortedVariance / normalizationFactor,
      referenceDistortedCovariance / normalizationFactor
    };
  }

  /**
   * Translates a 2D coordinate into an 1D index, based on the stride of the 2D space.
   *
   * @param x The width component of coordinate.
   * @param y The height component of coordinate.
   * @param stride The width of the 2D space.
   * @param offset An offset to apply.
   * @return The 1D index.
   */
  private static int get1dIndex(int x, int y, int stride, int offset) {
    return x + (y * stride) + offset;
  }
}
","distortedMean
",distortedMe,distortedMean,distortedPixel,distortedMean,
"

package com.google.refine.exporters;

import com.google.refine.ProjectManager;
import com.google.refine.ProjectManagerStub;
import com.google.refine.ProjectMetadata;
import com.google.refine.RefineTest;
import com.google.refine.browsing.Engine;
import com.google.refine.browsing.Engine.Mode;
import com.google.refine.model.Cell;
import com.google.refine.model.Column;
import com.google.refine.model.ModelException;
import com.google.refine.model.Project;
import com.google.refine.model.Row;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.odftoolkit.odfdom.doc.OdfDocument;
import org.odftoolkit.odfdom.doc.table.OdfTable;
import org.slf4j.LoggerFactory;
import org.testng.Assert;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.Test;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Properties;

import static org.mockito.Mockito.mock;

public class OdsExporterTests extends RefineTest {

    private static final String TEST_PROJECT_NAME = ""ods exporter test project"";

    @Override
    @BeforeTest
    public void init() {
        logger = LoggerFactory.getLogger(this.getClass());
    }

    // dependencies
    ByteArrayOutputStream stream;
    ProjectMetadata projectMetadata;
    Project project;
    Engine engine;
    Properties options;

    // System Under Test
    StreamExporter SUT;

    @BeforeMethod
    public void SetUp() {
        SUT = new OdsExporter();
        stream = new ByteArrayOutputStream();
        ProjectManager.singleton = new ProjectManagerStub();
        projectMetadata = new ProjectMetadata();
        project = new Project();
        projectMetadata.setName(TEST_PROJECT_NAME);
        ProjectManager.singleton.registerProject(project, projectMetadata);
        engine = new Engine(project);
        options = mock(Properties.class);
    }

    @AfterMethod
    public void TearDown() {
        SUT = null;
        stream = null;
        ProjectManager.singleton.deleteProject(project.id);
        project = null;
        engine = null;
        options = null;
    }

    @Test
    public void getContentType() {
        Assert.assertEquals(SUT.getContentType(), ""application/vnd.oasis.opendocument.spreadsheet"");
    }

    @Test
    public void exportSimpleOds() throws IOException {
        CreateGrid(2, 2);

        try {
            SUT.export(project, options, engine, stream);
        } catch (IOException e) {
            Assert.fail();
        }

        try {
            OdfDocument odfDoc = OdfDocument.loadDocument(new ByteArrayInputStream(stream.toByteArray()));
            List<OdfTable> tables = odfDoc.getTableList();
            Assert.assertEquals(tables.size(), 1); // we deleted the first sheet generated by default
            OdfTable odfTab = tables.get(0);
            Assert.assertEquals(odfTab.getTableName(), ""ods exporter test project"");
            Assert.assertEquals(odfTab.getRowCount(), 3); // first row is header
            Assert.assertEquals(odfTab.getRowByIndex(1).getCellByIndex(0).getStringValue(), ""row0cell0"");
        } catch (Exception e) {
            Assert.fail();
        }
    }

    protected void CreateColumns(int  [MASK] ) {
        for (int i = 0; i <  [MASK] ; i++) {
            try {
                project.columnModel.addColumn(i, new Column(i, ""column"" + i), true);
            } catch (ModelException e1) {
                Assert.fail(""Could not create column"");
            }
        }
    }

    protected void CreateGrid(int noOfRows, int  [MASK] ) {
        CreateColumns( [MASK] );

        for (int i = 0; i < noOfRows; i++) {
            Row row = new Row( [MASK] );
            for (int j = 0; j <  [MASK] ; j++) {
                row.cells.add(new Cell(""row"" + i + ""cell"" + j, null));
            }
            project.rows.add(row);
        }
    }

    private void createDateGrid(int noOfRows, int  [MASK] , OffsetDateTime now) {
        CreateColumns( [MASK] );

        for (int i = 0; i < noOfRows; i++) {
            Row row = new Row( [MASK] );
            for (int j = 0; j <  [MASK] ; j++) {
                row.cells.add(new Cell(now, null));
            }
            project.rows.add(row);
        }
    }
}
","noOfColumns
",rows,columnOfs,numColumns,numColumns,
"
package com.google.devtools.build.lib.rules.android;

import com.google.devtools.build.lib.actions.Artifact;
import com.google.devtools.build.lib.rules.android.AndroidDataConverter.JoinerType;
import com.google.devtools.build.lib.skyframe.serialization.autocodec.AutoCodec.VisibleForSerialization;
import com.google.devtools.build.lib.skyframe.serialization.autocodec.SerializationConstant;
import com.google.errorprone.annotations.CanIgnoreReturnValue;

/** Builds up the spawn action for $android_rclass_generator. */
public class RClassGeneratorActionBuilder {

  @SerializationConstant @VisibleForSerialization
  static final AndroidDataConverter<ValidatedAndroidResources> AAPT2_CONVERTER =
      AndroidDataConverter.<ValidatedAndroidResources>builder(JoinerType.COLON_COMMA)
          .with(RClassGeneratorActionBuilder::depsToBusyboxArg)
          .build();

  private ResourceDependencies dependencies;

  private Artifact classJarOut;

  private boolean finalFields = true;

  @CanIgnoreReturnValue
  public RClassGeneratorActionBuilder withDependencies(ResourceDependencies resourceDeps) {
    this.dependencies = resourceDeps;
    return this;
  }

  @CanIgnoreReturnValue
  public RClassGeneratorActionBuilder finalFields(boolean finalFields) {
    this.finalFields = finalFields;
    return this;
  }

  @CanIgnoreReturnValue
  public RClassGeneratorActionBuilder setClassJarOut(Artifact classJarOut) {
    this.classJarOut = classJarOut;
    return this;
  }

  public ResourceApk build(AndroidDataContext dataContext, ProcessedAndroidData data) {
    build(dataContext, data.getRTxt(), data.getManifest());

    return data.withValidatedResources(classJarOut);
  }

  private void build(
      AndroidDataContext dataContext, Artifact rTxt, ProcessedAndroidManifest manifest) {
    BusyBoxActionBuilder builder =
        BusyBoxActionBuilder.create(dataContext, ""GENERATE_BINARY_R"")
            .addInput(""--primaryRTxt"", rTxt)
            .addInput(""--primaryManifest"", manifest.getManifest())
            .maybeAddFlag(""--packageForR"", manifest.getPackage())
            .addFlag(finalFields ? ""--finalFields"" : ""--nofinalFields"");

    if (dependencies != null && !dependencies.getResourceContainers().isEmpty()) {
      builder
          .addTransitiveFlagForEach(
              ""--library"", dependencies.getResourceContainers(), AAPT2_CONVERTER)
          .addTransitiveInputValues(dependencies.getTransitiveAapt2RTxt())
          .addTransitiveInputValues(dependencies.getTransitiveManifests())
          .addTransitiveInputValues(dependencies.getTransitiveAapt2ValidationArtifacts());
    }

    builder
        .addOutput(""--classJarOutput"", classJarOut)
        .addLabelFlag(""--targetLabel"")
        .buildAndRegister(""Generating R Classes"", ""RClassGenerator"");
  }

  private static String depsToBusyboxArg(ValidatedAndroidResources  [MASK] ) {
    Artifact rTxt =  [MASK] .getAapt2RTxt();
    return (rTxt != null ? rTxt.getExecPath() : """")
        + "",""
        + ( [MASK] .getManifest() != null ?  [MASK] .getManifest().getExecPath() : """");
  }
}
","container
",valididatedAndroidResources,valididatedAndroidResources,resources,resource,
"

package com.google.devtools.build.lib.packages;

import static com.google.common.collect.ImmutableList.toImmutableList;
import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.assertThrows;

import com.google.common.collect.ImmutableList;
import com.google.devtools.build.lib.analysis.util.BuildViewTestCase;
import com.google.devtools.build.lib.cmdline.Label;
import com.google.devtools.build.lib.skyframe.ConfiguredTargetAndData;
import com.google.devtools.build.lib.vfs.ModifiedFileSet;
import com.google.devtools.build.lib.vfs.PathFragment;
import com.google.devtools.build.lib.vfs.Root;
import java.io.IOException;
import java.util.List;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/** Tests for {@code native.glob} function. */
@RunWith(JUnit4.class)
public class NativeGlobTest extends BuildViewTestCase {

  @Test
  public void glob_simple() throws Exception {
    makeFile(""test/starlark/file1.txt"");
    makeFile(""test/starlark/file2.txt"");
    makeFile(""test/starlark/file3.txt"");

    makeGlobFilegroup(""test/starlark/BUILD"", ""glob(['*'])"");

    assertAttrLabelList(
        ""//test/starlark:files"",
        ""srcs"",
        ImmutableList.of(
            ""//test/starlark:BUILD"",
            ""//test/starlark:file1.txt"",
            ""//test/starlark:file2.txt"",
            ""//test/starlark:file3.txt""));
  }

  @Test
  public void glob_not_empty() throws Exception {

    makeGlobFilegroup(""test/starlark/BUILD"", ""glob(['foo*'], allow_empty=False)"");

    AssertionError e =
        assertThrows(
            AssertionError.class,
            () -> assertAttrLabelList(""//test/starlark:files"", ""srcs"", ImmutableList.of()));
    assertThat(e).hasMessageThat().contains(""allow_empty"");
  }

  @Test
  public void glob_simple_subdirs() throws Exception {
    makeFile(""test/starlark/sub/file1.txt"");
    makeFile(""test/starlark/sub2/file2.txt"");
    makeFile(""test/starlark/sub3/file3.txt"");

    makeGlobFilegroup(""test/starlark/BUILD"", ""glob(['**'])"");

    assertAttrLabelList(
        ""//test/starlark:files"",
        ""srcs"",
        ImmutableList.of(
            ""//test/starlark:BUILD"",
            ""//test/starlark:sub/file1.txt"",
            ""//test/starlark:sub2/file2.txt"",
            ""//test/starlark:sub3/file3.txt""));
  }

  @Test
  public void glob_incremental() throws Exception {
    makeFile(""test/starlark/file1.txt"");
    makeGlobFilegroup(""test/starlark/BUILD"", ""glob(['**'])"");

    assertAttrLabelList(
        ""//test/starlark:files"",
        ""srcs"",
        ImmutableList.of(""//test/starlark:BUILD"", ""//test/starlark:file1.txt""));

    scratch.file(""test/starlark/file2.txt"");
    scratch.file(""test/starlark/sub/subfile3.txt"");

    // Poke SkyFrame to tell it what changed.
    invalidateSkyFrameFiles(
        ""test/starlark"", ""test/starlark/file2.txt"", ""test/starlark/sub/subfile3.txt"");

    assertAttrLabelList(
        ""//test/starlark:files"",
        ""srcs"",
        ImmutableList.of(
            ""//test/starlark:BUILD"",
            ""//test/starlark:file1.txt"",
            ""//test/starlark:file2.txt"",
            ""//test/starlark:sub/subfile3.txt""));
  }

  /**
   * Constructs a BUILD file containing a single rule with uses glob() to list files look for a rule
   * called :files in it.
   */
  private void makeGlobFilegroup(String buildPath, String glob) throws IOException {
    scratch.file(buildPath, ""filegroup("", ""   name = 'files',"", ""   srcs = "" + glob, "")"");
  }

  private void assertAttrLabelList(String target, String  [MASK] , List<String> expectedLabels)
      throws Exception {
    ConfiguredTargetAndData cfgTarget = getConfiguredTargetAndData(target);
    assertThat(cfgTarget).isNotNull();

    ImmutableList<Label> labels =
        expectedLabels.stream().map(this::makeLabel).collect(toImmutableList());

    ConfiguredAttributeMapper configuredAttributeMapper =
        getMapperFromConfiguredTargetAndTarget(cfgTarget);
    assertThat(configuredAttributeMapper.get( [MASK] , BuildType.LABEL_LIST))
        .containsExactlyElementsIn(labels);
  }

  private Label makeLabel(String label) {
    try {
      return Label.parseCanonical(label);
    } catch (Exception e) {
      // Always fails the test.
      assertThat(e).isNull();
      return null;
    }
  }

  private void invalidateSkyFrameFiles(String... files) throws Exception {
    ModifiedFileSet.Builder builder = ModifiedFileSet.builder();

    for (String f : files) {
      builder.modify(PathFragment.create(f));
    }

    getSkyframeExecutor()
        .invalidateFilesUnderPathForTesting(
            reporter, builder.build(), Root.fromPath(rootDirectory));
  }

  private void makeFile(String fileName) throws IOException {
    scratch.file(fileName, ""Content: "" + fileName);
  }
}
","attrName
",attKey,attGroupKey,attributes,srcs,
"

package com.google.common.collect;

import static com.google.common.collect.TableCollectionTest.DIVIDE_BY_2;

import com.google.common.annotations.GwtCompatible;
import com.google.common.collect.TableCollectionTest.ColumnTests;
import java.util.Map;

@GwtCompatible
public class TablesTransformValuesColumnTest extends ColumnTests {
  public TablesTransformValuesColumnTest() {
    super(false, false, true, true, false);
  }

  @Override
  Table<String, Character, Integer> makeTable() {
    Table<String, Character, Integer>  [MASK]  = HashBasedTable.create();
    return Tables.transformValues( [MASK] , DIVIDE_BY_2);
  }

  @Override
  protected Map<String, Integer> makePopulatedMap() {
    Table<String, Character, Integer>  [MASK]  = HashBasedTable.create();
     [MASK] .put(""one"", 'a', 1);
     [MASK] .put(""two"", 'a', 2);
     [MASK] .put(""three"", 'a', 3);
     [MASK] .put(""four"", 'b', 4);
    return Tables.transformValues( [MASK] , DIVIDE_BY_2).column('a');
  }
}
","table
",tTable,table,table,table,
"
package com.google.devtools.build.skyframe;

import static com.google.common.truth.Truth.assertThat;

import com.google.common.base.Throwables;
import com.google.common.collect.ImmutableList;
import com.google.common.util.concurrent.Uninterruptibles;
import com.google.devtools.build.lib.testutil.TestUtils;
import com.google.devtools.build.lib.util.Pair;

import java.util.List;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Safely await {@link CountDownLatch}es in tests, storing any exceptions that happen. Callers
 * should call {@link #assertNoErrors} at the end of each test method, either manually or using an
 * {@code @After} hook.
 */
public class TrackingAwaiter {
  public static final TrackingAwaiter INSTANCE = new TrackingAwaiter();

  private TrackingAwaiter() {}

  private final ConcurrentLinkedQueue<Pair<String, Throwable>> exceptionsThrown =
      new ConcurrentLinkedQueue<>();

  /**
   * This method fixes a race condition with simply calling {@link CountDownLatch#await}. If this
   * thread is interrupted before {@code latch.await} is called, then {@code latch.await} will throw
   * an {@link InterruptedException} without checking the value of the latch at all. This leads to a
   * race condition in which this thread will throw an InterruptedException if it is slow calling
   * {@code latch.await}, but it will succeed normally otherwise.
   *
   * <p>To avoid this, we wait for the latch uninterruptibly. In the end, if the latch has in fact
   * been released, we do nothing, although the interrupted bit is set, so that the caller can
   * decide to throw an InterruptedException if it wants to. If the latch was not released, then
   * this was not a race condition, but an honest-to-goodness interrupt, and we propagate the
   * exception onward.
   */
  private static void waitAndMaybeThrowInterrupt(CountDownLatch latch, String errorMessage)
      throws InterruptedException {
    if (Uninterruptibles.awaitUninterruptibly(latch, TestUtils.WAIT_TIMEOUT_SECONDS,
        TimeUnit.SECONDS)) {
      // Latch was released. We can ignore the interrupt state.
      return;
    }
    if (!Thread.currentThread().isInterrupted()) {
      // Nobody interrupted us, but latch wasn't released. Failure.
      throw new AssertionError(errorMessage);
    } else {
      // We were interrupted before the latch was released. Propagate this interruption.
      throw new InterruptedException();
    }
  }

  /** Threadpools can swallow exceptions. Make sure they don't get lost. */
  public void awaitLatchAndTrackExceptions(CountDownLatch latch, String errorMessage) {
    try {
      waitAndMaybeThrowInterrupt(latch, errorMessage);
    } catch (Throwable e) {
      // We would expect e to be InterruptedException or AssertionError, but we leave it open so
      // that any throwable gets recorded.
      exceptionsThrown.add(Pair.of(errorMessage, e));
      // Caller will assert exceptionsThrown is empty at end of test and fail, even if this is
      // swallowed.
      Throwables.propagate(e);
    }
  }

  /** Allow arbitrary errors to be recorded here for later throwing. */
  public void injectExceptionAndMessage(Throwable throwable, String  [MASK] ) {
    exceptionsThrown.add(Pair.of( [MASK] , throwable));
  }

  public void assertNoErrors() {
    List<Pair<String, Throwable>> thisEvalExceptionsThrown = ImmutableList.copyOf(exceptionsThrown);
    exceptionsThrown.clear();
    assertThat(thisEvalExceptionsThrown).isEmpty();
  }
}
","message
",errorMessage,errorMessage,errorMessage,errorMessage,
"

package com.google.zxing.common;

import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.charset.UnsupportedCharsetException;
import java.util.ArrayList;
import java.util.List;

/**
 * Set of CharsetEncoders for a given input string
 *
 * Invariants:
 * - The list contains only encoders from CharacterSetECI (list is shorter then the list of encoders available on
 *   the platform for which ECI values are defined).
 * - The list contains encoders at least one encoder for every character in the input.
 * - The first encoder in the list is always the ISO-8859-1 encoder even of no character in the input can be encoded
 *       by it.
 * - If the input contains a character that is not in ISO-8859-1 then the last two entries in the list will be the
 *   UTF-8 encoder and the UTF-16BE encoder.
 *
 * @author Alex Geller
 */
public final class ECIEncoderSet {

  // List of encoders that potentially encode characters not in ISO-8859-1 in one byte.
  private static final List<CharsetEncoder> ENCODERS = new ArrayList<>();
  static {
    String[] names = { ""IBM437"",
                       ""ISO-8859-2"",
                       ""ISO-8859-3"",
                       ""ISO-8859-4"",
                       ""ISO-8859-5"",
                       ""ISO-8859-6"",
                       ""ISO-8859-7"",
                       ""ISO-8859-8"",
                       ""ISO-8859-9"",
                       ""ISO-8859-10"",
                       ""ISO-8859-11"",
                       ""ISO-8859-13"",
                       ""ISO-8859-14"",
                       ""ISO-8859-15"",
                       ""ISO-8859-16"",
                       ""windows-1250"",
                       ""windows-1251"",
                       ""windows-1252"",
                       ""windows-1256"",
                       ""Shift_JIS"" };
    for (String name : names) {
      if (CharacterSetECI.getCharacterSetECIByName(name) != null) {
        try {
          ENCODERS.add(Charset.forName(name).newEncoder());
        } catch (UnsupportedCharsetException e) {
          // continue
        }
      }
    }
  }

  private final CharsetEncoder[] encoders;
  private final int priorityEncoderIndex;

  /**
   * Constructs an encoder set
   *
   * @param stringToEncode the string that needs to be encoded
   * @param priorityCharset The preferred {@link Charset} or null.
   * @param fnc1 fnc1 denotes the character in the input that represents the FNC1 character or -1 for a non-GS1 bar
   * code. When specified, it is considered an error to pass it as argument to the methods canEncode() or encode().
   */
  public ECIEncoderSet(String stringToEncode, Charset priorityCharset, int fnc1) {
    List<CharsetEncoder>  [MASK]  = new ArrayList<>();

    //we always need the ISO-8859-1 encoder. It is the default encoding
     [MASK] .add(StandardCharsets.ISO_8859_1.newEncoder());
    boolean needUnicodeEncoder = priorityCharset != null && priorityCharset.name().startsWith(""UTF"");

    //Walk over the input string and see if all characters can be encoded with the list of encoders 
    for (int i = 0; i < stringToEncode.length(); i++) {
      boolean canEncode = false;
      for (CharsetEncoder encoder :  [MASK] ) {
        char c = stringToEncode.charAt(i);
        if (c == fnc1 || encoder.canEncode(c)) {
          canEncode = true;
          break;
        }
      }

      if (!canEncode) {
        //for the character at position i we don't yet have an encoder in the list
        for (CharsetEncoder encoder : ENCODERS) {
          if (encoder.canEncode(stringToEncode.charAt(i))) {
            //Good, we found an encoder that can encode the character. We add him to the list and continue scanning
            //the input
             [MASK] .add(encoder);
            canEncode = true;
            break;
          }
        }
      }

      if (!canEncode) {
        //The character is not encodeable by any of the single byte encoders so we remember that we will need a
        //Unicode encoder.
        needUnicodeEncoder = true;
      }
    }
  
    if ( [MASK] .size() == 1 && !needUnicodeEncoder) {
      //the entire input can be encoded by the ISO-8859-1 encoder
      encoders = new CharsetEncoder[] {  [MASK] .get(0) };
    } else {
      // we need more than one single byte encoder or we need a Unicode encoder.
      // In this case we append a UTF-8 and UTF-16 encoder to the list
      encoders = new CharsetEncoder[ [MASK] .size() + 2];
      int index = 0;
      for (CharsetEncoder encoder :  [MASK] ) {
        encoders[index++] = encoder;
      }

      encoders[index] = StandardCharsets.UTF_8.newEncoder();
      encoders[index + 1] = StandardCharsets.UTF_16BE.newEncoder();
    }
  
    //Compute priorityEncoderIndex by looking up priorityCharset in encoders
    int priorityEncoderIndexValue = -1;
    if (priorityCharset != null) {
      for (int i = 0; i < encoders.length; i++) {
        if (encoders[i] != null && priorityCharset.name().equals(encoders[i].charset().name())) {
          priorityEncoderIndexValue = i;
          break;
        }
      }
    }
    priorityEncoderIndex = priorityEncoderIndexValue;
    //invariants
    assert encoders[0].charset().equals(StandardCharsets.ISO_8859_1);
  }

  public int length() {
    return encoders.length;
  }

  public String getCharsetName(int index) {
    assert index < length();
    return encoders[index].charset().name();
  }

  public Charset getCharset(int index) {
    assert index < length();
    return encoders[index].charset();
  }

  public int getECIValue(int encoderIndex) {
    return CharacterSetECI.getCharacterSetECI(encoders[encoderIndex].charset()).getValue();
  }

  /*
   *  returns -1 if no priority charset was defined
   */
  public int getPriorityEncoderIndex() {
    return priorityEncoderIndex;
  }

  public boolean canEncode(char c, int encoderIndex) {
    assert encoderIndex < length();
    CharsetEncoder encoder = encoders[encoderIndex];
    return encoder.canEncode("""" + c);
  }

  public byte[] encode(char c, int encoderIndex) {
    assert encoderIndex < length();
    CharsetEncoder encoder = encoders[encoderIndex];
    assert encoder.canEncode("""" + c);
    return ("""" + c).getBytes(encoder.charset());
  }

  public byte[] encode(String s, int encoderIndex) {
    assert encoderIndex < length();
    CharsetEncoder encoder = encoders[encoderIndex];
    return s.getBytes(encoder.charset());
  }
}
","neededEncoders
",encers,charsetEncoderList,encoderList,encoders,
"

package com.badlogic.gdx.tests.lwjgl;

import java.awt.BorderLayout;
import java.awt.HeadlessException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import javax.swing.DefaultListSelectionModel;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;

import com.badlogic.gdx.Preferences;
import com.badlogic.gdx.backends.lwjgl.LwjglApplication;
import com.badlogic.gdx.backends.lwjgl.LwjglApplicationConfiguration;
import com.badlogic.gdx.backends.lwjgl.LwjglFiles;
import com.badlogic.gdx.backends.lwjgl.LwjglPreferences;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.glutils.ShaderProgram;
import com.badlogic.gdx.tests.utils.CommandLineOptions;
import com.badlogic.gdx.tests.utils.GdxTest;
import com.badlogic.gdx.tests.utils.GdxTestWrapper;
import com.badlogic.gdx.tests.utils.GdxTests;
import com.badlogic.gdx.utils.SharedLibraryLoader;

public class LwjglTestStarter extends JFrame {
        static CommandLineOptions options;

        public LwjglTestStarter () throws HeadlessException {
                super(""libGDX Tests"");
                setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                setContentPane(new TestList());
                pack();
                setSize(getWidth(), 600);
                setLocationRelativeTo(null);
                setVisible(true);
        }

        /** Runs the {@link GdxTest} with the given name.
         * 
         * @param testName the name of a test class
         * @return {@code true} if the test was found and run, {@code false} otherwise */
        public static boolean runTest (String testName) {
                boolean useGL30 = options.gl30;
                GdxTest test = GdxTests.newTest(testName);
                if (test == null) {
                        return false;
                }
                LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
                config.width = 640;
                config.height = 480;
                config.title = testName;
                config.forceExit = false;
                if (useGL30) {
                        config.useGL30 = true;
                        if (!SharedLibraryLoader.isMac) {
                                config.gles30ContextMajorVersion = 4;
                                config.gles30ContextMinorVersion = 3;
                        }
                        ShaderProgram.prependVertexCode = ""#version 140\n#define varying out\n#define attribute in\n"";
                        ShaderProgram.prependFragmentCode = ""#version 140\n#define varying in\n#define texture2D texture\n#define gl_FragColor fragColor\nout vec4 fragColor;\n"";
                } else {
                        config.useGL30 = false;
                        ShaderProgram.prependVertexCode = """";
                        ShaderProgram.prependFragmentCode = """";
                }
                new LwjglApplication(new GdxTestWrapper(test, options.logGLErrors), config);
                return true;
        }

        class TestList extends JPanel {
                public TestList () {
                        setLayout(new BorderLayout());

                        final JButton  [MASK]  = new JButton(""Run Test"");

                        final JList list = new JList(options.getCompatibleTests());
                        JScrollPane pane = new JScrollPane(list);

                        DefaultListSelectionModel m = new DefaultListSelectionModel();
                        m.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                        m.setLeadAnchorNotificationEnabled(false);
                        list.setSelectionModel(m);

                        list.addMouseListener(new MouseAdapter() {
                                public void mouseClicked (MouseEvent event) {
                                        if (event.getClickCount() == 2)  [MASK] .doClick();
                                }
                        });

                        list.addKeyListener(new KeyAdapter() {
                                public void keyPressed (KeyEvent e) {
                                        if (e.getKeyCode() == KeyEvent.VK_ENTER)  [MASK] .doClick();
                                }
                        });

                        final Preferences prefs = new LwjglPreferences(
                                new FileHandle(new LwjglFiles().getExternalStoragePath() + "".prefs/lwjgl-tests""));
                        list.setSelectedValue(prefs.getString(""last"", null), true);

                         [MASK] .addActionListener(new ActionListener() {
                                @Override
                                public void actionPerformed (ActionEvent e) {
                                        String testName = (String)list.getSelectedValue();
                                        prefs.putString(""last"", testName);
                                        prefs.flush();
                                        dispose();
                                        runTest(testName);
                                }
                        });

                        add(pane, BorderLayout.CENTER);
                        add( [MASK] , BorderLayout.SOUTH);

                        // GdxTest test = GdxTests.newTest(""BitmapFontFlipTest"");
                        // new LwjglApplication(test, ""Test"", 480, 320, test.needsGL20());
                }
        }

        /** Runs a libGDX test.
         * 
         * If no arguments are provided on the command line, shows a list of tests to choose from. If an argument is present, the test
         * with that name will immediately be run. Additional options can be passed, see {@link CommandLineOptions}
         * 
         * @param argv command line arguments */
        public static void main (String[] argv) throws Exception {
                options = new CommandLineOptions(argv);
                if (options.startupTestName != null) {
                        if (runTest(options.startupTestName)) {
                                return;
                                // Otherwise, fall back to showing the list
                        }
                }
                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
                new LwjglTestStarter();
        }
}
","button
",testButton,runTestButton,runTestButton,runTestButton,
"package io.netty.channel.nio;

import io.netty.channel.AbstractEventLoopTest;
import io.netty.channel.Channel;
import io.netty.channel.DefaultSelectStrategyFactory;
import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.EventLoopTaskQueueFactory;
import io.netty.channel.SelectStrategy;
import io.netty.channel.SelectStrategyFactory;
import io.netty.channel.SingleThreadEventLoop;
import io.netty.channel.socket.ServerSocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.util.IntSupplier;
import io.netty.util.concurrent.DefaultEventExecutorChooserFactory;
import io.netty.util.concurrent.DefaultThreadFactory;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.RejectedExecutionHandlers;
import io.netty.util.concurrent.ThreadPerTaskExecutor;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Timeout;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.nio.channels.spi.SelectorProvider;
import java.util.Queue;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.instanceOf;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotSame;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class NioEventLoopTest extends AbstractEventLoopTest {

    @Override
    protected EventLoopGroup newEventLoopGroup() {
        return new NioEventLoopGroup();
    }

    @Override
    protected Class<? extends ServerSocketChannel> newChannel() {
        return NioServerSocketChannel.class;
    }

    @Test
    public void testRebuildSelector() {
        EventLoopGroup  [MASK]  = new NioEventLoopGroup(1);
        final NioEventLoop loop = (NioEventLoop)  [MASK] .next();
        try {
            Channel channel = new NioServerSocketChannel();
            loop.register(channel).syncUninterruptibly();

            Selector selector = loop.unwrappedSelector();
            assertSame(selector, ((NioEventLoop) channel.eventLoop()).unwrappedSelector());
            assertTrue(selector.isOpen());

            // Submit to the EventLoop so we are sure its really executed in a non-async manner.
            loop.submit(new Runnable() {
                @Override
                public void run() {
                    loop.rebuildSelector();
                }
            }).syncUninterruptibly();

            Selector newSelector = ((NioEventLoop) channel.eventLoop()).unwrappedSelector();
            assertTrue(newSelector.isOpen());
            assertNotSame(selector, newSelector);
            assertFalse(selector.isOpen());

            channel.close().syncUninterruptibly();
        } finally {
             [MASK] .shutdownGracefully();
        }
    }

    @Test
    public void testScheduleBigDelayNotOverflow() {
        EventLoopGroup  [MASK]  = new NioEventLoopGroup(1);

        final EventLoop el =  [MASK] .next();
        Future<?> future = el.schedule(new Runnable() {
            @Override
            public void run() {
                // NOOP
            }
        }, Long.MAX_VALUE, TimeUnit.MILLISECONDS);

        assertFalse(future.awaitUninterruptibly(1000));
        assertTrue(future.cancel(true));
         [MASK] .shutdownGracefully();
    }

    @Test
    public void testInterruptEventLoopThread() throws Exception {
        EventLoopGroup  [MASK]  = new NioEventLoopGroup(1);
        final NioEventLoop loop = (NioEventLoop)  [MASK] .next();
        try {
            Selector selector = loop.unwrappedSelector();
            assertTrue(selector.isOpen());

            loop.submit(new Runnable() {
                @Override
                public void run() {
                    // Interrupt the thread which should not end-up in a busy spin and
                    // so the selector should not have been rebuild.
                    Thread.currentThread().interrupt();
                }
            }).syncUninterruptibly();

            assertTrue(selector.isOpen());

            final CountDownLatch latch = new CountDownLatch(2);
            loop.submit(new Runnable() {
                @Override
                public void run() {
                    latch.countDown();
                }
            }).syncUninterruptibly();

            loop.schedule(new Runnable() {
                @Override
                public void run() {
                    latch.countDown();
                }
            }, 2, TimeUnit.SECONDS).syncUninterruptibly();

            latch.await();

            assertSame(selector, loop.unwrappedSelector());
            assertTrue(selector.isOpen());
        } finally {
             [MASK] .shutdownGracefully();
        }
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testSelectableChannel() throws Exception {
        NioEventLoopGroup  [MASK]  = new NioEventLoopGroup(1);
        NioEventLoop loop = (NioEventLoop)  [MASK] .next();

        try {
            Channel channel = new NioServerSocketChannel();
            loop.register(channel).syncUninterruptibly();
            channel.bind(new InetSocketAddress(0)).syncUninterruptibly();

            SocketChannel selectableChannel = SocketChannel.open();
            selectableChannel.configureBlocking(false);
            selectableChannel.connect(channel.localAddress());

            final CountDownLatch latch = new CountDownLatch(1);

            loop.register(selectableChannel, SelectionKey.OP_CONNECT, new NioTask<SocketChannel>() {
                @Override
                public void channelReady(SocketChannel ch, SelectionKey key) {
                    latch.countDown();
                }

                @Override
                public void channelUnregistered(SocketChannel ch, Throwable cause) {
                }
            });

            latch.await();

            selectableChannel.close();
            channel.close().syncUninterruptibly();
        } finally {
             [MASK] .shutdownGracefully();
        }
    }

    @SuppressWarnings(""deprecation"")
    @Test
    public void testTaskRemovalOnShutdownThrowsNoUnsupportedOperationException() throws Exception {
        final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
        final Runnable task = new Runnable() {
            @Override
            public void run() {
                // NOOP
            }
        };
        // Just run often enough to trigger it normally.
        for (int i = 0; i < 1000; i++) {
            NioEventLoopGroup  [MASK]  = new NioEventLoopGroup(1);
            final NioEventLoop loop = (NioEventLoop)  [MASK] .next();

            Thread t = new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        for (;;) {
                            loop.execute(task);
                        }
                    } catch (Throwable cause) {
                        error.set(cause);
                    }
                }
            });
            t.start();
             [MASK] .shutdownNow();
            t.join();
             [MASK] .terminationFuture().syncUninterruptibly();
            assertThat(error.get(), instanceOf(RejectedExecutionException.class));
            error.set(null);
        }
    }

    @Test
    public void testRebuildSelectorOnIOException() {
        SelectStrategyFactory selectStrategyFactory = new SelectStrategyFactory() {
            @Override
            public SelectStrategy newSelectStrategy() {
                return new SelectStrategy() {

                    private boolean thrown;

                    @Override
                    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception {
                        if (!thrown) {
                            thrown = true;
                            throw new IOException();
                        }
                        return -1;
                    }
                };
            }
        };

        EventLoopGroup  [MASK]  = new NioEventLoopGroup(1, new DefaultThreadFactory(""ioPool""),
                                                     SelectorProvider.provider(), selectStrategyFactory);
        final NioEventLoop loop = (NioEventLoop)  [MASK] .next();
        try {
            Channel channel = new NioServerSocketChannel();
            Selector selector = loop.unwrappedSelector();

            loop.register(channel).syncUninterruptibly();

            Selector newSelector = ((NioEventLoop) channel.eventLoop()).unwrappedSelector();
            assertTrue(newSelector.isOpen());
            assertNotSame(selector, newSelector);
            assertFalse(selector.isOpen());

            channel.close().syncUninterruptibly();
        } finally {
             [MASK] .shutdownGracefully();
        }
    }

    @Test
    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testChannelsRegistered() throws Exception {
        NioEventLoopGroup  [MASK]  = new NioEventLoopGroup(1);
        final NioEventLoop loop = (NioEventLoop)  [MASK] .next();

        try {
            final Channel ch1 = new NioServerSocketChannel();
            final Channel ch2 = new NioServerSocketChannel();

            assertEquals(0, registeredChannels(loop));

            assertTrue(loop.register(ch1).syncUninterruptibly().isSuccess());
            assertTrue(loop.register(ch2).syncUninterruptibly().isSuccess());
            assertEquals(2, registeredChannels(loop));

            assertTrue(ch1.deregister().syncUninterruptibly().isSuccess());

            int registered;
            // As SelectionKeys are removed in a lazy fashion in the JDK implementation we may need to query a few
            // times before we see the right number of registered chanels.
            while ((registered = registeredChannels(loop)) == 2) {
                Thread.sleep(50);
            }
            assertEquals(1, registered);
        } finally {
             [MASK] .shutdownGracefully();
        }
    }

    // Only reliable if run from event loop
    private static int registeredChannels(final SingleThreadEventLoop loop) throws Exception {
        return loop.submit(new Callable<Integer>() {
            @Override
            public Integer call() {
                return loop.registeredChannels();
            }
        }).get(1, TimeUnit.SECONDS);
    }

    @Test
    public void testCustomQueue()  {
        final AtomicBoolean called = new AtomicBoolean();
        NioEventLoopGroup  [MASK]  = new NioEventLoopGroup(1,
                new ThreadPerTaskExecutor(new DefaultThreadFactory(NioEventLoopGroup.class)),
                DefaultEventExecutorChooserFactory.INSTANCE, SelectorProvider.provider(),
                DefaultSelectStrategyFactory.INSTANCE, RejectedExecutionHandlers.reject(),
                new EventLoopTaskQueueFactory() {
                    @Override
                    public Queue<Runnable> newTaskQueue(int maxCapacity) {
                        called.set(true);
                        return new LinkedBlockingQueue<Runnable>(maxCapacity);
                    }
        });

        final NioEventLoop loop = (NioEventLoop)  [MASK] .next();

        try {
            loop.submit(new Runnable() {
                @Override
                public void run() {
                    // NOOP.
                }
            }).syncUninterruptibly();
            assertTrue(called.get());
        } finally {
             [MASK] .shutdownGracefully();
        }
    }

}
","group
",eventGroup,eventLoopGroup,eventLoopGroup,group,
"
package io.netty.channel.kqueue;

import io.netty.channel.DefaultFileRegion;
import io.netty.channel.socket.InternetProtocolFamily;
import io.netty.channel.unix.IovArray;
import io.netty.channel.unix.PeerCredentials;
import io.netty.channel.unix.Socket;

import java.io.IOException;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.InetSocketAddress;

import static io.netty.channel.kqueue.AcceptFilter.PLATFORM_UNSUPPORTED;
import static io.netty.channel.kqueue.Native.CONNECT_TCP_FASTOPEN;
import static io.netty.channel.unix.Errors.ERRNO_EINPROGRESS_NEGATIVE;
import static io.netty.channel.unix.Errors.ioResult;
import static io.netty.channel.unix.NativeInetAddress.ipv4MappedIpv6Address;
import static io.netty.util.internal.ObjectUtil.checkNotNull;

/**
 * A socket which provides access BSD native methods.
 */
final class BsdSocket extends Socket {

    // These limits are just based on observations. I couldn't find anything in header files which formally
    // define these limits.
    private static final int APPLE_SND_LOW_AT_MAX = 1 << 17;
    private static final int FREEBSD_SND_LOW_AT_MAX = 1 << 15;
    static final int BSD_SND_LOW_AT_MAX = Math.min(APPLE_SND_LOW_AT_MAX, FREEBSD_SND_LOW_AT_MAX);
    /**
     * The `endpoints` structure passed to `connectx(2)` has an optional ""source interface"" field,
     * which is the index of the network interface to use.
     * According to `if_nametoindex(3)`, the value 0 is used when no interface is specified.
     */
    private static final int UNSPECIFIED_SOURCE_INTERFACE = 0;

    BsdSocket(int fd) {
        super(fd);
    }

    void setAcceptFilter(AcceptFilter acceptFilter) throws IOException {
        setAcceptFilter(intValue(), acceptFilter.filterName(), acceptFilter.filterArgs());
    }

    void setTcpNoPush(boolean tcpNoPush) throws IOException {
        setTcpNoPush(intValue(), tcpNoPush ? 1 : 0);
    }

    void setSndLowAt(int lowAt) throws IOException {
        setSndLowAt(intValue(), lowAt);
    }

    public void setTcpFastOpen(boolean enableTcpFastOpen) throws IOException {
        setTcpFastOpen(intValue(), enableTcpFastOpen ? 1 : 0);
    }

    boolean isTcpNoPush() throws IOException {
        return getTcpNoPush(intValue()) != 0;
    }

    int getSndLowAt() throws IOException {
        return getSndLowAt(intValue());
    }

    AcceptFilter getAcceptFilter() throws IOException {
        String[] result = getAcceptFilter(intValue());
        return result == null ? PLATFORM_UNSUPPORTED : new AcceptFilter(result[0], result[1]);
    }

    public boolean isTcpFastOpen() throws IOException {
        return isTcpFastOpen(intValue()) != 0;
    }

    PeerCredentials getPeerCredentials() throws IOException {
        return getPeerCredentials(intValue());
    }

    long sendFile(DefaultFileRegion src, long baseOffset, long offset, long length) throws IOException {
        // Open the file-region as it may be created via the lazy constructor. This is needed as we directly access
        // the FileChannel field via JNI.
        src.open();

        long res = sendFile(intValue(), src, baseOffset, offset, length);
        if (res >= 0) {
            return res;
        }
        return ioResult(""sendfile"", (int) res);
    }

    /**
     * Establish a connection to the given destination address, and send the given data to it.
     *
     * <strong>Note:</strong> This method relies on the {@code connectx(2)} system call, which is MacOS specific.
     *
     * @param source      the source address we are connecting from.
     * @param destination the destination address we are connecting to.
     * @param data        the data to copy to the kernel-side socket buffer.
     * @param tcpFastOpen if {@code true}, set the flags needed to enable TCP FastOpen connecting.
     * @return The number of bytes copied to the kernel-side socket buffer, or the number of bytes sent to the
     * destination. This number is <em>negative</em> if connecting is left in an in-progress state,
     * or <em>positive</em> if the connection was immediately established.
     * @throws IOException if an IO error occurs, if the {@code data} is too big to send in one go,
     * or if the system call is not supported on your platform.
     */
    int connectx(InetSocketAddress source, InetSocketAddress destination, IovArray data, boolean tcpFastOpen)
            throws IOException {
        checkNotNull(destination, ""Destination InetSocketAddress cannot be null."");
        int flags = tcpFastOpen ? CONNECT_TCP_FASTOPEN : 0;

        boolean sourceIPv6;
        byte[] sourceAddress;
        int sourceScopeId;
        int sourcePort;
        if (source == null) {
            sourceIPv6 = false;
            sourceAddress = null;
            sourceScopeId = 0;
            sourcePort = 0;
        } else {
            InetAddress  [MASK]  = source.getAddress();
            sourceIPv6 = useIpv6(this,  [MASK] );
            if ( [MASK]  instanceof Inet6Address) {
                sourceAddress =  [MASK] .getAddress();
                sourceScopeId = ((Inet6Address)  [MASK] ).getScopeId();
            } else {
                // convert to ipv4 mapped ipv6 address;
                sourceScopeId = 0;
                sourceAddress = ipv4MappedIpv6Address( [MASK] .getAddress());
            }
            sourcePort = source.getPort();
        }

        InetAddress destinationInetAddress = destination.getAddress();
        boolean destinationIPv6 = useIpv6(this, destinationInetAddress);
        byte[] destinationAddress;
        int destinationScopeId;
        if (destinationInetAddress instanceof Inet6Address) {
            destinationAddress = destinationInetAddress.getAddress();
            destinationScopeId = ((Inet6Address) destinationInetAddress).getScopeId();
        } else {
            // convert to ipv4 mapped ipv6 address;
            destinationScopeId = 0;
            destinationAddress = ipv4MappedIpv6Address(destinationInetAddress.getAddress());
        }
        int destinationPort = destination.getPort();

        long iovAddress;
        int iovCount;
        int iovDataLength;
        if (data == null || data.count() == 0) {
            iovAddress = 0;
            iovCount = 0;
            iovDataLength = 0;
        } else {
            iovAddress = data.memoryAddress(0);
            iovCount = data.count();
            long size = data.size();
            if (size > Integer.MAX_VALUE) {
                throw new IOException(""IovArray.size() too big: "" + size + "" bytes."");
            }
            iovDataLength = (int) size;
        }

        int result = connectx(intValue(),
                UNSPECIFIED_SOURCE_INTERFACE, sourceIPv6, sourceAddress, sourceScopeId, sourcePort,
                destinationIPv6, destinationAddress, destinationScopeId, destinationPort,
                flags, iovAddress, iovCount, iovDataLength);
        if (result == ERRNO_EINPROGRESS_NEGATIVE) {
            // This is normal for non-blocking sockets.
            // We'll know the connection has been established when the socket is selectable for writing.
            // Tell the channel the data was written, so the outbound buffer can update its position.
            return -iovDataLength;
        }
        if (result < 0) {
            return ioResult(""connectx"", result);
        }
        return result;
    }

    public static BsdSocket newSocketStream() {
        return new BsdSocket(newSocketStream0());
    }

    public static BsdSocket newSocketStream(InternetProtocolFamily protocol) {
        return new BsdSocket(newSocketStream0(protocol));
    }

    public static BsdSocket newSocketDgram() {
        return new BsdSocket(newSocketDgram0());
    }

    public static BsdSocket newSocketDgram(InternetProtocolFamily protocol) {
        return new BsdSocket(newSocketDgram0(protocol));
    }

    public static BsdSocket newSocketDomain() {
        return new BsdSocket(newSocketDomain0());
    }

    public static BsdSocket newSocketDomainDgram() {
        return new BsdSocket(newSocketDomainDgram0());
    }

    private static native long sendFile(int socketFd, DefaultFileRegion src, long baseOffset,
                                        long offset, long length) throws IOException;

    /**
     * @return If successful, zero or positive number of bytes transfered, otherwise negative errno.
     */
    private static native int connectx(
            int socketFd,
            // sa_endpoints_t *endpoints:
            int sourceInterface,
            boolean sourceIPv6, byte[] sourceAddress, int sourceScopeId, int sourcePort,
            boolean destinationIPv6, byte[] destinationAddress, int destinationScopeId, int destinationPort,
            // sae_associd_t associd is reserved
            int flags,
            long iovAddress, int iovCount, int iovDataLength
            // sae_connid_t *connid is reserved
    );

    private static native String[] getAcceptFilter(int fd) throws IOException;

    private static native int getTcpNoPush(int fd) throws IOException;

    private static native int getSndLowAt(int fd) throws IOException;

    private static native int isTcpFastOpen(int fd) throws IOException;

    private static native PeerCredentials getPeerCredentials(int fd) throws IOException;

    private static native void setAcceptFilter(int fd, String filterName, String filterArgs) throws IOException;

    private static native void setTcpNoPush(int fd, int tcpNoPush) throws IOException;

    private static native void setSndLowAt(int fd, int lowAt) throws IOException;

    private static native void setTcpFastOpen(int fd, int enableFastOpen) throws IOException;
}
","sourceInetAddress
",sourceAddress,sourceInetAddress,sourceAddress,sourceAddress,
"

package jenkins.util;

import hudson.Util;
import java.util.HashMap;
import java.util.Map;

/**
 * Utilities to reduce memory footprint
 * @author Sam Van Oort
 */
public class MemoryReductionUtil {
    /** Returns the capacity we need to allocate for a HashMap so it will hold all elements without needing to resize. */
    public static int preallocatedHashmapCapacity(int  [MASK] ) {
        if ( [MASK]  <= 0) {
            return 0;
        } else if ( [MASK]  < 3) {
            return  [MASK]  + 1;
        } else {
            return  [MASK]  +  [MASK]  / 3; // Default load factor is 0.75, so we want to fill that much.
        }
    }

    /** Returns a mutable HashMap presized to hold the given number of elements without needing to resize. */
    public static Map getPresizedMutableMap(int elementCount) {
        return new HashMap(preallocatedHashmapCapacity(elementCount));
    }

    /** Empty string array, exactly what it says on the tin. Avoids repeatedly created empty array when calling ""toArray."" */
    public static final String[] EMPTY_STRING_ARRAY = new String[0];

    /** Returns the input strings, but with all values interned. */
    public static String[] internInPlace(String[] input) {
        if (input == null) {
            return null;
        } else if (input.length == 0) {
            return EMPTY_STRING_ARRAY;
        }
        for (int i = 0; i < input.length; i++) {
            input[i] = Util.intern(input[i]);
        }
        return input;
    }

}
","elementsToHold
",memoryacity,capacity,numElements,numElements,
"
package org.apache.dubbo.spring.boot.actuate.endpoint.metadata;

import org.apache.dubbo.config.ProtocolConfig;
import org.apache.dubbo.config.spring.ServiceBean;
import org.apache.dubbo.config.spring.beans.factory.annotation.ReferenceAnnotationBeanPostProcessor;
import org.apache.dubbo.config.spring.util.DubboBeanUtils;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.EnvironmentAware;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.Environment;

import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.URL;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.Map;

import static org.springframework.beans.factory.BeanFactoryUtils.beansOfTypeIncludingAncestors;
import static org.springframework.util.ClassUtils.isPrimitiveOrWrapper;

/**
 * Abstract Dubbo Meatadata
 *
 * @since 2.7.0
 */
public abstract class AbstractDubboMetadata implements ApplicationContextAware, EnvironmentAware {

    protected ApplicationContext applicationContext;

    protected ConfigurableEnvironment environment;

    private static boolean isSimpleType(Class<?> type) {
        return isPrimitiveOrWrapper(type)
                || type == String.class
                || type == BigDecimal.class
                || type == BigInteger.class
                || type == Date.class
                || type == URL.class
                || type == Class.class
                ;
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    @Override
    public void setEnvironment(Environment environment) {
        if (environment instanceof ConfigurableEnvironment) {
            this.environment = (ConfigurableEnvironment) environment;
        }
    }

    protected Map<String, Object> resolveBeanMetadata(final Object bean) {

        final Map<String, Object>  [MASK]  = new LinkedHashMap<>();

        try {

            BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass());
            PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();

            for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {

                Method readMethod = propertyDescriptor.getReadMethod();

                if (readMethod != null && isSimpleType(propertyDescriptor.getPropertyType())) {

                    String name = Introspector.decapitalize(propertyDescriptor.getName());
                    Object value = readMethod.invoke(bean);
                    if (value != null) {
                         [MASK] .put(name, value);
                    }
                }

            }

        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        return  [MASK] ;

    }

    protected Map<String, ServiceBean> getServiceBeansMap() {
        return beansOfTypeIncludingAncestors(applicationContext, ServiceBean.class);
    }

    protected ReferenceAnnotationBeanPostProcessor getReferenceAnnotationBeanPostProcessor() {
        return DubboBeanUtils.getReferenceAnnotationBeanPostProcessor(applicationContext);
    }

    protected Map<String, ProtocolConfig> getProtocolConfigsBeanMap() {
        return beansOfTypeIncludingAncestors(applicationContext, ProtocolConfig.class);
    }


}
","beanMetadata
",aMap,metadata,propertyMap,metadata,
"package io.netty.util;

import org.junit.jupiter.api.Test;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

public class HashedWheelTimerTest {

    @Test
    public void testScheduleTimeoutShouldNotRunBeforeDelay() throws InterruptedException {
        final Timer timer = new HashedWheelTimer();
        final CountDownLatch  [MASK]  = new CountDownLatch(1);
        final Timeout timeout = timer.newTimeout(new TimerTask() {
            @Override
            public void run(Timeout timeout) throws Exception {
                fail(""This should not have run"");
                 [MASK] .countDown();
            }
        }, 10, TimeUnit.SECONDS);
        assertFalse( [MASK] .await(3, TimeUnit.SECONDS));
        assertFalse(timeout.isExpired(), ""timer should not expire"");
        timer.stop();
    }

    @Test
    public void testScheduleTimeoutShouldRunAfterDelay() throws InterruptedException {
        final Timer timer = new HashedWheelTimer();
        final CountDownLatch  [MASK]  = new CountDownLatch(1);
        final Timeout timeout = timer.newTimeout(new TimerTask() {
            @Override
            public void run(Timeout timeout) throws Exception {
                 [MASK] .countDown();
            }
        }, 2, TimeUnit.SECONDS);
        assertTrue( [MASK] .await(3, TimeUnit.SECONDS));
        assertTrue(timeout.isExpired(), ""timer should expire"");
        timer.stop();
    }

    @Test
    @org.junit.jupiter.api.Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testStopTimer() throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(3);
        final Timer timerProcessed = new HashedWheelTimer();
        for (int i = 0; i < 3; i ++) {
            timerProcessed.newTimeout(new TimerTask() {
                @Override
                public void run(final Timeout timeout) throws Exception {
                    latch.countDown();
                }
            }, 1, TimeUnit.MILLISECONDS);
        }

        latch.await();
        assertEquals(0, timerProcessed.stop().size(), ""Number of unprocessed timeouts should be 0"");

        final Timer timerUnprocessed = new HashedWheelTimer();
        for (int i = 0; i < 5; i ++) {
            timerUnprocessed.newTimeout(new TimerTask() {
                @Override
                public void run(Timeout timeout) throws Exception {
                }
            }, 5, TimeUnit.SECONDS);
        }
        Thread.sleep(1000L); // sleep for a second
        assertFalse(timerUnprocessed.stop().isEmpty(), ""Number of unprocessed timeouts should be greater than 0"");
    }

    @Test
    @org.junit.jupiter.api.Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testTimerShouldThrowExceptionAfterShutdownForNewTimeouts() throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(3);
        final Timer timer = new HashedWheelTimer();
        for (int i = 0; i < 3; i ++) {
            timer.newTimeout(new TimerTask() {
                @Override
                public void run(Timeout timeout) throws Exception {
                    latch.countDown();
                }
            }, 1, TimeUnit.MILLISECONDS);
        }

        latch.await();
        timer.stop();

        try {
            timer.newTimeout(createNoOpTimerTask(), 1, TimeUnit.MILLISECONDS);
            fail(""Expected exception didn't occur."");
        } catch (IllegalStateException ignored) {
            // expected
        }
    }

    @Test
    @org.junit.jupiter.api.Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
    public void testTimerOverflowWheelLength() throws InterruptedException {
        final HashedWheelTimer timer = new HashedWheelTimer(
            Executors.defaultThreadFactory(), 100, TimeUnit.MILLISECONDS, 32);
        final CountDownLatch latch = new CountDownLatch(3);

        timer.newTimeout(new TimerTask() {
            @Override
            public void run(final Timeout timeout) throws Exception {
                timer.newTimeout(this, 100, TimeUnit.MILLISECONDS);
                latch.countDown();
            }
        }, 100, TimeUnit.MILLISECONDS);

        latch.await();
        assertFalse(timer.stop().isEmpty());
    }

    @Test
    public void testExecutionOnTime() throws InterruptedException {
        int tickDuration = 200;
        int timeout = 125;
        int maxTimeout = 2 * (tickDuration + timeout);
        final HashedWheelTimer timer = new HashedWheelTimer(tickDuration, TimeUnit.MILLISECONDS);
        final BlockingQueue<Long> queue = new LinkedBlockingQueue<Long>();

        int scheduledTasks = 100000;
        for (int i = 0; i < scheduledTasks; i++) {
            final long start = System.nanoTime();
            timer.newTimeout(new TimerTask() {
                @Override
                public void run(final Timeout timeout) throws Exception {
                    queue.add(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
                }
            }, timeout, TimeUnit.MILLISECONDS);
        }

        for (int i = 0; i < scheduledTasks; i++) {
            long delay = queue.take();
            assertTrue(delay >= timeout && delay < maxTimeout,
                ""Timeout + "" + scheduledTasks + "" delay "" + delay + "" must be "" + timeout + "" < "" + maxTimeout);
        }

        timer.stop();
    }

    @Test
    public void testExecutionOnTaskExecutor() throws InterruptedException {
        int timeout = 10;

        final CountDownLatch latch = new CountDownLatch(1);
        final CountDownLatch timeoutLatch = new CountDownLatch(1);
        Executor executor = new Executor() {
            @Override
            public void execute(Runnable command) {
                try {
                    command.run();
                } finally {
                    latch.countDown();
                }
            }
        };
        final HashedWheelTimer timer = new HashedWheelTimer(Executors.defaultThreadFactory(), 100,
                TimeUnit.MILLISECONDS, 32, true, 2, executor);
        timer.newTimeout(new TimerTask() {
            @Override
            public void run(final Timeout timeout) throws Exception {
                timeoutLatch.countDown();
            }
        }, timeout, TimeUnit.MILLISECONDS);

        latch.await();
        timeoutLatch.await();
        timer.stop();
    }

    @Test
    public void testRejectedExecutionExceptionWhenTooManyTimeoutsAreAddedBackToBack() {
        HashedWheelTimer timer = new HashedWheelTimer(Executors.defaultThreadFactory(), 100,
            TimeUnit.MILLISECONDS, 32, true, 2);
        timer.newTimeout(createNoOpTimerTask(), 5, TimeUnit.SECONDS);
        timer.newTimeout(createNoOpTimerTask(), 5, TimeUnit.SECONDS);
        try {
            timer.newTimeout(createNoOpTimerTask(), 1, TimeUnit.MILLISECONDS);
            fail(""Timer allowed adding 3 timeouts when maxPendingTimeouts was 2"");
        } catch (RejectedExecutionException e) {
            // Expected
        } finally {
            timer.stop();
        }
    }

    @Test
    public void testNewTimeoutShouldStopThrowingRejectedExecutionExceptionWhenExistingTimeoutIsCancelled()
        throws InterruptedException {
        final int tickDurationMs = 100;
        final HashedWheelTimer timer = new HashedWheelTimer(Executors.defaultThreadFactory(), tickDurationMs,
            TimeUnit.MILLISECONDS, 32, true, 2);
        timer.newTimeout(createNoOpTimerTask(), 5, TimeUnit.SECONDS);
        Timeout timeoutToCancel = timer.newTimeout(createNoOpTimerTask(), 5, TimeUnit.SECONDS);
        assertTrue(timeoutToCancel.cancel());

        Thread.sleep(tickDurationMs * 5);

        final CountDownLatch secondLatch = new CountDownLatch(1);
        timer.newTimeout(createCountDownLatchTimerTask(secondLatch), 90, TimeUnit.MILLISECONDS);

        secondLatch.await();
        timer.stop();
    }

    @Test
    @org.junit.jupiter.api.Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)
    public void testNewTimeoutShouldStopThrowingRejectedExecutionExceptionWhenExistingTimeoutIsExecuted()
        throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(1);
        final HashedWheelTimer timer = new HashedWheelTimer(Executors.defaultThreadFactory(), 25,
            TimeUnit.MILLISECONDS, 4, true, 2);
        timer.newTimeout(createNoOpTimerTask(), 5, TimeUnit.SECONDS);
        timer.newTimeout(createCountDownLatchTimerTask(latch), 90, TimeUnit.MILLISECONDS);

        latch.await();

        final CountDownLatch secondLatch = new CountDownLatch(1);
        timer.newTimeout(createCountDownLatchTimerTask(secondLatch), 90, TimeUnit.MILLISECONDS);

        secondLatch.await();
        timer.stop();
    }

    @Test()
    public void reportPendingTimeouts() throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(1);
        final HashedWheelTimer timer = new HashedWheelTimer();
        final Timeout t1 = timer.newTimeout(createNoOpTimerTask(), 100, TimeUnit.MINUTES);
        final Timeout t2 = timer.newTimeout(createNoOpTimerTask(), 100, TimeUnit.MINUTES);
        timer.newTimeout(createCountDownLatchTimerTask(latch), 90, TimeUnit.MILLISECONDS);

        assertEquals(3, timer.pendingTimeouts());
        t1.cancel();
        t2.cancel();
        latch.await();

        assertEquals(0, timer.pendingTimeouts());
        timer.stop();
    }

    @Test
    public void testOverflow() throws InterruptedException  {
        final HashedWheelTimer timer = new HashedWheelTimer();
        final CountDownLatch latch = new CountDownLatch(1);
        Timeout timeout = timer.newTimeout(new TimerTask() {
            @Override
            public void run(Timeout timeout) {
                latch.countDown();
            }
        }, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
        assertFalse(latch.await(1, TimeUnit.SECONDS));
        timeout.cancel();
        timer.stop();
    }

    private static TimerTask createNoOpTimerTask() {
        return new TimerTask() {
            @Override
            public void run(final Timeout timeout) throws Exception {
            }
        };
    }

    private static TimerTask createCountDownLatchTimerTask(final CountDownLatch latch) {
        return new TimerTask() {
            @Override
            public void run(final Timeout timeout) throws Exception {
                latch.countDown();
            }
        };
    }
}
","barrier
",latch,latch,countDownLatch,timeoutLatch,
"
package proguard.optimize.peephole;

import proguard.classfile.*;
import proguard.classfile.attribute.*;
import proguard.classfile.attribute.visitor.*;
import proguard.classfile.util.*;
import proguard.classfile.visitor.*;

import java.util.*;

/**
 * This ClassVisitor disambiguates line numbers, in the classes that it
 * visits. It shifts line numbers that originate from different classes
 * (e.g. due to method inlining or class merging) to blocks that don't
 * overlap with the main line numbers and with each other. The line numbers
 * then uniquely identify the inlined and merged code in the classes.
 *
 * @author Eric Lafortune
 */
public class LineNumberLinearizer
extends      SimplifiedVisitor
implements   ClassVisitor,
             MemberVisitor,
             AttributeVisitor,
             LineNumberInfoVisitor
{
    private static final boolean DEBUG = false;

    public  static final int SHIFT_ROUNDING       = 1000;
    private static final int SHIFT_ROUNDING_LIMIT = 50000;


    private Stack          enclosingLineNumbers = new Stack();
    private LineNumberInfo previousLineNumberInfo;
    private int            highestUsedLineNumber;
    private int            currentLineNumberShift;


    // Implementations for ClassVisitor.

    public void visitProgramClass(ProgramClass programClass)
    {
        // Find the highest line number in the entire class.
        LineNumberRangeFinder  [MASK]  =
            new LineNumberRangeFinder();

        programClass.methodsAccept(new AllAttributeVisitor(true,
                                   new AllLineNumberInfoVisitor(
                                    [MASK] )));

        // Are there any inlined line numbers?
        if ( [MASK] .hasSource())
        {
            // Remember the minimum initial shift.
            highestUsedLineNumber =  [MASK] .getHighestLineNumber();

            // Shift the inlined line numbers.
            programClass.methodsAccept(this);
        }
    }


    // Implementations for MemberVisitor.

    public void visitProgramMethod(ProgramClass programClass, ProgramMethod programMethod)
    {
        programMethod.attributesAccept(programClass, this);
    }


    // Implementations for AttributeVisitor.

    public void visitAnyAttribute(Clazz clazz, Attribute attribute) {}


    public void visitCodeAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute)
    {
        codeAttribute.attributesAccept(clazz, method, this);
    }


    public void visitLineNumberTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, LineNumberTableAttribute lineNumberTableAttribute)
    {
        if (DEBUG)
        {
            System.out.println(""LineNumberLinearizer [""+clazz.getName()+"".""+method.getName(clazz)+method.getDescriptor(clazz)+""]:"");
        }

        enclosingLineNumbers.clear();
        previousLineNumberInfo = null;

        // Process all line numbers.
        lineNumberTableAttribute.lineNumbersAccept(clazz, method, codeAttribute, this);
    }


    // Implementations for LineNumberInfoVisitor.

    public void visitLineNumberInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, LineNumberInfo lineNumberInfo)
    {
        String source = lineNumberInfo.getSource();

        if (DEBUG)
        {
            System.out.print(""    ["" + lineNumberInfo.u2startPC + ""] line "" + lineNumberInfo.u2lineNumber + (source == null ? """" : "" ["" + source + ""]""));
        }

        // Is it an inlined line number?
        if (source != null)
        {
            ExtendedLineNumberInfo extendedLineNumberInfo =
                (ExtendedLineNumberInfo)lineNumberInfo;

            int lineNumber = extendedLineNumberInfo.u2lineNumber;

            // Are we entering or exiting a new inlined block?
            if (previousLineNumberInfo == null ||
                previousLineNumberInfo.getSource() != source)
            {
                // Are we entering a new inlined block?
                if (lineNumber != MethodInliner.INLINED_METHOD_END_LINE_NUMBER)
                {
                    // Remember information about the inlined block.
                    enclosingLineNumbers.push(previousLineNumberInfo != null ?
                        new MyLineNumberBlock(currentLineNumberShift,
                                              previousLineNumberInfo.u2lineNumber,
                                              previousLineNumberInfo.getSource()) :
                        new MyLineNumberBlock(0, 0, null));

                    // Parse the end line number from the source string,
                    // so we know how large a block this will be.
                    int separatorIndex1 = source.indexOf(':');
                    int separatorIndex2 = source.indexOf(':', separatorIndex1 + 1);

                    int startLineNumber = Integer.parseInt(source.substring(separatorIndex1 + 1, separatorIndex2));
                    int endLineNumber   = Integer.parseInt(source.substring(separatorIndex2 + 1));

                    // Start shifting, if necessary, so the block ends up beyond
                    // the highest used line number. We're striving for rounded
                    // shifts, unless we've reached a given limit, to avoid
                    // running out of line numbers too quickly.
                    currentLineNumberShift =
                        highestUsedLineNumber > SHIFT_ROUNDING_LIMIT ?
                            highestUsedLineNumber - startLineNumber + 1 :
                        startLineNumber > highestUsedLineNumber ? 0 :
                            (highestUsedLineNumber - startLineNumber + SHIFT_ROUNDING)
                            / SHIFT_ROUNDING * SHIFT_ROUNDING;

                    highestUsedLineNumber = endLineNumber + currentLineNumberShift;

                    if (DEBUG)
                    {
                        System.out.print("" (enter with shift ""+currentLineNumberShift+"")"");
                    }

                    // Apply the shift.
                    lineNumberInfo.u2lineNumber += currentLineNumberShift;
                }

                // TODO: There appear to be cases where the stack is empty at this point, so we've added a check.
                else if (enclosingLineNumbers.isEmpty())
                {
                    if (DEBUG)
                    {
                        System.err.println(""Problem linearizing line numbers for optimized code (""+clazz.getName()+"".""+method.getName(clazz)+"")"");
                    }
                }

                // Are we exiting an inlined block?
                else
                {
                    // Pop information about the enclosing line number.
                    MyLineNumberBlock lineNumberBlock =
                        (MyLineNumberBlock)enclosingLineNumbers.pop();

                    // Set this end of the block to the line at which it was
                    // inlined.
                    extendedLineNumberInfo.u2lineNumber = lineNumberBlock.enclosingLineNumber;
                    extendedLineNumberInfo.source       = lineNumberBlock.enclosingSource;

                    // Reset the shift to the shift of the block.
                    currentLineNumberShift = lineNumberBlock.lineNumberShift;

                    if (DEBUG)
                    {
                        System.out.print("" (exit to shift ""+currentLineNumberShift+"")"");
                    }
                }
            }
            else
            {
                if (DEBUG)
                {
                    System.out.print("" (apply shift ""+currentLineNumberShift+"")"");
                }

                // Apply the shift.
                lineNumberInfo.u2lineNumber += currentLineNumberShift;
            }
        }

        previousLineNumberInfo = lineNumberInfo;

        if (DEBUG)
        {
            System.out.println("" -> line "" + lineNumberInfo.u2lineNumber);
        }
    }


    /**
     * This class represents a block of line numbers that originates from the
     * same inlined method.
     */
    private static class MyLineNumberBlock
    {
        public final int    lineNumberShift;
        public final int    enclosingLineNumber;
        public final String enclosingSource;

        public MyLineNumberBlock(int    lineNumberShift,
                                 int    enclosingLineNumber,
                                 String enclosingSource)
        {
            this.lineNumberShift     = lineNumberShift;
            this.enclosingLineNumber = enclosingLineNumber;
            this.enclosingSource     = enclosingSource;
        }
    }
}
","lineNumberRangeFinder
",finder,lineNumberRangeF,lineNumberRangeFinder,lineNumberShift,
"package jadx.plugins.input.dex.smali;

import java.util.HashMap;
import java.util.Map;

import org.jetbrains.annotations.NotNull;

import jadx.api.plugins.input.insns.InsnData;
import jadx.plugins.input.dex.insns.DexOpcodes;

public class SmaliInsnFormat {

	private static SmaliInsnFormat instance;

	public static synchronized SmaliInsnFormat getInstance() {
		SmaliInsnFormat instance = SmaliInsnFormat.instance;
		if (instance == null) {
			instance = new SmaliInsnFormat();
			SmaliInsnFormat.instance = instance;
		}
		return instance;
	}

	private final Map<Integer, InsnFormatter> formatters;

	public SmaliInsnFormat() {
		formatters = registerFormatters();
	}

	private Map<Integer, InsnFormatter> registerFormatters() {
		Map<Integer, InsnFormatter> map = new HashMap<>();
		map.put(DexOpcodes.NOP, fi -> fi.getCodeWriter().add(""nop""));
		map.put(DexOpcodes.SGET_OBJECT, staticFieldInsn(""sget-object""));
		map.put(DexOpcodes.SPUT_BOOLEAN, staticFieldInsn(""sput-boolean""));
		map.put(DexOpcodes.CONST, constInsn(""const""));
		map.put(DexOpcodes.CONST_HIGH16, constInsn(""const/high16""));
		map.put(DexOpcodes.CONST_STRING, stringInsn(""const-string""));
		map.put(DexOpcodes.INVOKE_VIRTUAL, invokeInsn(""invoke-virtual""));
		map.put(DexOpcodes.INVOKE_DIRECT, invokeInsn(""invoke-direct""));
		map.put(DexOpcodes.INVOKE_SUPER, invokeInsn(""invoke-super""));
		map.put(DexOpcodes.INVOKE_STATIC, invokeInsn(""invoke-static""));
		map.put(DexOpcodes.MOVE_RESULT, oneArgsInsn(""move-result""));
		map.put(DexOpcodes.RETURN_VOID, noArgsInsn(""return-void""));
		map.put(DexOpcodes.GOTO, gotoInsn(""goto""));
		map.put(DexOpcodes.GOTO_16, gotoInsn(""goto-16""));
		map.put(DexOpcodes.MOVE, simpleInsn(""move""));
		// TODO: complete list
		return map;
	}

	private InsnFormatter simpleInsn(String name) {
		return fi -> {
			SmaliCodeWriter code = fi.getCodeWriter();
			code.add(name);
			InsnData insn = fi.getInsn();
			int regsCount = insn.getRegsCount();
			for (int i = 0; i < regsCount; i++) {
				if (i == 0) {
					code.add(' ');
				} else {
					code.add("", "");
				}
				code.add(regAt(fi, i));
			}
		};
	}

	private InsnFormatter gotoInsn(String name) {
		return fi -> fi.getCodeWriter().add(name).add("" :goto"").add(Integer.toHexString(fi.getInsn().getTarget()));
	}

	@NotNull
	private InsnFormatter staticFieldInsn(String name) {
		return fi -> fi.getCodeWriter().add(name).add(' ').add(regAt(fi, 0)).add("", "").add(field(fi));
	}

	@NotNull
	private InsnFormatter constInsn(String name) {
		return fi -> fi.getCodeWriter().add(name).add(' ').add(regAt(fi, 0)).add("", "").add(literal(fi));
	}

	@NotNull
	private InsnFormatter stringInsn(String name) {
		return fi -> fi.getCodeWriter().add(name).add(' ').add(regAt(fi, 0)).add("", "").add(str(fi));
	}

	@NotNull
	private InsnFormatter invokeInsn(String name) {
		return fi -> {
			SmaliCodeWriter code = fi.getCodeWriter();
			code.add(name).add(' ');
			regsList(code, fi.getInsn());
			code.add("", "").add(method(fi));
		};
	}

	private InsnFormatter oneArgsInsn(String name) {
		return fi -> fi.getCodeWriter().add(name).add(' ').add(regAt(fi, 0));
	}

	private InsnFormatter noArgsInsn(String name) {
		return (fi) -> fi.getCodeWriter().add(name);
	}

	private String literal(InsnFormatterInfo fi) {
		return ""0x"" + Long.toHexString(fi.getInsn().getLiteral());
	}

	private String str(InsnFormatterInfo fi) {
		return ""\"""" + fi.getInsn().getIndexAsString() + ""\"""";
	}

	private String field(InsnFormatterInfo fi) {
		return fi.getInsn().getIndexAsField().toString();
	}

	private String method(InsnFormatterInfo fi) {
		return fi.getInsn().getIndexAsMethod().toString();
	}

	private void regsList(SmaliCodeWriter code, InsnData insn) {
		int argsCount = insn.getRegsCount();
		code.add('{');
		for (int i = 0; i < argsCount; i++) {
			if (i != 0) {
				code.add("", "");
			}
			code.add(""v"").add(insn.getReg(i));
		}
		code.add('}');
	}

	private String regAt(InsnFormatterInfo fi, int argNum) {
		return ""v"" + fi.getInsn().getReg(argNum);
	}

	public void format(InsnFormatterInfo formatInfo) {
		InsnData insn = formatInfo.getInsn();
		insn.decode();
		int rawOpcodeUnit = insn.getRawOpcodeUnit();
		int  [MASK]  = rawOpcodeUnit & 0xFF;
		InsnFormatter insnFormatter = formatters.get( [MASK] );
		if (insnFormatter != null) {
			insnFormatter.format(formatInfo);
		} else {
			formatInfo.getCodeWriter().add(""# "").add(insn.getOpcode()).add("" (?0x"").add(Integer.toHexString(rawOpcodeUnit)).add(')');
		}
	}

	public String format(InsnData insn) {
		InsnFormatterInfo formatInfo = new InsnFormatterInfo(new SmaliCodeWriter(), insn);
		format(formatInfo);
		return formatInfo.getCodeWriter().getCode();
	}
}
","opcode
",format,rawOpCodeByte,opcode,opcode,
"

package android.icu.dev.test.util;

import java.nio.ByteBuffer;
import java.util.NoSuchElementException;

import org.junit.Test;

import android.icu.dev.test.TestFmwk;
import android.icu.util.BytesTrie;
import android.icu.util.BytesTrieBuilder;
import android.icu.util.StringTrieBuilder;

public class BytesTrieTest extends TestFmwk {
    public BytesTrieTest() {}

    // All test functions have a TestNN prefix where NN is a double-digit number.
    // This is so that when tests are run in sorted order
    // the simpler ones are run first.
    // If there is a problem, the simpler ones are easier to step through.

    @Test
    public void Test00Builder() {
        builder_.clear();
        try {
            builder_.build(StringTrieBuilder.Option.FAST);
            errln(""BytesTrieBuilder().build() did not throw IndexOutOfBoundsException"");
            return;
        } catch(IndexOutOfBoundsException e) {
            // good
        }
        try {
            byte[] equal=new byte[] { 0x3d };  // ""=""
            builder_.add(equal, 1, 0).add(equal, 1, 1);
            errln(""BytesTrieBuilder.add() did not detect duplicates"");
            return;
        } catch(IllegalArgumentException e) {
            // good
        }
    }

    private static final class StringAndValue {
        public StringAndValue(String str, int val) {
            s=str;
            bytes=new byte[s.length()];
            for(int i=0; i<bytes.length; ++i) {
                bytes[i]=(byte)s.charAt(i);
            }
            value=val;
        }

        public String s;
        public byte[] bytes;
        public int value;
    }
    // Note: C++ StringAndValue initializers converted to Java syntax
    // with Eclipse Find/Replace regular expressions:
    // Find:            \{ ("".*"", [-0-9xa-fA-F]+) \}
    // Replace with:    new StringAndValue($1)

    @Test
    public void Test10Empty() {
        final StringAndValue[] data={
            new StringAndValue("""", 0)
        };
        checkData(data);
    }

    @Test
    public void Test11_a() {
        final StringAndValue[] data={
            new StringAndValue(""a"", 1)
        };
        checkData(data);
    }

    @Test
    public void Test12_a_ab() {
        final StringAndValue[] data={
            new StringAndValue(""a"", 1),
            new StringAndValue(""ab"", 100)
        };
        checkData(data);
    }

    @Test
    public void Test20ShortestBranch() {
        final StringAndValue[] data={
            new StringAndValue(""a"", 1000),
            new StringAndValue(""b"", 2000)
        };
        checkData(data);
    }

    @Test
    public void Test21Branches() {
        final StringAndValue[] data={
            new StringAndValue(""a"", 0x10),
            new StringAndValue(""cc"", 0x40),
            new StringAndValue(""e"", 0x100),
            new StringAndValue(""ggg"", 0x400),
            new StringAndValue(""i"", 0x1000),
            new StringAndValue(""kkkk"", 0x4000),
            new StringAndValue(""n"", 0x10000),
            new StringAndValue(""ppppp"", 0x40000),
            new StringAndValue(""r"", 0x100000),
            new StringAndValue(""sss"", 0x200000),
            new StringAndValue(""t"", 0x400000),
            new StringAndValue(""uu"", 0x800000),
            new StringAndValue(""vv"", 0x7fffffff),
            new StringAndValue(""zz"", 0x80000000)
        };
        for(int length=2; length<=data.length; ++length) {
            logln(""TestBranches length=""+length);
            checkData(data, length);
        }
    }

    @Test
    public void Test22LongSequence() {
        final StringAndValue[] data={
            new StringAndValue(""a"", -1),
            // sequence of linear-match nodes
            new StringAndValue(""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"", -2),
            // more than 256 bytes
            new StringAndValue(
                ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""+
                ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""+
                ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""+
                ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""+
                ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ""+
                ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"", -3)
        };
        checkData(data);
    }

    @Test
    public void Test23LongBranch() {
        // Split-branch and interesting compact-integer values.
        final StringAndValue[] data={
            new StringAndValue(""a"", -2),
            new StringAndValue(""b"", -1),
            new StringAndValue(""c"", 0),
            new StringAndValue(""d2"", 1),
            new StringAndValue(""f"", 0x3f),
            new StringAndValue(""g"", 0x40),
            new StringAndValue(""h"", 0x41),
            new StringAndValue(""j23"", 0x1900),
            new StringAndValue(""j24"", 0x19ff),
            new StringAndValue(""j25"", 0x1a00),
            new StringAndValue(""k2"", 0x1a80),
            new StringAndValue(""k3"", 0x1aff),
            new StringAndValue(""l234567890"", 0x1b00),
            new StringAndValue(""l234567890123"", 0x1b01),
            new StringAndValue(""nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn"", 0x10ffff),
            new StringAndValue(""oooooooooooooooooooooooooooooooooooooooooooooooooooooo"", 0x110000),
            new StringAndValue(""pppppppppppppppppppppppppppppppppppppppppppppppppppppp"", 0x120000),
            new StringAndValue(""r"", 0x333333),
            new StringAndValue(""s2345"", 0x4444444),
            new StringAndValue(""t234567890"", 0x77777777),
            new StringAndValue(""z"", 0x80000001)
        };
        checkData(data);
    }

    @Test
    public void Test24ValuesForState() {
        // Check that saveState() and resetToState() interact properly
        // with next() and current().
        final StringAndValue[] data={
            new StringAndValue(""a"", -1),
            new StringAndValue(""ab"", -2),
            new StringAndValue(""abc"", -3),
            new StringAndValue(""abcd"", -4),
            new StringAndValue(""abcde"", -5),
            new StringAndValue(""abcdef"", -6)
        };
        checkData(data);
    }

    @Test
    public void Test30Compact() {
        // Duplicate trailing strings and values provide opportunities for compacting.
        final StringAndValue[] data={
            new StringAndValue(""+"", 0),
            new StringAndValue(""+august"", 8),
            new StringAndValue(""+december"", 12),
            new StringAndValue(""+july"", 7),
            new StringAndValue(""+june"", 6),
            new StringAndValue(""+november"", 11),
            new StringAndValue(""+october"", 10),
            new StringAndValue(""+september"", 9),
            new StringAndValue(""-"", 0),
            new StringAndValue(""-august"", 8),
            new StringAndValue(""-december"", 12),
            new StringAndValue(""-july"", 7),
            new StringAndValue(""-june"", 6),
            new StringAndValue(""-november"", 11),
            new StringAndValue(""-october"", 10),
            new StringAndValue(""-september"", 9),
            // The l+n branch (with its sub-nodes) is a duplicate but will be written
            // both times because each time it follows a different linear-match node.
            new StringAndValue(""xjuly"", 7),
            new StringAndValue(""xjune"", 6)
        };
        checkData(data);
    }

    public BytesTrie buildMonthsTrie(StringTrieBuilder.Option buildOption) {
        // All types of nodes leading to the same value,
        // for code coverage of recursive functions.
        // In particular, we need a lot of branches on some single level
        // to exercise a split-branch node.
        final StringAndValue[] data={
            new StringAndValue(""august"", 8),
            new StringAndValue(""jan"", 1),
            new StringAndValue(""jan."", 1),
            new StringAndValue(""jana"", 1),
            new StringAndValue(""janbb"", 1),
            new StringAndValue(""janc"", 1),
            new StringAndValue(""janddd"", 1),
            new StringAndValue(""janee"", 1),
            new StringAndValue(""janef"", 1),
            new StringAndValue(""janf"", 1),
            new StringAndValue(""jangg"", 1),
            new StringAndValue(""janh"", 1),
            new StringAndValue(""janiiii"", 1),
            new StringAndValue(""janj"", 1),
            new StringAndValue(""jankk"", 1),
            new StringAndValue(""jankl"", 1),
            new StringAndValue(""jankmm"", 1),
            new StringAndValue(""janl"", 1),
            new StringAndValue(""janm"", 1),
            new StringAndValue(""jannnnnnnnnnnnnnnnnnnnnnnnnnnnn"", 1),
            new StringAndValue(""jano"", 1),
            new StringAndValue(""janpp"", 1),
            new StringAndValue(""janqqq"", 1),
            new StringAndValue(""janr"", 1),
            new StringAndValue(""januar"", 1),
            new StringAndValue(""january"", 1),
            new StringAndValue(""july"", 7),
            new StringAndValue(""jun"", 6),
            new StringAndValue(""jun."", 6),
            new StringAndValue(""june"", 6)
        };
        return buildTrie(data, data.length, buildOption);
    }

    @Test
    public void Test40GetUniqueValue() {
        BytesTrie trie=buildMonthsTrie(StringTrieBuilder.Option.FAST);
        long uniqueValue;
        if((uniqueValue=trie.getUniqueValue())!=0) {
            errln(""unique value at root"");
        }
        trie.next('j');
        trie.next('a');
        trie.next('n');
        // getUniqueValue() directly after next()
        if((uniqueValue=trie.getUniqueValue())!=((1<<1)|1)) {
            errln(""not unique value 1 after \""jan\"": instead ""+uniqueValue);
        }
        trie.first('j');
        trie.next('u');
        if((uniqueValue=trie.getUniqueValue())!=0) {
            errln(""unique value after \""ju\"""");
        }
        if(trie.next('n')!=BytesTrie.Result.INTERMEDIATE_VALUE || 6!=trie.getValue()) {
            errln(""not normal value 6 after \""jun\"""");
        }
        // getUniqueValue() after getValue()
        if((uniqueValue=trie.getUniqueValue())!=((6<<1)|1)) {
            errln(""not unique value 6 after \""jun\"""");
        }
        // getUniqueValue() from within a linear-match node
        trie.first('a');
        trie.next('u');
        if((uniqueValue=trie.getUniqueValue())!=((8<<1)|1)) {
            errln(""not unique value 8 after \""au\"""");
        }
    }

    @Test
    public void Test41GetNextBytes() {
        BytesTrie trie=buildMonthsTrie(StringTrieBuilder.Option.SMALL);
        StringBuilder buffer=new StringBuilder();
        int count=trie.getNextBytes(buffer);
        if(count!=2 || !""aj"".contentEquals(buffer)) {
            errln(""months getNextBytes()!=[aj] at root"");
        }
        trie.next('j');
        trie.next('a');
        trie.next('n');
        // getNextBytes() directly after next()
        buffer.setLength(0);
        count=trie.getNextBytes(buffer);
        if(count!=20 || !"".abcdefghijklmnopqru"".contentEquals(buffer)) {
            errln(""months getNextBytes()!=[.abcdefghijklmnopqru] after \""jan\"""");
        }
        // getNextBytes() after getValue()
        trie.getValue();  // next() had returned BytesTrie.Result.INTERMEDIATE_VALUE.
        buffer.setLength(0);
        count=trie.getNextBytes(buffer);
        if(count!=20 || !"".abcdefghijklmnopqru"".contentEquals(buffer)) {
            errln(""months getNextBytes()!=[.abcdefghijklmnopqru] after \""jan\""+getValue()"");
        }
        // getNextBytes() from a linear-match node
        trie.next('u');
        buffer.setLength(0);
        count=trie.getNextBytes(buffer);
        if(count!=1 || !""a"".contentEquals(buffer)) {
            errln(""months getNextBytes()!=[a] after \""janu\"""");
        }
        trie.next('a');
        buffer.setLength(0);
        count=trie.getNextBytes(buffer);
        if(count!=1 || !""r"".contentEquals(buffer)) {
            errln(""months getNextBytes()!=[r] after \""janua\"""");
        }
        trie.next('r');
        trie.next('y');
        // getNextBytes() after a final match
        buffer.setLength(0);
        count=trie.getNextBytes(buffer);
        if(count!=0 || buffer.length()!=0) {
            errln(""months getNextBytes()!=[] after \""january\"""");
        }
    }

    @Test
    public void Test50IteratorFromBranch() {
        BytesTrie trie=buildMonthsTrie(StringTrieBuilder.Option.FAST);
        // Go to a branch node.
        trie.next('j');
        trie.next('a');
        trie.next('n');
        BytesTrie.Iterator iter=trie.iterator();
        // Expected data: Same as in buildMonthsTrie(), except only the suffixes
        // following ""jan"".
        final StringAndValue[] data={
            new StringAndValue("""", 1),
            new StringAndValue(""."", 1),
            new StringAndValue(""a"", 1),
            new StringAndValue(""bb"", 1),
            new StringAndValue(""c"", 1),
            new StringAndValue(""ddd"", 1),
            new StringAndValue(""ee"", 1),
            new StringAndValue(""ef"", 1),
            new StringAndValue(""f"", 1),
            new StringAndValue(""gg"", 1),
            new StringAndValue(""h"", 1),
            new StringAndValue(""iiii"", 1),
            new StringAndValue(""j"", 1),
            new StringAndValue(""kk"", 1),
            new StringAndValue(""kl"", 1),
            new StringAndValue(""kmm"", 1),
            new StringAndValue(""l"", 1),
            new StringAndValue(""m"", 1),
            new StringAndValue(""nnnnnnnnnnnnnnnnnnnnnnnnnnnn"", 1),
            new StringAndValue(""o"", 1),
            new StringAndValue(""pp"", 1),
            new StringAndValue(""qqq"", 1),
            new StringAndValue(""r"", 1),
            new StringAndValue(""uar"", 1),
            new StringAndValue(""uary"", 1)
        };
        checkIterator(iter, data);
        // Reset, and we should get the same result.
        logln(""after iter.reset()"");
        checkIterator(iter.reset(), data);
    }

    @Test
    public void Test51IteratorFromLinearMatch() {
        BytesTrie trie=buildMonthsTrie(StringTrieBuilder.Option.SMALL);
        // Go into a linear-match node.
        trie.next('j');
        trie.next('a');
        trie.next('n');
        trie.next('u');
        trie.next('a');
        BytesTrie.Iterator iter=trie.iterator();
        // Expected data: Same as in buildMonthsTrie(), except only the suffixes
        // following ""janua"".
        final StringAndValue[] data={
            new StringAndValue(""r"", 1),
            new StringAndValue(""ry"", 1)
        };
        checkIterator(iter, data);
        // Reset, and we should get the same result.
        logln(""after iter.reset()"");
        checkIterator(iter.reset(), data);
    }

    @Test
    public void Test52TruncatingIteratorFromRoot() {
        BytesTrie trie=buildMonthsTrie(StringTrieBuilder.Option.FAST);
        BytesTrie.Iterator iter=trie.iterator(4);
        // Expected data: Same as in buildMonthsTrie(), except only the first 4 characters
        // of each string, and no string duplicates from the truncation.
        final StringAndValue[] data={
            new StringAndValue(""augu"", -1),
            new StringAndValue(""jan"", 1),
            new StringAndValue(""jan."", 1),
            new StringAndValue(""jana"", 1),
            new StringAndValue(""janb"", -1),
            new StringAndValue(""janc"", 1),
            new StringAndValue(""jand"", -1),
            new StringAndValue(""jane"", -1),
            new StringAndValue(""janf"", 1),
            new StringAndValue(""jang"", -1),
            new StringAndValue(""janh"", 1),
            new StringAndValue(""jani"", -1),
            new StringAndValue(""janj"", 1),
            new StringAndValue(""jank"", -1),
            new StringAndValue(""janl"", 1),
            new StringAndValue(""janm"", 1),
            new StringAndValue(""jann"", -1),
            new StringAndValue(""jano"", 1),
            new StringAndValue(""janp"", -1),
            new StringAndValue(""janq"", -1),
            new StringAndValue(""janr"", 1),
            new StringAndValue(""janu"", -1),
            new StringAndValue(""july"", 7),
            new StringAndValue(""jun"", 6),
            new StringAndValue(""jun."", 6),
            new StringAndValue(""june"", 6)
        };
        checkIterator(iter, data);
        // Reset, and we should get the same result.
        logln(""after iter.reset()"");
        checkIterator(iter.reset(), data);
    }

    @Test
    public void Test53TruncatingIteratorFromLinearMatchShort() {
        final StringAndValue[] data={
            new StringAndValue(""abcdef"", 10),
            new StringAndValue(""abcdepq"", 200),
            new StringAndValue(""abcdeyz"", 3000)
        };
        BytesTrie trie=buildTrie(data, data.length, StringTrieBuilder.Option.FAST);
        // Go into a linear-match node.
        trie.next('a');
        trie.next('b');
        // Truncate within the linear-match node.
        BytesTrie.Iterator iter=trie.iterator(2);
        final StringAndValue[] expected={
            new StringAndValue(""cd"", -1)
        };
        checkIterator(iter, expected);
        // Reset, and we should get the same result.
        logln(""after iter.reset()"");
        checkIterator(iter.reset(), expected);
    }

    @Test
    public void Test54TruncatingIteratorFromLinearMatchLong() {
        final StringAndValue[] data={
            new StringAndValue(""abcdef"", 10),
            new StringAndValue(""abcdepq"", 200),
            new StringAndValue(""abcdeyz"", 3000)
        };
        BytesTrie trie=buildTrie(data, data.length, StringTrieBuilder.Option.FAST);
        // Go into a linear-match node.
        trie.next('a');
        trie.next('b');
        trie.next('c');
        // Truncate after the linear-match node.
        BytesTrie.Iterator iter=trie.iterator(3);
        final StringAndValue[] expected={
            new StringAndValue(""def"", 10),
            new StringAndValue(""dep"", -1),
            new StringAndValue(""dey"", -1)
        };
        checkIterator(iter, expected);
        // Reset, and we should get the same result.
        logln(""after iter.reset()"");
        checkIterator(iter.reset(), expected);
    }

    @Test
    public void Test59IteratorFromBytes() {
        final StringAndValue[] data={
            new StringAndValue(""mm"", 3),
            new StringAndValue(""mmm"", 33),
            new StringAndValue(""mmnop"", 333)
        };
        builder_.clear();
        for(StringAndValue item : data) {
            builder_.add(item.bytes, item.bytes.length, item.value);
        }
        ByteBuffer trieBytes=builder_.buildByteBuffer(StringTrieBuilder.Option.FAST);
        checkIterator(
            BytesTrie.iterator(trieBytes.array(), trieBytes.arrayOffset()+trieBytes.position(), 0),
            data);
    }

    private void checkData(StringAndValue data[]) {
        checkData(data, data.length);
    }

    private void checkData(StringAndValue data[], int dataLength) {
        logln(""checkData(dataLength=""+dataLength+"", fast)"");
        checkData(data, dataLength, StringTrieBuilder.Option.FAST);
        logln(""checkData(dataLength=""+dataLength+"", small)"");
        checkData(data, dataLength, StringTrieBuilder.Option.SMALL);
    }

    private void checkData(StringAndValue data[], int dataLength, StringTrieBuilder.Option buildOption) {
        BytesTrie trie=buildTrie(data, dataLength, buildOption);
        checkFirst(trie, data, dataLength);
        checkNext(trie, data, dataLength);
        checkNextWithState(trie, data, dataLength);
        checkNextString(trie, data, dataLength);
        checkIterator(trie, data, dataLength);
    }

    private BytesTrie buildTrie(StringAndValue data[], int dataLength,
                                StringTrieBuilder.Option buildOption) {
        // Add the items to the trie builder in an interesting (not trivial, not random) order.
        int index, step;
        if((dataLength&1)!=0) {
            // Odd number of items.
            index=dataLength/2;
            step=2;
        } else if((dataLength%3)!=0) {
            // Not a multiple of 3.
            index=dataLength/5;
            step=3;
        } else {
            index=dataLength-1;
            step=-1;
        }
        builder_.clear();
        for(int i=0; i<dataLength; ++i) {
            builder_.add(data[index].bytes, data[index].bytes.length, data[index].value);
            index=(index+step)%dataLength;
        }
        BytesTrie trie=builder_.build(buildOption);
        try {
            builder_.add(/* ""zzz"" */ new byte[] { 0x7a, 0x7a, 0x7a }, 0, 999);
            errln(""builder.build().add(zzz) did not throw IllegalStateException"");
        } catch(IllegalStateException e) {
            // good
        }
        ByteBuffer trieBytes=builder_.buildByteBuffer(buildOption);
        logln(""serialized trie size: ""+trieBytes.remaining()+"" bytes\n"");
        // Tries from either build() method should be identical but
        // BytesTrie does not implement equals().
        // We just return either one.
        if((dataLength&1)!=0) {
            return trie;
        } else {
            return new BytesTrie(trieBytes.array(), trieBytes.arrayOffset()+trieBytes.position());
        }
    }

    private void checkFirst(BytesTrie trie, StringAndValue data[], int dataLength) {
        for(int i=0; i<dataLength; ++i) {
            if(data[i].s.length()==0) {
                continue;  // skip empty string
            }
            int c=data[i].bytes[0];
            BytesTrie.Result firstResult=trie.first(c);
            int firstValue=firstResult.hasValue() ? trie.getValue() : -1;
            int nextC=data[i].s.length()>1 ? data[i].bytes[1] : 0;
            BytesTrie.Result nextResult=trie.next(nextC);
            if(firstResult!=trie.reset().next(c) ||
               firstResult!=trie.current() ||
               firstValue!=(firstResult.hasValue() ? trie.getValue() : -1) ||
               nextResult!=trie.next(nextC)
            ) {
                errln(String.format(""trie.first(%c)!=trie.reset().next(same) for %s"",
                                    c, data[i].s));
            }
        }
        trie.reset();
    }

    private void checkNext(BytesTrie trie, StringAndValue data[], int dataLength) {
        BytesTrie.State state=new BytesTrie.State();
        for(int i=0; i<dataLength; ++i) {
            int  [MASK] =data[i].s.length();
            BytesTrie.Result result;
            if( !(result=trie.next(data[i].bytes, 0,  [MASK] )).hasValue() ||
                result!=trie.current()
            ) {
                errln(""trie does not seem to contain ""+data[i].s);
            } else if(trie.getValue()!=data[i].value) {
                errln(String.format(""trie value for %s is %d=0x%x instead of expected %d=0x%x"",
                                    data[i].s,
                                    trie.getValue(), trie.getValue(),
                                    data[i].value, data[i].value));
            } else if(result!=trie.current() || trie.getValue()!=data[i].value) {
                errln(""trie value for ""+data[i].s+"" changes when repeating current()/getValue()"");
            }
            trie.reset();
            result=trie.current();
            for(int j=0; j< [MASK] ; ++j) {
                if(!result.hasNext()) {
                    errln(String.format(""trie.current()!=hasNext before end of %s (at index %d)"",
                                        data[i].s, j));
                    break;
                }
                if(result==BytesTrie.Result.INTERMEDIATE_VALUE) {
                    trie.getValue();
                    if(trie.current()!=BytesTrie.Result.INTERMEDIATE_VALUE) {
                        errln(String.format(""trie.getValue().current()!=BytesTrie.Result.INTERMEDIATE_VALUE ""+
                                            ""before end of %s (at index %d)"", data[i].s, j));
                        break;
                    }
                }
                result=trie.next(data[i].bytes[j]);
                if(!result.matches()) {
                    errln(String.format(""trie.next()=BytesTrie.Result.NO_MATCH ""+
                                        ""before end of %s (at index %d)"", data[i].s, j));
                    break;
                }
                if(result!=trie.current()) {
                    errln(String.format(""trie.next()!=following current() ""+
                                        ""before end of %s (at index %d)"", data[i].s, j));
                    break;
                }
            }
            if(!result.hasValue()) {
                errln(""trie.next()!=hasValue at the end of ""+data[i].s);
                continue;
            }
            trie.getValue();
            if(result!=trie.current()) {
                errln(""trie.current() != current()+getValue()+current() after end of ""+
                      data[i].s);
            }
            // Compare the final current() with whether next() can actually continue.
            trie.saveState(state);
            boolean nextContinues=false;
            for(int c=0x20; c<0x7f; ++c) {
                if(trie.resetToState(state).next(c).matches()) {
                    nextContinues=true;
                    break;
                }
            }
            if((result==BytesTrie.Result.INTERMEDIATE_VALUE)!=nextContinues) {
                errln(""(trie.current()==BytesTrie.Result.INTERMEDIATE_VALUE) contradicts ""+
                      ""(trie.next(some UChar)!=BytesTrie.Result.NO_MATCH) after end of ""+data[i].s);
            }
            trie.reset();
        }
    }

    private void checkNextWithState(BytesTrie trie, StringAndValue data[], int dataLength) {
        BytesTrie.State noState=new BytesTrie.State(), state=new BytesTrie.State();
        for(int i=0; i<dataLength; ++i) {
            if((i&1)==0) {
                try {
                    trie.resetToState(noState);
                    errln(""trie.resetToState(noState) should throw an IllegalArgumentException"");
                } catch(IllegalArgumentException e) {
                    // good
                }
            }
            byte[] expectedString=data[i].bytes;
            int  [MASK] =data[i].s.length();
            int partialLength= [MASK] /3;
            for(int j=0; j<partialLength; ++j) {
                if(!trie.next(expectedString[j]).matches()) {
                    errln(""trie.next()=BytesTrie.Result.NO_MATCH for a prefix of ""+data[i].s);
                    return;
                }
            }
            trie.saveState(state);
            BytesTrie.Result resultAtState=trie.current();
            BytesTrie.Result result;
            int valueAtState=-99;
            if(resultAtState.hasValue()) {
                valueAtState=trie.getValue();
            }
            result=trie.next(0);  // mismatch
            if(result!=BytesTrie.Result.NO_MATCH || result!=trie.current()) {
                errln(""trie.next(0) matched after part of ""+data[i].s);
            }
            if( resultAtState!=trie.resetToState(state).current() ||
                (resultAtState.hasValue() && valueAtState!=trie.getValue())
            ) {
                errln(""trie.next(part of ""+data[i].s+"") changes current()/getValue() after ""+
                      ""saveState/next(0)/resetToState"");
            } else if(!(result=trie.next(expectedString, partialLength,  [MASK] )).hasValue() ||
                      result!=trie.current()) {
                errln(""trie.next(rest of ""+data[i].s+"") does not seem to contain ""+data[i].s+"" after ""+
                      ""saveState/next(0)/resetToState"");
            } else if(!(result=trie.resetToState(state).
                                next(expectedString, partialLength,  [MASK] )).hasValue() ||
                      result!=trie.current()) {
                errln(""trie does not seem to contain ""+data[i].s+
                      "" after saveState/next(rest)/resetToState"");
            } else if(trie.getValue()!=data[i].value) {
                errln(String.format(""trie value for %s is %d=0x%x instead of expected %d=0x%x"",
                                    data[i].s,
                                    trie.getValue(), trie.getValue(),
                                    data[i].value, data[i].value));
            }
            trie.reset();
        }
    }

    // next(string) is also tested in other functions,
    // but here we try to go partway through the string, and then beyond it.
    private void checkNextString(BytesTrie trie, StringAndValue data[], int dataLength) {
        for(int i=0; i<dataLength; ++i) {
            byte[] expectedString=data[i].bytes;
            int  [MASK] =data[i].s.length();
            if(!trie.next(expectedString, 0,  [MASK] /2).matches()) {
                errln(""trie.next(up to middle of string)=BytesTrie.Result.NO_MATCH for ""+data[i].s);
                continue;
            }
            // Test that we stop properly at the end of the string.
            trie.next(expectedString,  [MASK] /2,  [MASK] );
            if(trie.next(0).matches()) {
                errln(""trie.next(string+NUL)!=BytesTrie.Result.NO_MATCH for ""+data[i].s);
            }
            trie.reset();
        }
    }

    private void checkIterator(BytesTrie trie, StringAndValue data[], int dataLength) {
        checkIterator(trie.iterator(), data, dataLength);
    }

    private void checkIterator(BytesTrie.Iterator iter, StringAndValue data[]) {
        checkIterator(iter, data, data.length);
    }

    private void checkIterator(BytesTrie.Iterator iter, StringAndValue data[], int dataLength) {
        for(int i=0; i<dataLength; ++i) {
            if(!iter.hasNext()) {
                errln(""trie iterator hasNext()=false for item ""+i+"": ""+data[i].s);
                break;
            }
            BytesTrie.Entry entry=iter.next();
            StringBuilder bytesString=new StringBuilder();
            for(int j=0; j<entry.bytesLength(); ++j) {
                bytesString.append((char)(entry.byteAt(j)&0xff));
            }
            if(!data[i].s.contentEquals(bytesString)) {
                errln(String.format(""trie iterator next().getString()=%s but expected %s for item %d"",
                                    bytesString, data[i].s, i));
            }
            if(entry.value!=data[i].value) {
                errln(String.format(""trie iterator next().getValue()=%d=0x%x but expected %d=0x%x for item %d: %s"",
                                    entry.value, entry.value,
                                    data[i].value, data[i].value,
                                    i, data[i].s));
            }
        }
        if(iter.hasNext()) {
            errln(""trie iterator hasNext()=true after all items"");
        }
        try {
            iter.next();
            errln(""trie iterator next() did not throw NoSuchElementException after all items"");
        } catch(NoSuchElementException e) {
            // good
        }
    }

    private BytesTrieBuilder builder_=new BytesTrieBuilder();
}
","stringLength
",strLen,strLen,index,stringLength,
"package java.util;

import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * An unbounded priority {@linkplain Queue queue} based on a priority heap.
 * The elements of the priority queue are ordered according to their
 * {@linkplain Comparable natural ordering}, or by a {@link Comparator}
 * provided at queue construction time, depending on which constructor is
 * used.  A priority queue does not permit {@code null} elements.
 * A priority queue relying on natural ordering also does not permit
 * insertion of non-comparable objects (doing so may result in
 * {@code ClassCastException}).
 *
 * <p>The <em>head</em> of this queue is the <em>least</em> element
 * with respect to the specified ordering.  If multiple elements are
 * tied for least value, the head is one of those elements -- ties are
 * broken arbitrarily.  The queue retrieval operations {@code poll},
 * {@code remove}, {@code peek}, and {@code element} access the
 * element at the head of the queue.
 *
 * <p>A priority queue is unbounded, but has an internal
 * <i>capacity</i> governing the size of an array used to store the
 * elements on the queue.  It is always at least as large as the queue
 * size.  As elements are added to a priority queue, its capacity
 * grows automatically.  The details of the growth policy are not
 * specified.
 *
 * <p>This class and its iterator implement all of the
 * <em>optional</em> methods of the {@link Collection} and {@link
 * Iterator} interfaces.  The Iterator provided in method {@link
 * #iterator()} and the Spliterator provided in method {@link #spliterator()}
 * are <em>not</em> guaranteed to traverse the elements of
 * the priority queue in any particular order. If you need ordered
 * traversal, consider using {@code Arrays.sort(pq.toArray())}.
 *
 * <p><strong>Note that this implementation is not synchronized.</strong>
 * Multiple threads should not access a {@code PriorityQueue}
 * instance concurrently if any of the threads modifies the queue.
 * Instead, use the thread-safe {@link
 * java.util.concurrent.PriorityBlockingQueue} class.
 *
 * <p>Implementation note: this implementation provides
 * O(log(n)) time for the enqueuing and dequeuing methods
 * ({@code offer}, {@code poll}, {@code remove()} and {@code add});
 * linear time for the {@code remove(Object)} and {@code contains(Object)}
 * methods; and constant time for the retrieval methods
 * ({@code peek}, {@code element}, and {@code size}).
 *
 * <p>This class is a member of the
 * <a href=""{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework"">
 * Java Collections Framework</a>.
 *
 * @since 1.5
 * @author Josh Bloch, Doug Lea
 * @param <E> the type of elements held in this queue
 */
@SuppressWarnings(""unchecked"")
public class PriorityQueue<E> extends AbstractQueue<E>
    implements java.io.Serializable {

    private static final long serialVersionUID = -7720805057305804111L;

    private static final int DEFAULT_INITIAL_CAPACITY = 11;

    /**
     * Priority queue represented as a balanced binary heap: the two
     * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The
     * priority queue is ordered by comparator, or by the elements'
     * natural ordering, if comparator is null: For each node n in the
     * heap and each descendant d of n, n <= d.  The element with the
     * lowest value is in queue[0], assuming the queue is nonempty.
     */
    transient Object[] queue; // non-private to simplify nested class access

    /**
     * The number of elements in the priority queue.
     */
    int size;

    /**
     * The comparator, or null if priority queue uses elements'
     * natural ordering.
     */
    private final Comparator<? super E> comparator;

    /**
     * The number of times this priority queue has been
     * <i>structurally modified</i>.  See AbstractList for gory details.
     */
    transient int modCount;     // non-private to simplify nested class access

    /**
     * Creates a {@code PriorityQueue} with the default initial
     * capacity (11) that orders its elements according to their
     * {@linkplain Comparable natural ordering}.
     */
    public PriorityQueue() {
        this(DEFAULT_INITIAL_CAPACITY, null);
    }

    /**
     * Creates a {@code PriorityQueue} with the specified initial
     * capacity that orders its elements according to their
     * {@linkplain Comparable natural ordering}.
     *
     * @param initialCapacity the initial capacity for this priority queue
     * @throws IllegalArgumentException if {@code initialCapacity} is less
     *         than 1
     */
    public PriorityQueue(int initialCapacity) {
        this(initialCapacity, null);
    }

    /**
     * Creates a {@code PriorityQueue} with the default initial capacity and
     * whose elements are ordered according to the specified comparator.
     *
     * @param  comparator the comparator that will be used to order this
     *         priority queue.  If {@code null}, the {@linkplain Comparable
     *         natural ordering} of the elements will be used.
     * @since 1.8
     */
    public PriorityQueue(Comparator<? super E> comparator) {
        this(DEFAULT_INITIAL_CAPACITY, comparator);
    }

    /**
     * Creates a {@code PriorityQueue} with the specified initial capacity
     * that orders its elements according to the specified comparator.
     *
     * @param  initialCapacity the initial capacity for this priority queue
     * @param  comparator the comparator that will be used to order this
     *         priority queue.  If {@code null}, the {@linkplain Comparable
     *         natural ordering} of the elements will be used.
     * @throws IllegalArgumentException if {@code initialCapacity} is
     *         less than 1
     */
    public PriorityQueue(int initialCapacity,
                         Comparator<? super E> comparator) {
        // Note: This restriction of at least one is not actually needed,
        // but continues for 1.5 compatibility
        if (initialCapacity < 1)
            throw new IllegalArgumentException();
        this.queue = new Object[initialCapacity];
        this.comparator = comparator;
    }

    /**
     * Creates a {@code PriorityQueue} containing the elements in the
     * specified collection.  If the specified collection is an instance of
     * a {@link SortedSet} or is another {@code PriorityQueue}, this
     * priority queue will be ordered according to the same ordering.
     * Otherwise, this priority queue will be ordered according to the
     * {@linkplain Comparable natural ordering} of its elements.
     *
     * @param  c the collection whose elements are to be placed
     *         into this priority queue
     * @throws ClassCastException if elements of the specified collection
     *         cannot be compared to one another according to the priority
     *         queue's ordering
     * @throws NullPointerException if the specified collection or any
     *         of its elements are null
     */
    public PriorityQueue(Collection<? extends E> c) {
        if (c instanceof SortedSet<?>) {
            SortedSet<? extends E> ss = (SortedSet<? extends E>) c;
            this.comparator = (Comparator<? super E>) ss.comparator();
            initElementsFromCollection(ss);
        }
        else if (c instanceof PriorityQueue<?>) {
            PriorityQueue<? extends E> pq = (PriorityQueue<? extends E>) c;
            this.comparator = (Comparator<? super E>) pq.comparator();
            initFromPriorityQueue(pq);
        }
        else {
            this.comparator = null;
            initFromCollection(c);
        }
    }

    /**
     * Creates a {@code PriorityQueue} containing the elements in the
     * specified priority queue.  This priority queue will be
     * ordered according to the same ordering as the given priority
     * queue.
     *
     * @param  c the priority queue whose elements are to be placed
     *         into this priority queue
     * @throws ClassCastException if elements of {@code c} cannot be
     *         compared to one another according to {@code c}'s
     *         ordering
     * @throws NullPointerException if the specified priority queue or any
     *         of its elements are null
     */
    public PriorityQueue(PriorityQueue<? extends E> c) {
        this.comparator = (Comparator<? super E>) c.comparator();
        initFromPriorityQueue(c);
    }

    /**
     * Creates a {@code PriorityQueue} containing the elements in the
     * specified sorted set.   This priority queue will be ordered
     * according to the same ordering as the given sorted set.
     *
     * @param  c the sorted set whose elements are to be placed
     *         into this priority queue
     * @throws ClassCastException if elements of the specified sorted
     *         set cannot be compared to one another according to the
     *         sorted set's ordering
     * @throws NullPointerException if the specified sorted set or any
     *         of its elements are null
     */
    public PriorityQueue(SortedSet<? extends E> c) {
        this.comparator = (Comparator<? super E>) c.comparator();
        initElementsFromCollection(c);
    }

    /** Ensures that queue[0] exists, helping peek() and poll(). */
    private static Object[] ensureNonEmpty(Object[] es) {
        return (es.length > 0) ? es : new Object[1];
    }

    private void initFromPriorityQueue(PriorityQueue<? extends E> c) {
        if (c.getClass() == PriorityQueue.class) {
            this.queue = ensureNonEmpty(c.toArray());
            this.size = c.size();
        } else {
            initFromCollection(c);
        }
    }

    private void initElementsFromCollection(Collection<? extends E> c) {
        Object[] es = c.toArray();
        int len = es.length;
        if (c.getClass() != ArrayList.class)
            es = Arrays.copyOf(es, len, Object[].class);
        if (len == 1 || this.comparator != null)
            for (Object e : es)
                if (e == null)
                    throw new NullPointerException();
        this.queue = ensureNonEmpty(es);
        this.size = len;
    }

    /**
     * Initializes queue array with elements from the given Collection.
     *
     * @param c the collection
     */
    private void initFromCollection(Collection<? extends E> c) {
        initElementsFromCollection(c);
        heapify();
    }

    /**
     * The maximum size of array to allocate.
     * Some VMs reserve some header words in an array.
     * Attempts to allocate larger arrays may result in
     * OutOfMemoryError: Requested array size exceeds VM limit
     */
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * Increases the capacity of the array.
     *
     * @param minCapacity the desired minimum capacity
     */
    private void grow(int minCapacity) {
        int oldCapacity = queue.length;
        // Double size if small; else grow by 50%
        int newCapacity = oldCapacity + ((oldCapacity < 64) ?
                                         (oldCapacity + 2) :
                                         (oldCapacity >> 1));
        // overflow-conscious code
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        queue = Arrays.copyOf(queue, newCapacity);
    }

    private static int hugeCapacity(int minCapacity) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity > MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    }

    /**
     * Inserts the specified element into this priority queue.
     *
     * @return {@code true} (as specified by {@link Collection#add})
     * @throws ClassCastException if the specified element cannot be
     *         compared with elements currently in this priority queue
     *         according to the priority queue's ordering
     * @throws NullPointerException if the specified element is null
     */
    public boolean add(E e) {
        return offer(e);
    }

    /**
     * Inserts the specified element into this priority queue.
     *
     * @return {@code true} (as specified by {@link Queue#offer})
     * @throws ClassCastException if the specified element cannot be
     *         compared with elements currently in this priority queue
     *         according to the priority queue's ordering
     * @throws NullPointerException if the specified element is null
     */
    public boolean offer(E e) {
        if (e == null)
            throw new NullPointerException();
        modCount++;
        int i = size;
        if (i >= queue.length)
            grow(i + 1);
        size = i + 1;
        if (i == 0)
            queue[0] = e;
        else
            siftUp(i, e);
        return true;
    }

    public E peek() {
        return (E) queue[0];
    }

    private int indexOf(Object o) {
        if (o != null) {
            final Object[] es = queue;
            for (int i = 0, n = size; i < n; i++)
                if (o.equals(es[i]))
                    return i;
        }
        return -1;
    }

    /**
     * Removes a single instance of the specified element from this queue,
     * if it is present.  More formally, removes an element {@code e} such
     * that {@code o.equals(e)}, if this queue contains one or more such
     * elements.  Returns {@code true} if and only if this queue contained
     * the specified element (or equivalently, if this queue changed as a
     * result of the call).
     *
     * @param o element to be removed from this queue, if present
     * @return {@code true} if this queue changed as a result of the call
     */
    public boolean remove(Object o) {
        int i = indexOf(o);
        if (i == -1)
            return false;
        else {
            removeAt(i);
            return true;
        }
    }

    /**
     * Identity-based version for use in Itr.remove.
     *
     * @param o element to be removed from this queue, if present
     */
    void removeEq(Object o) {
        final Object[] es = queue;
        for (int i = 0, n = size; i < n; i++) {
            if (o == es[i]) {
                removeAt(i);
                break;
            }
        }
    }

    /**
     * Returns {@code true} if this queue contains the specified element.
     * More formally, returns {@code true} if and only if this queue contains
     * at least one element {@code e} such that {@code o.equals(e)}.
     *
     * @param o object to be checked for containment in this queue
     * @return {@code true} if this queue contains the specified element
     */
    public boolean contains(Object o) {
        return indexOf(o) >= 0;
    }

    /**
     * Returns an array containing all of the elements in this queue.
     * The elements are in no particular order.
     *
     * <p>The returned array will be ""safe"" in that no references to it are
     * maintained by this queue.  (In other words, this method must allocate
     * a new array).  The caller is thus free to modify the returned array.
     *
     * <p>This method acts as bridge between array-based and collection-based
     * APIs.
     *
     * @return an array containing all of the elements in this queue
     */
    public Object[] toArray() {
        return Arrays.copyOf(queue, size);
    }

    /**
     * Returns an array containing all of the elements in this queue; the
     * runtime type of the returned array is that of the specified array.
     * The returned array elements are in no particular order.
     * If the queue fits in the specified array, it is returned therein.
     * Otherwise, a new array is allocated with the runtime type of the
     * specified array and the size of this queue.
     *
     * <p>If the queue fits in the specified array with room to spare
     * (i.e., the array has more elements than the queue), the element in
     * the array immediately following the end of the collection is set to
     * {@code null}.
     *
     * <p>Like the {@link #toArray()} method, this method acts as bridge between
     * array-based and collection-based APIs.  Further, this method allows
     * precise control over the runtime type of the output array, and may,
     * under certain circumstances, be used to save allocation costs.
     *
     * <p>Suppose {@code x} is a queue known to contain only strings.
     * The following code can be used to dump the queue into a newly
     * allocated array of {@code String}:
     *
     * <pre> {@code String[] y = x.toArray(new String[0]);}</pre>
     *
     * Note that {@code toArray(new Object[0])} is identical in function to
     * {@code toArray()}.
     *
     * @param a the array into which the elements of the queue are to
     *          be stored, if it is big enough; otherwise, a new array of the
     *          same runtime type is allocated for this purpose.
     * @return an array containing all of the elements in this queue
     * @throws ArrayStoreException if the runtime type of the specified array
     *         is not a supertype of the runtime type of every element in
     *         this queue
     * @throws NullPointerException if the specified array is null
     */
    public <T> T[] toArray(T[] a) {
        final int size = this.size;
        if (a.length < size)
            // Make a new array of a's runtime type, but my contents:
            return (T[]) Arrays.copyOf(queue, size, a.getClass());
        System.arraycopy(queue, 0, a, 0, size);
        if (a.length > size)
            a[size] = null;
        return a;
    }

    /**
     * Returns an iterator over the elements in this queue. The iterator
     * does not return the elements in any particular order.
     *
     * @return an iterator over the elements in this queue
     */
    public Iterator<E> iterator() {
        return new Itr();
    }

    private final class Itr implements Iterator<E> {
        /**
         * Index (into queue array) of element to be returned by
         * subsequent call to next.
         */
        private int cursor;

        /**
         * Index of element returned by most recent call to next,
         * unless that element came from the forgetMeNot list.
         * Set to -1 if element is deleted by a call to remove.
         */
        private int lastRet = -1;

        /**
         * A queue of elements that were moved from the unvisited portion of
         * the heap into the visited portion as a result of ""unlucky"" element
         * removals during the iteration.  (Unlucky element removals are those
         * that require a siftup instead of a siftdown.)  We must visit all of
         * the elements in this list to complete the iteration.  We do this
         * after we've completed the ""normal"" iteration.
         *
         * We expect that most iterations, even those involving removals,
         * will not need to store elements in this field.
         */
        private ArrayDeque<E> forgetMeNot;

        /**
         * Element returned by the most recent call to next iff that
         * element was drawn from the forgetMeNot list.
         */
        private E lastRetElt;

        /**
         * The modCount value that the iterator believes that the backing
         * Queue should have.  If this expectation is violated, the iterator
         * has detected concurrent modification.
         */
        private int expectedModCount = modCount;

        Itr() {}                        // prevent access constructor creation

        public boolean hasNext() {
            return cursor < size ||
                (forgetMeNot != null && !forgetMeNot.isEmpty());
        }

        public E next() {
            if (expectedModCount != modCount)
                throw new ConcurrentModificationException();
            if (cursor < size)
                return (E) queue[lastRet = cursor++];
            if (forgetMeNot != null) {
                lastRet = -1;
                lastRetElt = forgetMeNot.poll();
                if (lastRetElt != null)
                    return lastRetElt;
            }
            throw new NoSuchElementException();
        }

        public void remove() {
            if (expectedModCount != modCount)
                throw new ConcurrentModificationException();
            if (lastRet != -1) {
                E moved = PriorityQueue.this.removeAt(lastRet);
                lastRet = -1;
                if (moved == null)
                    cursor--;
                else {
                    if (forgetMeNot == null)
                        forgetMeNot = new ArrayDeque<>();
                    forgetMeNot.add(moved);
                }
            } else if (lastRetElt != null) {
                PriorityQueue.this.removeEq(lastRetElt);
                lastRetElt = null;
            } else {
                throw new IllegalStateException();
            }
            expectedModCount = modCount;
        }
    }

    public int size() {
        return size;
    }

    /**
     * Removes all of the elements from this priority queue.
     * The queue will be empty after this call returns.
     */
    public void clear() {
        modCount++;
        final Object[] es = queue;
        for (int i = 0, n = size; i < n; i++)
            es[i] = null;
        size = 0;
    }

    public E poll() {
        final Object[] es;
        final E result;

        if ((result = (E) ((es = queue)[0])) != null) {
            modCount++;
            final int n;
            final E x = (E) es[(n = --size)];
            es[n] = null;
            if (n > 0) {
                final Comparator<? super E> cmp;
                if ((cmp = comparator) == null)
                    siftDownComparable(0, x, es, n);
                else
                    siftDownUsingComparator(0, x, es, n, cmp);
            }
        }
        return result;
    }

    /**
     * Removes the ith element from queue.
     *
     * Normally this method leaves the elements at up to i-1,
     * inclusive, untouched.  Under these circumstances, it returns
     * null.  Occasionally, in order to maintain the heap invariant,
     * it must swap a later element of the list with one earlier than
     * i.  Under these circumstances, this method returns the element
     * that was previously at the end of the list and is now at some
     * position before i. This fact is used by iterator.remove so as to
     * avoid missing traversing elements.
     */
    E removeAt(int i) {
        // assert i >= 0 && i < size;
        final Object[] es = queue;
        modCount++;
        int s = --size;
        if (s == i) // removed last element
            es[i] = null;
        else {
            E moved = (E) es[s];
            es[s] = null;
            siftDown(i, moved);
            if (es[i] == moved) {
                siftUp(i, moved);
                if (es[i] != moved)
                    return moved;
            }
        }
        return null;
    }

    /**
     * Inserts item x at position k, maintaining heap invariant by
     * promoting x up the tree until it is greater than or equal to
     * its  [MASK] , or is the root.
     *
     * To simplify and speed up coercions and comparisons, the
     * Comparable and Comparator versions are separated into different
     * methods that are otherwise identical. (Similarly for siftDown.)
     *
     * @param k the position to fill
     * @param x the item to insert
     */
    private void siftUp(int k, E x) {
        if (comparator != null)
            siftUpUsingComparator(k, x, queue, comparator);
        else
            siftUpComparable(k, x, queue);
    }

    private static <T> void siftUpComparable(int k, T x, Object[] es) {
        Comparable<? super T> key = (Comparable<? super T>) x;
        while (k > 0) {
            int  [MASK]  = (k - 1) >>> 1;
            Object e = es[ [MASK] ];
            if (key.compareTo((T) e) >= 0)
                break;
            es[k] = e;
            k =  [MASK] ;
        }
        es[k] = key;
    }

    private static <T> void siftUpUsingComparator(
        int k, T x, Object[] es, Comparator<? super T> cmp) {
        while (k > 0) {
            int  [MASK]  = (k - 1) >>> 1;
            Object e = es[ [MASK] ];
            if (cmp.compare(x, (T) e) >= 0)
                break;
            es[k] = e;
            k =  [MASK] ;
        }
        es[k] = x;
    }

    /**
     * Inserts item x at position k, maintaining heap invariant by
     * demoting x down the tree repeatedly until it is less than or
     * equal to its children or is a leaf.
     *
     * @param k the position to fill
     * @param x the item to insert
     */
    private void siftDown(int k, E x) {
        if (comparator != null)
            siftDownUsingComparator(k, x, queue, size, comparator);
        else
            siftDownComparable(k, x, queue, size);
    }

    private static <T> void siftDownComparable(int k, T x, Object[] es, int n) {
        // assert n > 0;
        Comparable<? super T> key = (Comparable<? super T>)x;
        int half = n >>> 1;           // loop while a non-leaf
        while (k < half) {
            int child = (k << 1) + 1; // assume left child is least
            Object c = es[child];
            int right = child + 1;
            if (right < n &&
                ((Comparable<? super T>) c).compareTo((T) es[right]) > 0)
                c = es[child = right];
            if (key.compareTo((T) c) <= 0)
                break;
            es[k] = c;
            k = child;
        }
        es[k] = key;
    }

    private static <T> void siftDownUsingComparator(
        int k, T x, Object[] es, int n, Comparator<? super T> cmp) {
        // assert n > 0;
        int half = n >>> 1;
        while (k < half) {
            int child = (k << 1) + 1;
            Object c = es[child];
            int right = child + 1;
            if (right < n && cmp.compare((T) c, (T) es[right]) > 0)
                c = es[child = right];
            if (cmp.compare(x, (T) c) <= 0)
                break;
            es[k] = c;
            k = child;
        }
        es[k] = x;
    }

    /**
     * Establishes the heap invariant (described above) in the entire tree,
     * assuming nothing about the order of the elements prior to the call.
     * This classic algorithm due to Floyd (1964) is known to be O(size).
     */
    private void heapify() {
        final Object[] es = queue;
        int n = size, i = (n >>> 1) - 1;
        final Comparator<? super E> cmp;
        if ((cmp = comparator) == null)
            for (; i >= 0; i--)
                siftDownComparable(i, (E) es[i], es, n);
        else
            for (; i >= 0; i--)
                siftDownUsingComparator(i, (E) es[i], es, n, cmp);
    }

    /**
     * Returns the comparator used to order the elements in this
     * queue, or {@code null} if this queue is sorted according to
     * the {@linkplain Comparable natural ordering} of its elements.
     *
     * @return the comparator used to order this queue, or
     *         {@code null} if this queue is sorted according to the
     *         natural ordering of its elements
     */
    public Comparator<? super E> comparator() {
        return comparator;
    }

    /**
     * Saves this queue to a stream (that is, serializes it).
     *
     * @param s the stream
     * @throws java.io.IOException if an I/O error occurs
     * @serialData The length of the array backing the instance is
     *             emitted (int), followed by all of its elements
     *             (each an {@code Object}) in the proper order.
     */
    private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out element count, and any hidden stuff
        s.defaultWriteObject();

        // Write out array length, for compatibility with 1.5 version
        s.writeInt(Math.max(2, size + 1));

        // Write out all elements in the ""proper order"".
        final Object[] es = queue;
        for (int i = 0, n = size; i < n; i++)
            s.writeObject(es[i]);
    }

    /**
     * Reconstitutes the {@code PriorityQueue} instance from a stream
     * (that is, deserializes it).
     *
     * @param s the stream
     * @throws ClassNotFoundException if the class of a serialized object
     *         could not be found
     * @throws java.io.IOException if an I/O error occurs
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {
        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // Read in (and discard) array length
        s.readInt();

        queue = new Object[size];

        // Read in all elements.
        for (int i = 0; i < size; i++)
            queue[i] = s.readObject();

        // Elements are guaranteed to be in ""proper order"", but the
        // spec has never explained what that might be.
        heapify();
    }

    /**
     * Creates a <em><a href=""Spliterator.html#binding"">late-binding</a></em>
     * and <em>fail-fast</em> {@link Spliterator} over the elements in this
     * queue. The spliterator does not traverse elements in any particular order
     * (the {@link Spliterator#ORDERED ORDERED} characteristic is not reported).
     *
     * <p>The {@code Spliterator} reports {@link Spliterator#SIZED},
     * {@link Spliterator#SUBSIZED}, and {@link Spliterator#NONNULL}.
     * Overriding implementations should document the reporting of additional
     * characteristic values.
     *
     * @return a {@code Spliterator} over the elements in this queue
     * @since 1.8
     */
    public final Spliterator<E> spliterator() {
        return new PriorityQueueSpliterator<>(this, 0, -1, 0);
    }

    static final class PriorityQueueSpliterator<E> implements Spliterator<E> {
        /*
         * This is very similar to ArrayList Spliterator, except for
         * extra null checks.
         */
        private final PriorityQueue<E> pq;
        private int index;            // current index, modified on advance/split
        private int fence;            // -1 until first use
        private int expectedModCount; // initialized when fence set

        /** Creates new spliterator covering the given range. */
        PriorityQueueSpliterator(PriorityQueue<E> pq, int origin, int fence,
                                 int expectedModCount) {
            this.pq = pq;
            this.index = origin;
            this.fence = fence;
            this.expectedModCount = expectedModCount;
        }

        private int getFence() { // initialize fence to size on first use
            int hi;
            if ((hi = fence) < 0) {
                expectedModCount = pq.modCount;
                hi = fence = pq.size;
            }
            return hi;
        }

        public PriorityQueueSpliterator<E> trySplit() {
            int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;
            return (lo >= mid) ? null :
                new PriorityQueueSpliterator<>(pq, lo, index = mid,
                                               expectedModCount);
        }

        @SuppressWarnings(""unchecked"")
        public void forEachRemaining(Consumer<? super E> action) {
            int i, hi, mc; // hoist accesses and checks from loop
            PriorityQueue<E> q; Object[] a;
            if (action == null)
                throw new NullPointerException();
            if ((q = pq) != null && (a = q.queue) != null) {
                if ((hi = fence) < 0) {
                    mc = q.modCount;
                    hi = q.size;
                }
                else
                    mc = expectedModCount;
                if ((i = index) >= 0 && (index = hi) <= a.length) {
                    for (E e;; ++i) {
                        if (i < hi) {
                            if ((e = (E) a[i]) == null) // must be CME
                                break;
                            action.accept(e);
                        }
                        else if (q.modCount != mc)
                            break;
                        else
                            return;
                    }
                }
            }
            throw new ConcurrentModificationException();
        }

        public boolean tryAdvance(Consumer<? super E> action) {
            if (action == null)
                throw new NullPointerException();
            int hi = getFence(), lo = index;
            if (lo >= 0 && lo < hi) {
                index = lo + 1;
                @SuppressWarnings(""unchecked"") E e = (E)pq.queue[lo];
                if (e == null)
                    throw new ConcurrentModificationException();
                action.accept(e);
                if (pq.modCount != expectedModCount)
                    throw new ConcurrentModificationException();
                return true;
            }
            return false;
        }

        public long estimateSize() {
            return (long) (getFence() - index);
        }

        public int characteristics() {
            return Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.NONNULL;
        }
    }
    
    
    /**
     * @throws NullPointerException {@inheritDoc}
     */
    public boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        return bulkRemove(filter);
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     */
    public boolean removeAll(Collection<?> c) {
        Objects.requireNonNull(c);
        return bulkRemove(e -> c.contains(e));
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     */
    public boolean retainAll(Collection<?> c) {
        Objects.requireNonNull(c);
        return bulkRemove(e -> !c.contains(e));
    }

    // A tiny bit set implementation

    private static long[] nBits(int n) {
        return new long[((n - 1) >> 6) + 1];
    }
    private static void setBit(long[] bits, int i) {
        bits[i >> 6] |= 1L << i;
    }
    private static boolean isClear(long[] bits, int i) {
        return (bits[i >> 6] & (1L << i)) == 0;
    }

    /** Implementation of bulk remove methods. */
    private boolean bulkRemove(Predicate<? super E> filter) {
        final int expectedModCount = ++modCount;
        final Object[] es = queue;
        final int end = size;
        int i;
        // Optimize for initial run of survivors
        for (i = 0; i < end && !filter.test((E) es[i]); i++)
            ;
        if (i >= end) {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
            return false;
        }
        // Tolerate predicates that reentrantly access the collection for
        // read (but writers still get CME), so traverse once to find
        // elements to delete, a second pass to physically expunge.
        final int beg = i;
        final long[] deathRow = nBits(end - beg);
        deathRow[0] = 1L;   // set bit 0
        for (i = beg + 1; i < end; i++)
            if (filter.test((E) es[i]))
                setBit(deathRow, i - beg);
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        int w = beg;
        for (i = beg; i < end; i++)
            if (isClear(deathRow, i - beg))
                es[w++] = es[i];
        for (i = size = w; i < end; i++)
            es[i] = null;
        heapify();
        return true;
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     */
    public void forEach(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        final int expectedModCount = modCount;
        final Object[] es = queue;
        for (int i = 0, n = size; i < n; i++)
            action.accept((E) es[i]);
        if (expectedModCount != modCount)
            throw new ConcurrentModificationException();
    }
}
","parent
",newK,next,element,child,
"
package org.apache.dubbo.metrics.observation;

import org.apache.dubbo.common.URL;
import org.apache.dubbo.rpc.AppResponse;
import org.apache.dubbo.rpc.Filter;
import org.apache.dubbo.rpc.Invocation;
import org.apache.dubbo.rpc.Invoker;
import org.apache.dubbo.rpc.Result;
import org.apache.dubbo.rpc.RpcContext;
import org.apache.dubbo.rpc.RpcException;
import org.apache.dubbo.rpc.model.ApplicationModel;

import io.micrometer.common.KeyValues;
import io.micrometer.core.tck.MeterRegistryAssert;
import io.micrometer.tracing.Span;
import io.micrometer.tracing.Tracer;
import io.micrometer.tracing.test.simple.SpansAssert;
import org.assertj.core.api.BDDAssertions;

class ObservationReceiverFilterTest extends AbstractObservationFilterTest {

    @Override
    public SampleTestRunnerConsumer yourCode() {
        return (buildingBlocks, meterRegistry) -> {
            setupConfig();
            setupAttachments(buildingBlocks.getTracer());
            invoker = new AssertingInvoker(buildingBlocks.getTracer());

            ObservationReceiverFilter  [MASK]  = (ObservationReceiverFilter) filter;
             [MASK] .invoke(invoker, invocation);
             [MASK] .onResponse(null, invoker, invocation);

            MeterRegistryAssert.then(meterRegistry)
                .hasMeterWithNameAndTags(""rpc.server.duration"", KeyValues.of(""rpc.method"", ""mockMethod"", ""rpc.service"", ""DemoService"", ""rpc.system"", ""apache_dubbo""));
            SpansAssert.then(buildingBlocks.getFinishedSpans())
                .hasASpanWithNameIgnoreCase(""DemoService/mockMethod"", spanAssert ->
                    spanAssert
                        .hasTag(""rpc.method"", ""mockMethod"")
                        .hasTag(""rpc.service"", ""DemoService"")
                        .hasTag(""rpc.system"", ""apache_dubbo""));
        };
    }

    void setupAttachments(Tracer tracer) {
        RpcContext.getServerAttachment().setUrl(URL.valueOf(""test://test:11/test?accesslog=true&group=dubbo&version=1.1&side=consumer""));
        RpcContext.getServerAttachment().setMethodName(""foo"");
        RpcContext.getServerAttachment().setRemoteAddress(""foo.bar.com"", 8080);
        RpcContext.getServerAttachment().setAttachment(""X-B3-TraceId"", tracer.currentSpan().context().traceId());
        RpcContext.getServerAttachment().setAttachment(""X-B3-SpanId"", tracer.currentSpan().context().spanId());
        RpcContext.getServerAttachment().setAttachment(""X-B3-Sampled"", ""1"");
    }

    @Override
    Filter createFilter(ApplicationModel applicationModel) {
        return new ObservationReceiverFilter(applicationModel);
    }

    static class AssertingInvoker implements Invoker {

        private final String expectedTraceId;

        private final String parentSpanId;

        private final Tracer tracer;

        AssertingInvoker(Tracer tracer) {
            this.tracer = tracer;
            this.expectedTraceId = tracer.currentSpan().context().traceId();
            this.parentSpanId = tracer.currentSpan().context().spanId();
        }

        @Override
        public URL getUrl() {
            return null;
        }

        @Override
        public boolean isAvailable() {
            return true;
        }

        @Override
        public void destroy() {

        }

        @Override
        public Class getInterface() {
            return AssertingInvoker.class;
        }

        @Override
        public Result invoke(Invocation invocation) throws RpcException {
            Span span = this.tracer.currentSpan();
            BDDAssertions.then(span.context().traceId())
                .as(""Should propagate the trace id from the attributes"")
                .isEqualTo(this.expectedTraceId);
            BDDAssertions.then(span.context().spanId())
                .as(""A child span must be created"")
                .isNotEqualTo(this.parentSpanId);
            return new AppResponse(""OK"");
        }
    }
}
","senderFilter
",obFilter,ObservationReFilter,observationFilter,filter,
"

package com.badlogic.gdx.tests;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.InputAdapter;
import com.badlogic.gdx.InputMultiplexer;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.math.Interpolation;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.List;
import com.badlogic.gdx.scenes.scene2d.ui.ScrollPane;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.tests.utils.GdxTest;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.reflect.ClassReflection;
import com.badlogic.gdx.utils.reflect.Field;
import com.badlogic.gdx.utils.viewport.ScreenViewport;

public class InterpolationTest extends GdxTest {
        Stage stage;
        private Skin skin;
        private Table table;
        List<String> list;
        String interpolationNames[], selectedInterpolation;
        private ShapeRenderer renderer;
        float graphSize, steps, time = 0, duration = 2.5f;
        Vector2 startPosition = new Vector2(), targetPosition = new Vector2(), position = new Vector2();

        /** resets {@link #startPosition} and {@link #targetPosition} */
        void resetPositions () {
                startPosition.set(stage.getWidth() - stage.getWidth() / 5f, stage.getHeight() - stage.getHeight() / 5f);
                targetPosition.set(startPosition.x, stage.getHeight() / 5f);
        }

        /** @return the {@link #position} with the {@link #selectedInterpolation interpolation} applied */
        Vector2 getPosition (float time) {
                position.set(targetPosition);
                position.sub(startPosition);
                position.scl(getInterpolation(selectedInterpolation).apply(time / duration));
                position.add(startPosition);
                return position;
        }

        /** @return the {@link #selectedInterpolation selected} interpolation */
        private Interpolation getInterpolation (String name) {
                try {
                        return (Interpolation)ClassReflection.getField(Interpolation.class, name).get(null);
                } catch (Exception e) {
                        throw new RuntimeException(e);
                }
        }

        @Override
        public void create () {
                Gdx.gl.glClearColor(.3f, .3f, .3f, 1);
                renderer = new ShapeRenderer();

                skin = new Skin(Gdx.files.internal(""data/uiskin.json""));

                stage = new Stage(new ScreenViewport());
                resetPositions();

                Field[] interpolationFields = ClassReflection.getFields(Interpolation.class);

                // see how many fields are actually interpolations (for safety; other fields may be added with future)
                int interpolationMembers = 0;
                for (int i = 0; i < interpolationFields.length; i++)
                        if (ClassReflection.isAssignableFrom(Interpolation.class, interpolationFields[i].getDeclaringClass()))
                                interpolationMembers++;

                // get interpolation names
                interpolationNames = new String[interpolationMembers];
                for (int i = 0; i < interpolationFields.length; i++)
                        if (ClassReflection.isAssignableFrom(Interpolation.class, interpolationFields[i].getDeclaringClass()))
                                interpolationNames[i] = interpolationFields[i].getName();
                selectedInterpolation = interpolationNames[0];

                list = new List(skin);
                list.setItems(interpolationNames);
                list.addListener(new ChangeListener() {
                        public void changed (ChangeEvent event, Actor actor) {
                                selectedInterpolation = list.getSelected();
                                time = 0;
                                resetPositions();
                        }
                });

                ScrollPane scroll = new ScrollPane(list, skin);
                scroll.setFadeScrollBars(false);
                scroll.setScrollingDisabled(true, false);

                table = new Table();
                table.setFillParent(true);
                table.add(scroll).expandX().left().width(100);
                stage.addActor(table);

                Gdx.input.setInputProcessor(new InputMultiplexer(new InputAdapter() {
                        public boolean scrolled (float amountX, float amountY) {
                                if (!Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)) return false;
                                duration -= amountY / 15f;
                                duration = MathUtils.clamp(duration, 0, Float.POSITIVE_INFINITY);
                                return true;
                        }

                }, stage, new InputAdapter() {
                        public boolean touchDown (int screenX, int screenY, int pointer, int button) {
                                if (!Float.isNaN(time)) // if ""walking"" was interrupted by this touch down event
                                        startPosition.set(getPosition(time)); // set startPosition to the current position
                                targetPosition.set(stage.screenToStageCoordinates(targetPosition.set(screenX, screenY)));
                                time = 0;
                                return true;
                        }

                }));
        }

        public void render () {
                Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

                float bottomLeftX = Gdx.graphics.getWidth() / 2 - graphSize / 2, bottomLeftY = Gdx.graphics.getHeight() / 2 - graphSize / 2;

                // only show up to two decimals
                String text = String.valueOf(duration);
                if (text.length() > 4) text = text.substring(0, text.lastIndexOf('.') + 3);
                text = ""duration: "" + text + "" s (ctrl + scroll to change)"";
                stage.getBatch().begin();
                list.getStyle().font.draw(stage.getBatch(), text, bottomLeftX + graphSize / 2,
                        bottomLeftY + graphSize + list.getStyle().font.getLineHeight(), 0, Align.center, false);
                stage.getBatch().end();

                renderer.begin(ShapeType.Line);
                renderer.rect(bottomLeftX, bottomLeftY, graphSize, graphSize); // graph bounds
                float lastX = bottomLeftX, lastY = bottomLeftY;
                for (float step = 0; step <= steps; step++) {
                        Interpolation interpolation = getInterpolation(selectedInterpolation);
                        float  [MASK]  = step / steps;
                        float x = bottomLeftX + graphSize *  [MASK] , y = bottomLeftY + graphSize * interpolation.apply( [MASK] );
                        renderer.line(lastX, lastY, x, y);
                        lastX = x;
                        lastY = y;
                }
                time += Gdx.graphics.getDeltaTime();
                if (time > duration) {
                        time = Float.NaN; // stop ""walking""
                        startPosition.set(targetPosition); // set startPosition to targetPosition for next click
                }
                // draw time marker
                renderer.line(bottomLeftX + graphSize * time / duration, bottomLeftY, bottomLeftX + graphSize * time / duration,
                        bottomLeftY + graphSize);
                // draw path
                renderer.setColor(Color.GRAY);
                renderer.line(startPosition, targetPosition);
                renderer.setColor(Color.WHITE);
                renderer.end();

                // draw the position
                renderer.begin(ShapeType.Filled);
                if (!Float.isNaN(time)) // don't mess up position if time is NaN
                        getPosition(time);
                renderer.circle(position.x, position.y, 7);
                renderer.end();

                stage.act();
                stage.draw();
        }

        public void resize (int width, int height) {
                stage.getViewport().update(width, height, true);
                table.invalidateHierarchy();

                renderer.setProjectionMatrix(stage.getViewport().getCamera().combined);

                graphSize = 0.75f * Math.min(stage.getViewport().getWorldWidth(), stage.getViewport().getWorldHeight());
                steps = graphSize * 0.5f;
        }

        public void dispose () {
                stage.dispose();
                skin.dispose();
        }
}
","percent
",percentOffset,percentOffset,progress,t,
"package com.badlogic.gdx.tests;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.InputAdapter;
import com.badlogic.gdx.InputMultiplexer;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.math.Interpolation;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.List;
import com.badlogic.gdx.scenes.scene2d.ui.ScrollPane;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.tests.utils.GdxTest;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.reflect.ClassReflection;
import com.badlogic.gdx.utils.reflect.Field;
import com.badlogic.gdx.utils.viewport.ScreenViewport;

public class InterpolationTest extends GdxTest {
        Stage stage;
        private Skin skin;
        private Table table;
        List<String> list;
        String interpolationNames[], selectedInterpolation;
        private ShapeRenderer renderer;
        float graphSize, steps, time = 0, duration = 2.5f;
        Vector2 startPosition = new Vector2(), targetPosition = new Vector2(), position = new Vector2();

        /** resets {@link #startPosition} and {@link #targetPosition} */
        void resetPositions () {
                startPosition.set(stage.getWidth() - stage.getWidth() / 5f, stage.getHeight() - stage.getHeight() / 5f);
                targetPosition.set(startPosition.x, stage.getHeight() / 5f);
        }

        /** @return the {@link #position} with the {@link #selectedInterpolation interpolation} applied */
        Vector2 getPosition (float time) {
                position.set(targetPosition);
                position.sub(startPosition);
                position.scl(getInterpolation(selectedInterpolation).apply(time / duration));
                position.add(startPosition);
                return position;
        }

        /** @return the {@link #selectedInterpolation selected} interpolation */
        private Interpolation getInterpolation (String name) {
                try {
                        return (Interpolation)ClassReflection.getField(Interpolation.class, name).get(null);
                } catch (Exception e) {
                        throw new RuntimeException(e);
                }
        }

        @Override
        public void create () {
                Gdx.gl.glClearColor(.3f, .3f, .3f, 1);
                renderer = new ShapeRenderer();

                skin = new Skin(Gdx.files.internal(""data/uiskin.json""));

                stage = new Stage(new ScreenViewport());
                resetPositions();

                Field[] interpolationFields = ClassReflection.getFields(Interpolation.class);

                // see how many fields are actually interpolations (for safety; other fields may be added with future)
                int  [MASK]  = 0;
                for (int i = 0; i < interpolationFields.length; i++)
                        if (ClassReflection.isAssignableFrom(Interpolation.class, interpolationFields[i].getDeclaringClass()))
                                 [MASK] ++;

                // get interpolation names
                interpolationNames = new String[ [MASK] ];
                for (int i = 0; i < interpolationFields.length; i++)
                        if (ClassReflection.isAssignableFrom(Interpolation.class, interpolationFields[i].getDeclaringClass()))
                                interpolationNames[i] = interpolationFields[i].getName();
                selectedInterpolation = interpolationNames[0];

                list = new List(skin);
                list.setItems(interpolationNames);
                list.addListener(new ChangeListener() {
                        public void changed (ChangeEvent event, Actor actor) {
                                selectedInterpolation = list.getSelected();
                                time = 0;
                                resetPositions();
                        }
                });

                ScrollPane scroll = new ScrollPane(list, skin);
                scroll.setFadeScrollBars(false);
                scroll.setScrollingDisabled(true, false);

                table = new Table();
                table.setFillParent(true);
                table.add(scroll).expandX().left().width(100);
                stage.addActor(table);

                Gdx.input.setInputProcessor(new InputMultiplexer(new InputAdapter() {
                        public boolean scrolled (float amountX, float amountY) {
                                if (!Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)) return false;
                                duration -= amountY / 15f;
                                duration = MathUtils.clamp(duration, 0, Float.POSITIVE_INFINITY);
                                return true;
                        }

                }, stage, new InputAdapter() {
                        public boolean touchDown (int screenX, int screenY, int pointer, int button) {
                                if (!Float.isNaN(time)) // if ""walking"" was interrupted by this touch down event
                                        startPosition.set(getPosition(time)); // set startPosition to the current position
                                targetPosition.set(stage.screenToStageCoordinates(targetPosition.set(screenX, screenY)));
                                time = 0;
                                return true;
                        }

                }));
        }

        public void render () {
                Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

                float bottomLeftX = Gdx.graphics.getWidth() / 2 - graphSize / 2, bottomLeftY = Gdx.graphics.getHeight() / 2 - graphSize / 2;

                // only show up to two decimals
                String text = String.valueOf(duration);
                if (text.length() > 4) text = text.substring(0, text.lastIndexOf('.') + 3);
                text = ""duration: "" + text + "" s (ctrl + scroll to change)"";
                stage.getBatch().begin();
                list.getStyle().font.draw(stage.getBatch(), text, bottomLeftX + graphSize / 2,
                        bottomLeftY + graphSize + list.getStyle().font.getLineHeight(), 0, Align.center, false);
                stage.getBatch().end();

                renderer.begin(ShapeType.Line);
                renderer.rect(bottomLeftX, bottomLeftY, graphSize, graphSize); // graph bounds
                float lastX = bottomLeftX, lastY = bottomLeftY;
                for (float step = 0; step <= steps; step++) {
                        Interpolation interpolation = getInterpolation(selectedInterpolation);
                        float percent = step / steps;
                        float x = bottomLeftX + graphSize * percent, y = bottomLeftY + graphSize * interpolation.apply(percent);
                        renderer.line(lastX, lastY, x, y);
                        lastX = x;
                        lastY = y;
                }
                time += Gdx.graphics.getDeltaTime();
                if (time > duration) {
                        time = Float.NaN; // stop ""walking""
                        startPosition.set(targetPosition); // set startPosition to targetPosition for next click
                }
                // draw time marker
                renderer.line(bottomLeftX + graphSize * time / duration, bottomLeftY, bottomLeftX + graphSize * time / duration,
                        bottomLeftY + graphSize);
                // draw path
                renderer.setColor(Color.GRAY);
                renderer.line(startPosition, targetPosition);
                renderer.setColor(Color.WHITE);
                renderer.end();

                // draw the position
                renderer.begin(ShapeType.Filled);
                if (!Float.isNaN(time)) // don't mess up position if time is NaN
                        getPosition(time);
                renderer.circle(position.x, position.y, 7);
                renderer.end();

                stage.act();
                stage.draw();
        }

        public void resize (int width, int height) {
                stage.getViewport().update(width, height, true);
                table.invalidateHierarchy();

                renderer.setProjectionMatrix(stage.getViewport().getCamera().combined);

                graphSize = 0.75f * Math.min(stage.getViewport().getWorldWidth(), stage.getViewport().getWorldHeight());
                steps = graphSize * 0.5f;
        }

        public void dispose () {
                stage.dispose();
                skin.dispose();
        }
}
","interpolationMembers
",numCount,interpolationsCount,interpolationCount,interpolationNames,
"
package org.apache.dubbo.rpc.model;

import org.apache.dubbo.common.utils.ClassUtils;
import org.apache.dubbo.rpc.support.DemoService;
import org.apache.dubbo.rpc.support.DemoServiceImpl;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.Collection;
import java.util.List;
import java.util.Set;

/**
 * {@link ServiceRepository}
 */
class ServiceRepositoryTest {
    private FrameworkModel frameworkModel;
    private ApplicationModel applicationModel;
    private ModuleModel moduleModel;

    @BeforeEach
    public void setUp() {
        frameworkModel = new FrameworkModel();
        applicationModel = frameworkModel.newApplication();
        moduleModel = applicationModel.newModule();
    }

    @AfterEach
    public void reset() {
        frameworkModel.destroy();
    }

    @Test
    void test() {
        // verify BuiltinService
        Set<BuiltinServiceDetector>  [MASK] 
            = applicationModel.getExtensionLoader(BuiltinServiceDetector.class).getSupportedExtensionInstances();
        ModuleServiceRepository moduleServiceRepository = applicationModel.getInternalModule().getServiceRepository();
        List<ServiceDescriptor> allServices = moduleServiceRepository.getAllServices();
        Assertions.assertEquals(allServices.size(),  [MASK] .size());

        ModuleServiceRepository repository = moduleModel.getServiceRepository();
        ServiceMetadata serviceMetadata = new ServiceMetadata(DemoService.class.getName(), null, null, DemoService.class);
        ServiceDescriptor serviceDescriptor = repository.registerService(DemoService.class);

        // registerConsumer
        ConsumerModel consumerModel = new ConsumerModel(
            serviceMetadata.getServiceKey(), new DemoServiceImpl(), serviceDescriptor,
            moduleModel, serviceMetadata, null, ClassUtils.getClassLoader(DemoService.class));
        repository.registerConsumer(consumerModel);

        // registerProvider
        ProviderModel providerModel = new ProviderModel(DemoService.class.getName(),
            new DemoServiceImpl(),
            serviceDescriptor,
            moduleModel,
            serviceMetadata, ClassUtils.getClassLoader(DemoService.class));
        repository.registerProvider(providerModel);

        // verify allProviderModels, allConsumerModels
        ServiceRepository serviceRepository = applicationModel.getApplicationServiceRepository();
        Collection<ProviderModel> providerModels = serviceRepository.allProviderModels();
        Assertions.assertEquals(providerModels.size(), 1);
        Assertions.assertTrue(providerModels.contains(providerModel));

        Collection<ConsumerModel> consumerModels = serviceRepository.allConsumerModels();
        Assertions.assertEquals(consumerModels.size(), 1);
        Assertions.assertTrue(consumerModels.contains(consumerModel));

    }

}
","builtinServices
",supportedDet,builtinServiceDetector,builtinServiceDetectors,builtinServiceDetectors,
"
package org.apache.dubbo.metadata.annotation.processing.builder;

import org.apache.dubbo.metadata.definition.model.TypeDefinition;

import javax.annotation.processing.ProcessingEnvironment;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import java.util.Collection;
import java.util.Map;
import java.util.Objects;

/**
 * {@link TypeBuilder} for Java {@link Collection}
 *
 * @since 2.7.6
 */
public class CollectionTypeDefinitionBuilder implements DeclaredTypeDefinitionBuilder {

    @Override
    public boolean accept(ProcessingEnvironment processingEnv, DeclaredType type) {
        Elements elements = processingEnv.getElementUtils();
        TypeElement collectionTypeElement = elements.getTypeElement(Collection.class.getTypeName());
        TypeMirror collectionType = collectionTypeElement.asType();
        Types types = processingEnv.getTypeUtils();
        TypeMirror erasedType = types.erasure(type);
        return types.isAssignable(erasedType, collectionType);
    }

    @Override
    public TypeDefinition build(ProcessingEnvironment processingEnv, DeclaredType type, Map<String, TypeDefinition> typeCache) {
        String typeName = type.toString();
        TypeDefinition  [MASK]  = new TypeDefinition(typeName);
        // Generic Type arguments
        type.getTypeArguments()
                .stream()
                .map(typeArgument -> TypeDefinitionBuilder.build(processingEnv, typeArgument, typeCache)) // build the TypeDefinition from typeArgument
                .filter(Objects::nonNull)
                .map(TypeDefinition::getType)
                .forEach( [MASK] .getItems()::add);                              // Add into the declared TypeDefinition
        return  [MASK] ;
    }

    @Override
    public int getPriority() {
        return MIN_PRIORITY - 5;
    }
}
","typeDefinition
",typeDef,typeDef,collectionTypeDefinition,collectionTypeDefinition,
"
package com.google.android.exoplayer2.upstream;

import static com.google.common.truth.Truth.assertThat;

import android.net.Uri;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import com.google.android.exoplayer2.testutil.FakeDataSource;
import com.google.android.exoplayer2.testutil.TestUtil;
import java.io.IOException;
import java.util.Arrays;
import org.junit.Test;
import org.junit.runner.RunWith;

/** Unit tests for {@link DataSourceInputStream}. */
@RunWith(AndroidJUnit4.class)
public final class DataSourceInputStreamTest {

  private static final byte[] TEST_DATA = TestUtil.buildTestData(16);

  @Test
  public void readSingleBytes() throws IOException {
    DataSourceInputStream inputStream = buildTestInputStream();
    // No bytes read yet.
    assertThat(inputStream.bytesRead()).isEqualTo(0);
    // Read bytes.
    for (int i = 0; i < TEST_DATA.length; i++) {
      int readByte = inputStream.read();
      assertThat(0 <= readByte).isTrue();
      assertThat(readByte < 256).isTrue();
      assertThat(readByte).isEqualTo(TEST_DATA[i] & 0xFF);
      assertThat(inputStream.bytesRead()).isEqualTo(i + 1);
    }
    // Check end of stream.
    assertThat(inputStream.read()).isEqualTo(-1);
    assertThat(inputStream.bytesRead()).isEqualTo(TEST_DATA.length);
    // Check close succeeds.
    inputStream.close();
  }

  @Test
  public void read() throws IOException {
    DataSourceInputStream inputStream = buildTestInputStream();
    // Read bytes.
    byte[] readBytes = new byte[TEST_DATA.length];
    int totalBytesRead = 0;
    while (totalBytesRead < TEST_DATA.length) {
      int bytesRead =
          inputStream.read(readBytes, totalBytesRead, TEST_DATA.length - totalBytesRead);
      assertThat(bytesRead).isGreaterThan(0);
      totalBytesRead += bytesRead;
      assertThat(inputStream.bytesRead()).isEqualTo(totalBytesRead);
    }
    // Check the read data.
    assertThat(readBytes).isEqualTo(TEST_DATA);
    // Check end of stream.
    assertThat(inputStream.bytesRead()).isEqualTo(TEST_DATA.length);
    assertThat(totalBytesRead).isEqualTo(TEST_DATA.length);
    assertThat(inputStream.read()).isEqualTo(-1);
    // Check close succeeds.
    inputStream.close();
  }

  @Test
  public void skip() throws IOException {
    DataSourceInputStream inputStream = buildTestInputStream();
    // Skip bytes.
    long  [MASK]  = 0;
    while ( [MASK]  < TEST_DATA.length) {
      long bytesSkipped = inputStream.skip(Long.MAX_VALUE);
      assertThat(bytesSkipped > 0).isTrue();
       [MASK]  += bytesSkipped;
      assertThat(inputStream.bytesRead()).isEqualTo( [MASK] );
    }
    // Check end of stream.
    assertThat(inputStream.bytesRead()).isEqualTo(TEST_DATA.length);
    assertThat( [MASK] ).isEqualTo(TEST_DATA.length);
    assertThat(inputStream.read()).isEqualTo(-1);
    // Check close succeeds.
    inputStream.close();
  }

  private static DataSourceInputStream buildTestInputStream() {
    FakeDataSource fakeDataSource = new FakeDataSource();
    fakeDataSource
        .getDataSet()
        .newDefaultData()
        .appendReadData(Arrays.copyOfRange(TEST_DATA, 0, 5))
        .appendReadData(Arrays.copyOfRange(TEST_DATA, 5, 10))
        .appendReadData(Arrays.copyOfRange(TEST_DATA, 10, 15))
        .appendReadData(Arrays.copyOfRange(TEST_DATA, 15, TEST_DATA.length));
    return new DataSourceInputStream(fakeDataSource, new DataSpec(Uri.EMPTY));
  }
}
","totalBytesSkipped
",offset,totalBytesRead,totalBytesSkipped,bytesRead,
"

package java.io;

import com.badlogic.gdx.utils.Utf8Decoder;

public class InputStreamReader extends Reader {
        private final InputStream in;

        private final Utf8Decoder utf8Decoder;

        public InputStreamReader (InputStream in) {
                this.in = in;
                this.utf8Decoder = new Utf8Decoder();
        }

        public InputStreamReader (InputStream in, String encoding) throws UnsupportedEncodingException {
                this(in);

                // FIXME this is bad, but some APIs seem to use ""ISO-8859-1"", fuckers...
// if (! encoding.equals(""UTF-8"")) {
// throw new UnsupportedEncodingException(encoding);
// }
        }

        public int read (char[] b, int  [MASK] , int length) throws IOException {
                byte[] buffer = new byte[length];
                int c = in.read(buffer);
                return c <= 0 ? c : utf8Decoder.decode(buffer, 0, c, b,  [MASK] );
        }

        public void close () throws IOException {
                in.close();
        }
}
","offset
",nOffset,offset,offset,offset,
"

package com.badlogic.gdx.tests;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.InputAdapter;
import com.badlogic.gdx.InputMultiplexer;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.math.Interpolation;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.List;
import com.badlogic.gdx.scenes.scene2d.ui.ScrollPane;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.tests.utils.GdxTest;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.reflect.ClassReflection;
import com.badlogic.gdx.utils.reflect.Field;
import com.badlogic.gdx.utils.viewport.ScreenViewport;

public class InterpolationTest extends GdxTest {
        Stage stage;
        private Skin skin;
        private Table table;
        List<String> list;
        String interpolationNames[], selectedInterpolation;
        private ShapeRenderer renderer;
        float graphSize, steps, time = 0, duration = 2.5f;
        Vector2 startPosition = new Vector2(), targetPosition = new Vector2(), position = new Vector2();

        /** resets {@link #startPosition} and {@link #targetPosition} */
        void resetPositions () {
                startPosition.set(stage.getWidth() - stage.getWidth() / 5f, stage.getHeight() - stage.getHeight() / 5f);
                targetPosition.set(startPosition.x, stage.getHeight() / 5f);
        }

        /** @return the {@link #position} with the {@link #selectedInterpolation interpolation} applied */
        Vector2 getPosition (float time) {
                position.set(targetPosition);
                position.sub(startPosition);
                position.scl(getInterpolation(selectedInterpolation).apply(time / duration));
                position.add(startPosition);
                return position;
        }

        /** @return the {@link #selectedInterpolation selected} interpolation */
        private Interpolation getInterpolation (String name) {
                try {
                        return (Interpolation)ClassReflection.getField(Interpolation.class, name).get(null);
                } catch (Exception e) {
                        throw new RuntimeException(e);
                }
        }

        @Override
        public void create () {
                Gdx.gl.glClearColor(.3f, .3f, .3f, 1);
                renderer = new ShapeRenderer();

                skin = new Skin(Gdx.files.internal(""data/uiskin.json""));

                stage = new Stage(new ScreenViewport());
                resetPositions();

                Field[] interpolationFields = ClassReflection.getFields(Interpolation.class);

                // see how many fields are actually interpolations (for safety; other fields may be added with future)
                int interpolationMembers = 0;
                for (int i = 0; i < interpolationFields.length; i++)
                        if (ClassReflection.isAssignableFrom(Interpolation.class, interpolationFields[i].getDeclaringClass()))
                                interpolationMembers++;

                // get interpolation names
                interpolationNames = new String[interpolationMembers];
                for (int i = 0; i < interpolationFields.length; i++)
                        if (ClassReflection.isAssignableFrom(Interpolation.class, interpolationFields[i].getDeclaringClass()))
                                interpolationNames[i] = interpolationFields[i].getName();
                selectedInterpolation = interpolationNames[0];

                list = new List(skin);
                list.setItems(interpolationNames);
                list.addListener(new ChangeListener() {
                        public void changed (ChangeEvent event, Actor actor) {
                                selectedInterpolation = list.getSelected();
                                time = 0;
                                resetPositions();
                        }
                });

                ScrollPane scroll = new ScrollPane(list, skin);
                scroll.setFadeScrollBars(false);
                scroll.setScrollingDisabled(true, false);

                table = new Table();
                table.setFillParent(true);
                table.add(scroll).expandX().left().width(100);
                stage.addActor(table);

                Gdx.input.setInputProcessor(new InputMultiplexer(new InputAdapter() {
                        public boolean scrolled (float amountX, float amountY) {
                                if (!Gdx.input.isKeyPressed(Keys.CONTROL_LEFT)) return false;
                                duration -= amountY / 15f;
                                duration = MathUtils.clamp(duration, 0, Float.POSITIVE_INFINITY);
                                return true;
                        }

                }, stage, new InputAdapter() {
                        public boolean touchDown (int screenX, int screenY, int pointer, int button) {
                                if (!Float.isNaN(time)) // if ""walking"" was interrupted by this touch down event
                                        startPosition.set(getPosition(time)); // set startPosition to the current position
                                targetPosition.set(stage.screenToStageCoordinates(targetPosition.set(screenX, screenY)));
                                time = 0;
                                return true;
                        }

                }));
        }

        public void render () {
                Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

                float bottomLeftX = Gdx.graphics.getWidth() / 2 - graphSize / 2, bottomLeftY = Gdx.graphics.getHeight() / 2 - graphSize / 2;

                // only show up to two decimals
                String text = String.valueOf(duration);
                if (text.length() > 4) text = text.substring(0, text.lastIndexOf('.') + 3);
                text = ""duration: "" + text + "" s (ctrl + scroll to change)"";
                stage.getBatch().begin();
                list.getStyle().font.draw(stage.getBatch(), text, bottomLeftX + graphSize / 2,
                        bottomLeftY + graphSize + list.getStyle().font.getLineHeight(), 0, Align.center, false);
                stage.getBatch().end();

                renderer.begin(ShapeType.Line);
                renderer.rect(bottomLeftX, bottomLeftY, graphSize, graphSize); // graph bounds
                float  [MASK]  = bottomLeftX, lastY = bottomLeftY;
                for (float step = 0; step <= steps; step++) {
                        Interpolation interpolation = getInterpolation(selectedInterpolation);
                        float percent = step / steps;
                        float x = bottomLeftX + graphSize * percent, y = bottomLeftY + graphSize * interpolation.apply(percent);
                        renderer.line( [MASK] , lastY, x, y);
                         [MASK]  = x;
                        lastY = y;
                }
                time += Gdx.graphics.getDeltaTime();
                if (time > duration) {
                        time = Float.NaN; // stop ""walking""
                        startPosition.set(targetPosition); // set startPosition to targetPosition for next click
                }
                // draw time marker
                renderer.line(bottomLeftX + graphSize * time / duration, bottomLeftY, bottomLeftX + graphSize * time / duration,
                        bottomLeftY + graphSize);
                // draw path
                renderer.setColor(Color.GRAY);
                renderer.line(startPosition, targetPosition);
                renderer.setColor(Color.WHITE);
                renderer.end();

                // draw the position
                renderer.begin(ShapeType.Filled);
                if (!Float.isNaN(time)) // don't mess up position if time is NaN
                        getPosition(time);
                renderer.circle(position.x, position.y, 7);
                renderer.end();

                stage.act();
                stage.draw();
        }

        public void resize (int width, int height) {
                stage.getViewport().update(width, height, true);
                table.invalidateHierarchy();

                renderer.setProjectionMatrix(stage.getViewport().getCamera().combined);

                graphSize = 0.75f * Math.min(stage.getViewport().getWorldWidth(), stage.getViewport().getWorldHeight());
                steps = graphSize * 0.5f;
        }

        public void dispose () {
                stage.dispose();
                skin.dispose();
        }
}
","lastX
","lastX
","lastX
",currentX,x,
"

package com.google.devtools.build.lib.runtime;

import static com.google.common.truth.Truth.assertThat;
import static java.nio.charset.StandardCharsets.UTF_8;
import static org.mockito.Mockito.mock;

import com.google.common.collect.ImmutableList;
import com.google.devtools.build.lib.buildtool.BuildRequest;
import com.google.devtools.build.lib.buildtool.BuildResult;
import com.google.devtools.build.lib.buildtool.buildevent.BuildCompleteEvent;
import com.google.devtools.build.lib.buildtool.buildevent.BuildStartingEvent;
import com.google.devtools.build.lib.buildtool.buildevent.MainRepoMappingComputationStartingEvent;
import com.google.devtools.build.lib.events.Event;
import com.google.devtools.build.lib.events.EventKind;
import com.google.devtools.build.lib.testutil.ManualClock;
import com.google.devtools.build.lib.util.DetailedExitCode;
import com.google.devtools.build.lib.util.io.OutErr;
import com.google.testing.junit.testparameterinjector.TestParameter;
import com.google.testing.junit.testparameterinjector.TestParameterInjector;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/** Tests for output generated by {@link UiEventHandler}. */
@RunWith(TestParameterInjector.class)
public final class UiEventHandlerStdOutAndStdErrTest {

  private static final BuildCompleteEvent BUILD_COMPLETE_EVENT =
      new BuildCompleteEvent(new BuildResult(/*startTimeMillis=*/ 0));
  private static final String BUILD_DID_NOT_COMPLETE_MESSAGE =
      ""\033[31m\033[1mERROR: \033[0mBuild did NOT complete successfully"" + System.lineSeparator();

  @TestParameter private TestedOutput testedOutput;
  @TestParameter private boolean skymeldMode;

  private UiEventHandler uiEventHandler;
  private FlushCollectingOutputStream output;
  private EventKind eventKind;

  private enum TestedOutput {
    STDOUT,
    STDERR;
  }

  @Before
  public void createUiEventHandler() {
    UiOptions uiOptions = new UiOptions();
    uiOptions.eventKindFilters = ImmutableList.of();
    createUiEventHandler(uiOptions);
  }

  private void createUiEventHandler(UiOptions uiOptions) {
    output = new FlushCollectingOutputStream();

    OutErr outErr = null;
    switch (testedOutput) {
      case STDOUT:
        outErr = OutErr.create(/* out= */ output, /* err= */ mock(OutputStream.class));
        eventKind = EventKind.STDOUT;
        break;
      case STDERR:
        outErr = OutErr.create(/* out= */ mock(OutputStream.class), /* err= */ output);
        eventKind = EventKind.STDERR;
        break;
    }

    uiEventHandler =
        new UiEventHandler(
            outErr,
            uiOptions,
            new ManualClock(),
            /* workspacePathFragment= */ null,
            /* skymeldMode= */ skymeldMode);
    uiEventHandler.mainRepoMappingComputationStarted(new MainRepoMappingComputationStartingEvent());
    uiEventHandler.buildStarted(
        BuildStartingEvent.create(
            ""outputFileSystemType"",
            /* usesInMemoryFileSystem= */ false,
            mock(BuildRequest.class),
            /* workspace= */ null,
            ""/pwd""));
  }

  @Test
  public void buildComplete_outputsBuildFailedOnStderr() {
    uiEventHandler.buildComplete(BUILD_COMPLETE_EVENT);

    if (testedOutput == TestedOutput.STDOUT) {
      output.assertFlushed();
    } else {
      output.assertFlushed(BUILD_DID_NOT_COMPLETE_MESSAGE);
    }
  }

  @Test
  public void buildComplete_flushesBufferedMessage() {
    uiEventHandler.handle(output(""hello""));
    uiEventHandler.buildComplete(BUILD_COMPLETE_EVENT);

    if (testedOutput == TestedOutput.STDOUT) {
      output.assertFlushed(""hello"");
    } else {
      output.assertFlushed(""hello"", System.lineSeparator() + BUILD_DID_NOT_COMPLETE_MESSAGE);
    }
  }

  @Test
  public void buildComplete_successfulBuild() {
    uiEventHandler.handle(output(""""));
    var  [MASK]  = new BuildResult(/*startTimeMillis=*/ 0);
     [MASK] .setDetailedExitCode(DetailedExitCode.success());
    uiEventHandler.buildComplete(new BuildCompleteEvent( [MASK] ));

    if (testedOutput == TestedOutput.STDOUT) {
      output.assertFlushed();
    } else {
      output.assertFlushed(
          ""\033[32mINFO: \033[0mBuild completed successfully, 0 total actions""
              + System.lineSeparator());
    }
  }

  @Test
  public void buildComplete_emptyBuffer_outputsBuildFailedOnStderr() {
    uiEventHandler.handle(output(""""));
    uiEventHandler.buildComplete(BUILD_COMPLETE_EVENT);

    if (testedOutput == TestedOutput.STDOUT) {
      output.assertFlushed();
    } else {
      output.assertFlushed(BUILD_DID_NOT_COMPLETE_MESSAGE);
    }
  }

  @Test
  public void handleOutputEvent_buffersWithoutNewline() {
    uiEventHandler.handle(output(""hello""));
    output.assertFlushed();
  }

  @Test
  public void handleOutputEvent_concatenatesInBuffer() {
    uiEventHandler.handle(output(""hello ""));
    uiEventHandler.handle(output(""there""));
    uiEventHandler.buildComplete(BUILD_COMPLETE_EVENT);

    if (testedOutput == TestedOutput.STDOUT) {
      output.assertFlushed(""hello there"");
    } else {
      output.assertFlushed(""hello there"", System.lineSeparator() + BUILD_DID_NOT_COMPLETE_MESSAGE);
    }
  }

  @Test
  public void handleOutputEvent_flushesOnNewline() {
    uiEventHandler.handle(output(""hello\n""));
    output.assertFlushed(""hello\n"");
  }

  @Test
  public void handleOutputEvent_flushesOnlyUntilNewline() {
    uiEventHandler.handle(output(""hello\nworld""));
    output.assertFlushed(""hello\n"");
  }

  @Test
  public void handleOutputEvent_flushesUntilLastNewline() {
    uiEventHandler.handle(output(""hello\nto\neveryone""));
    output.assertFlushed(""hello\nto\n"");
  }

  @Test
  public void handleOutputEvent_flushesMultiLineMessageAtOnce() {
    uiEventHandler.handle(output(""hello\neveryone\n""));
    output.assertFlushed(""hello\neveryone\n"");
  }

  @Test
  public void handleOutputEvent_concatenatesBufferBeforeFlushingOnNewline() {
    uiEventHandler.handle(output(""hello""));
    uiEventHandler.handle(output("" there!\nmore text""));

    output.assertFlushed(""hello there!\n"");
  }

  // This test only exercises progress bar code when testing stderr output, since we don't make
  // any assertions on stderr (where the progress bar is written) when testing stdout.
  @Test
  public void noChangeOnUnflushedWrite() {
    UiOptions uiOptions = new UiOptions();
    uiOptions.showProgress = true;
    uiOptions.useCursesEnum = UiOptions.UseCurses.YES;
    uiOptions.eventKindFilters = ImmutableList.of();
    createUiEventHandler(uiOptions);
    if (testedOutput == TestedOutput.STDERR) {
      assertThat(output.flushed).hasSize(2);
      output.flushed.clear();
    }
    // Unterminated strings are saved in memory and not pushed out at all.
    assertThat(output.flushed).isEmpty();
    assertThat(output.writtenSinceFlush).isEmpty();
  }

  @Test
  public void buildCompleteMessageDoesntOverrideError() {
    Assume.assumeTrue(testedOutput == TestedOutput.STDERR);
    UiOptions uiOptions = new UiOptions();
    uiOptions.showProgress = true;
    uiOptions.useCursesEnum = UiOptions.UseCurses.YES;
    uiOptions.eventKindFilters = ImmutableList.of();
    createUiEventHandler(uiOptions);

    uiEventHandler.buildComplete(BUILD_COMPLETE_EVENT);
    uiEventHandler.handle(Event.error(""Show me this!""));
    uiEventHandler.afterCommand(new AfterCommandEvent());

    assertThat(output.flushed.size()).isEqualTo(5);
    assertThat(output.flushed.get(3)).contains(""Show me this!"");
    assertThat(output.flushed.get(4)).doesNotContain(""\033[1A\033[K"");
  }

  private Event output(String message) {
    return Event.of(eventKind, message);
  }

  private static class FlushCollectingOutputStream extends OutputStream {
    private final List<String> flushed = new ArrayList<>();
    private String writtenSinceFlush = """";

    @Override
    public void write(int b) throws IOException {
      write(new byte[] {(byte) b});
    }

    @Override
    public void write(byte[] bytes, int offset, int len) {
      writtenSinceFlush += new String(Arrays.copyOfRange(bytes, offset, offset + len), UTF_8);
    }

    @Override
    public void flush() {
      // Ignore inconsequential extra flushes.
      if (!writtenSinceFlush.isEmpty()) {
        flushed.add(writtenSinceFlush);
      }
      writtenSinceFlush = """";
    }

    private void assertFlushed(String... messages) {
      assertThat(writtenSinceFlush).isEmpty();
      assertThat(flushed).containsExactlyElementsIn(messages);
    }
  }
}
","buildSuccessResult
",buildCompleteResult,buildCompleteResult,buildResult,detailedExitCode,
"

package com.facebook.drawee.drawable;

import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.SystemClock;
import androidx.annotation.VisibleForTesting;
import com.facebook.common.internal.Preconditions;

/** Drawable that automatically rotates underlying drawable. */
public class AutoRotateDrawable extends ForwardingDrawable implements Runnable, CloneableDrawable {
  private static final int DEGREES_IN_FULL_ROTATION = 360;
  private static final int FRAME_INTERVAL_MS = 20;

  // Specified duration in milliseconds for one complete rotation.
  private int mInterval;
  // Specified rotation direction
  private boolean mClockwise;

  // Current  [MASK]  by which the drawable is rotated.
  @VisibleForTesting float mRotationAngle = 0;

  // Whether we have our next frame scheduled for update
  private boolean mIsScheduled = false;

  /**
   * Creates a new AutoRotateDrawable with given underlying drawable, interval and a clockwise
   * rotation.
   *
   * @param drawable underlying drawable to apply the rotation to
   * @param interval duration in milliseconds of one complete rotation
   */
  public AutoRotateDrawable(Drawable drawable, int interval) {
    this(drawable, interval, true);
  }

  /**
   * Creates a new AutoRotateDrawable with given underlying drawable and interval.
   *
   * @param drawable underlying drawable to apply the rotation to
   * @param interval duration in milliseconds of one complete rotation
   * @param clockwise defines whether the rotation is clockwise or not
   */
  public AutoRotateDrawable(Drawable drawable, int interval, boolean clockwise) {
    super(Preconditions.checkNotNull(drawable));
    mInterval = interval;
    mClockwise = clockwise;
  }

  /** Resets to the initial state. */
  public void reset() {
    mRotationAngle = 0;
    mIsScheduled = false;
    unscheduleSelf(this);
    invalidateSelf();
  }

  /** Define whether the rotation is clockwise or not. By default is the rotation clockwise. */
  public void setClockwise(boolean clockwise) {
    mClockwise = clockwise;
  }

  @Override
  public void draw(Canvas canvas) {
    int saveCount = canvas.save();

    Rect bounds = getBounds();
    int width = bounds.right - bounds.left;
    int height = bounds.bottom - bounds.top;

    float  [MASK]  = mRotationAngle;
    if (!mClockwise) {
       [MASK]  = DEGREES_IN_FULL_ROTATION - mRotationAngle;
    }
    canvas.rotate( [MASK] , bounds.left + width / 2, bounds.top + height / 2);
    super.draw(canvas);
    canvas.restoreToCount(saveCount);

    scheduleNextFrame();
  }

  @Override
  public void run() {
    mIsScheduled = false;
    mRotationAngle += getIncrement();
    invalidateSelf();
  }

  @Override
  public AutoRotateDrawable cloneDrawable() {
    Drawable delegateCopy = DrawableUtils.cloneDrawable(getDrawable());
    return new AutoRotateDrawable(delegateCopy, mInterval, mClockwise);
  }

  /**
   * Schedule the next frame for drawing.
   *
   * <p>Ideally, we'd like to call this from the callback (i.e. {@code run()}), but if we do there's
   * no place where we can call scheduleNextFrame() for the first time. As a tradeoff, we call this
   * from draw(), which means scheduleNextFrame() could technically be called multiple times for the
   * same frame, so we must handle that gracefully.
   */
  private void scheduleNextFrame() {
    if (!mIsScheduled) {
      mIsScheduled = true;
      scheduleSelf(this, SystemClock.uptimeMillis() + FRAME_INTERVAL_MS);
    }
  }

  private int getIncrement() {
    return (int) (((float) FRAME_INTERVAL_MS) / mInterval * DEGREES_IN_FULL_ROTATION);
  }
}
","angle
",rotOffset,rotOffset,rotationDegrees,rotationAngle,
"
package android.icu.dev.test.calendar;

// AstroTest

import java.util.Date;
import java.util.Locale;

import org.junit.Test;

import android.icu.dev.test.TestFmwk;
import android.icu.impl.CalendarAstronomer;
import android.icu.impl.CalendarAstronomer.Ecliptic;
import android.icu.impl.CalendarAstronomer.Equatorial;
import android.icu.text.DateFormat;
import android.icu.util.Calendar;
import android.icu.util.GregorianCalendar;
import android.icu.util.SimpleTimeZone;
import android.icu.util.TimeZone;

// TODO: try finding next new moon after  07/28/1984 16:00 GMT

public class AstroTest extends TestFmwk {
    static final double PI = Math.PI;

    @Test
    public void TestSolarLongitude() {
        GregorianCalendar gc = new GregorianCalendar(new SimpleTimeZone(0, ""UTC""));
        CalendarAstronomer astro = new CalendarAstronomer();
        // year, month, day, hour, minute, longitude (radians), ascension(radians), declination(radians)
        final double tests[][] = {
            { 1980, 7, 27, 00, 00, 2.166442986535465, 2.2070499713207730, 0.3355704075759270 },
            { 1988, 7, 27, 00, 00, 2.167484927693959, 2.2081183335606176, 0.3353093444275315 },
        };
        logln("""");
        for (int i = 0; i < tests.length; i++) {
            gc.clear();
            gc.set((int)tests[i][0], (int)tests[i][1]-1, (int)tests[i][2], (int)tests[i][3], (int) tests[i][4]);

            astro.setDate(gc.getTime());

            double longitude = astro.getSunLongitude();
            if (longitude != tests[i][5]) {
                if ((float)longitude == (float)tests[i][5]) {
                    logln(""longitude("" + longitude +
                            "") !=  tests[i][5]("" + tests[i][5] +
                            "") in double for test "" + i);
                } else {
                    errln(""FAIL: longitude("" + longitude +
                            "") !=  tests[i][5]("" + tests[i][5] +
                            "") for test "" + i);
                }
            }
            Equatorial result = astro.getSunPosition();
            if (result.ascension != tests[i][6]) {
                if ((float)result.ascension == (float)tests[i][6]) {
                    logln(""result.ascension("" + result.ascension +
                            "") !=  tests[i][6]("" + tests[i][6] +
                            "") in double for test "" + i);
                } else {
                    errln(""FAIL: result.ascension("" + result.ascension +
                            "") !=  tests[i][6]("" + tests[i][6] +
                            "") for test "" + i);
                }
            }
            if (result.declination != tests[i][7]) {
                if ((float)result.declination == (float)tests[i][7]) {
                    logln(""result.declination("" + result.declination +
                            "") !=  tests[i][7]("" + tests[i][7] +
                            "") in double for test "" + i);
                } else {
                    errln(""FAIL: result.declination("" + result.declination +
                            "") !=  tests[i][7]("" + tests[i][7] +
                            "") for test "" + i);
                }
            }
        }
    }

    @Test
    public void TestLunarPosition() {
        GregorianCalendar gc = new GregorianCalendar(new SimpleTimeZone(0, ""UTC""));
        CalendarAstronomer astro = new CalendarAstronomer();
        // year, month, day, hour, minute, ascension(radians), declination(radians)
        final double tests[][] = {
            { 1979, 2, 26, 16, 00, -0.3778379118188744, -0.1399698825594198 },
        };
        logln("""");

        for (int i = 0; i < tests.length; i++) {
            gc.clear();
            gc.set((int)tests[i][0], (int)tests[i][1]-1, (int)tests[i][2], (int)tests[i][3], (int) tests[i][4]);
            astro.setDate(gc.getTime());

            Equatorial result = astro.getMoonPosition();
            if (result.ascension != tests[i][5]) {
                if ((float)result.ascension == (float)tests[i][5]) {
                    logln(""result.ascension("" + result.ascension +
                            "") !=  tests[i][5]("" + tests[i][5] +
                            "") in double for test "" + i);
                } else {
                    errln(""FAIL: result.ascension("" + result.ascension +
                            "") !=  tests[i][5]("" + tests[i][5] +
                            "") for test "" + i);
                }
            }
            if (result.declination != tests[i][6]) {
                if ((float)result.declination == (float)tests[i][6]) {
                    logln(""result.declination("" + result.declination +
                            "") !=  tests[i][6]("" + tests[i][6] +
                            "") in double for test "" + i);
                } else {
                    errln(""FAIL: result.declination("" + result.declination +
                            "") !=  tests[i][6]("" + tests[i][6] +
                            "") for test "" + i);
                }
            }
        }
    }

    @Test
    public void TestCoordinates() {
        CalendarAstronomer astro = new CalendarAstronomer();
        Equatorial result = astro.eclipticToEquatorial(139.686111 * PI/ 180.0, 4.875278* PI / 180.0);
        logln(""result is "" + result + "";  "" + result.toHmsString());
    }

    @Test
    public void TestCoverage() {
        GregorianCalendar cal = new GregorianCalendar(1958, Calendar.AUGUST, 15);
        Date then = cal.getTime();
        CalendarAstronomer myastro = new CalendarAstronomer(then);

        //Latitude:  34 degrees 05' North
        //Longitude:  118 degrees 22' West
        double laLat = 34 + 5d/60, laLong = 360 - (118 + 22d/60);
        CalendarAstronomer myastro2 = new CalendarAstronomer(laLong, laLat);

        double eclLat = laLat * Math.PI / 360;
        double eclLong = laLong * Math.PI / 360;
        Ecliptic ecl = new Ecliptic(eclLat, eclLong);
        logln(""ecliptic: "" + ecl);

        CalendarAstronomer myastro3 = new CalendarAstronomer();
        myastro3.setJulianDay((4713 + 2000) * 365.25);

        CalendarAstronomer[] astronomers = {
            myastro, myastro2, myastro3, myastro2 // check cache

        };

        for (int i = 0; i < astronomers.length; ++i) {
            CalendarAstronomer astro = astronomers[i];

            logln(""astro: "" + astro);
            logln(""   time: "" + astro.getTime());
            logln(""   date: "" + astro.getDate());
            logln(""   cent: "" + astro.getJulianCentury());
            logln(""   gw sidereal: "" + astro.getGreenwichSidereal());
            logln(""   loc sidereal: "" + astro.getLocalSidereal());
            logln(""   equ ecl: "" + astro.eclipticToEquatorial(ecl));
            logln(""   equ long: "" + astro.eclipticToEquatorial(eclLong));
            logln(""   horiz: "" + astro.eclipticToHorizon(eclLong));
            logln(""   sunrise: "" + new Date(astro.getSunRiseSet(true)));
            logln(""    [MASK] : "" + new Date(astro.getSunRiseSet(false)));
            logln(""   moon phase: "" + astro.getMoonPhase());
            logln(""   moonrise: "" + new Date(astro.getMoonRiseSet(true)));
            logln(""   moonset: "" + new Date(astro.getMoonRiseSet(false)));
            logln(""   prev summer solstice: "" + new Date(astro.getSunTime(CalendarAstronomer.SUMMER_SOLSTICE, false)));
            logln(""   next summer solstice: "" + new Date(astro.getSunTime(CalendarAstronomer.SUMMER_SOLSTICE, true)));
            logln(""   prev full moon: "" + new Date(astro.getMoonTime(CalendarAstronomer.FULL_MOON, false)));
            logln(""   next full moon: "" + new Date(astro.getMoonTime(CalendarAstronomer.FULL_MOON, true)));
        }

    }

    static final long DAY_MS = 24*60*60*1000L;

    @Test
    public void TestSunriseTimes() {

        //        logln(""Sunrise/Sunset times for San Jose, California, USA"");
        //        CalendarAstronomer astro = new CalendarAstronomer(-121.55, 37.20);
        //        TimeZone tz = TimeZone.getTimeZone(""America/Los_Angeles"");

        // We'll use a table generated by the UNSO website as our reference
        // From: http://aa.usno.navy.mil/
        //-Location: W079 25, N43 40
        //-Rise and Set for the Sun for 2001
        //-Zone:  4h West of Greenwich
        int[] USNO = {
             6,59, 19,45,
             6,57, 19,46,
             6,56, 19,47,
             6,54, 19,48,
             6,52, 19,49,
             6,50, 19,51,
             6,48, 19,52,
             6,47, 19,53,
             6,45, 19,54,
             6,43, 19,55,
             6,42, 19,57,
             6,40, 19,58,
             6,38, 19,59,
             6,36, 20, 0,
             6,35, 20, 1,
             6,33, 20, 3,
             6,31, 20, 4,
             6,30, 20, 5,
             6,28, 20, 6,
             6,27, 20, 7,
             6,25, 20, 8,
             6,23, 20,10,
             6,22, 20,11,
             6,20, 20,12,
             6,19, 20,13,
             6,17, 20,14,
             6,16, 20,16,
             6,14, 20,17,
             6,13, 20,18,
             6,11, 20,19,
        };

        logln(""Sunrise/Sunset times for Toronto, Canada"");
        CalendarAstronomer astro = new CalendarAstronomer(-(79+25/60), 43+40/60);

        // As of ICU4J 2.8 the ICU4J time zones implement pass-through
        // to the underlying JDK.  Because of variation in the
        // underlying JDKs, we have to use a fixed-offset
        // SimpleTimeZone to get consistent behavior between JDKs.
        // The offset we want is [-18000000, 3600000] (raw, dst).
        // [aliu 10/15/03]

        // TimeZone tz = TimeZone.getTimeZone(""America/Montreal"");
        TimeZone tz = new SimpleTimeZone(-18000000 + 3600000, ""Montreal(FIXED)"");

        GregorianCalendar cal = new GregorianCalendar(tz, Locale.US);
        GregorianCalendar cal2 = new GregorianCalendar(tz, Locale.US);
        cal.clear();
        cal.set(Calendar.YEAR, 2001);
        cal.set(Calendar.MONTH, Calendar.APRIL);
        cal.set(Calendar.DAY_OF_MONTH, 1);
        cal.set(Calendar.HOUR_OF_DAY, 12); // must be near local noon for getSunRiseSet to work

        DateFormat df = DateFormat.getTimeInstance(cal, DateFormat.MEDIUM, Locale.US);
        DateFormat df2 = DateFormat.getDateTimeInstance(cal, DateFormat.MEDIUM, DateFormat.MEDIUM, Locale.US);
        DateFormat day = DateFormat.getDateInstance(cal, DateFormat.MEDIUM, Locale.US);

        for (int i=0; i < 30; i++) {
            astro.setDate(cal.getTime());

            Date sunrise = new Date(astro.getSunRiseSet(true));
            Date  [MASK]  = new Date(astro.getSunRiseSet(false));

            cal2.setTime(cal.getTime());
            cal2.set(Calendar.SECOND,      0);
            cal2.set(Calendar.MILLISECOND, 0);

            cal2.set(Calendar.HOUR_OF_DAY, USNO[4*i+0]);
            cal2.set(Calendar.MINUTE,      USNO[4*i+1]);
            Date exprise = cal2.getTime();
            cal2.set(Calendar.HOUR_OF_DAY, USNO[4*i+2]);
            cal2.set(Calendar.MINUTE,      USNO[4*i+3]);
            Date expset = cal2.getTime();
            // Compute delta of what we got to the USNO data, in seconds
            int deltarise = Math.abs((int)(sunrise.getTime() - exprise.getTime()) / 1000);
            int deltaset = Math.abs((int)( [MASK] .getTime() - expset.getTime()) / 1000);

            // Allow a deviation of 0..MAX_DEV seconds
            // It would be nice to get down to 60 seconds, but at this
            // point that appears to be impossible without a redo of the
            // algorithm using something more advanced than Duffett-Smith.
            final int MAX_DEV = 180;
            if (deltarise > MAX_DEV || deltaset > MAX_DEV) {
                if (deltarise > MAX_DEV) {
                    errln(""FAIL: "" + day.format(cal.getTime()) +
                          "", Sunrise: "" + df2.format(sunrise) +
                          "" (USNO "" + df.format(exprise) +
                          "" d="" + deltarise + ""s)"");
                } else {
                    logln(day.format(cal.getTime()) +
                          "", Sunrise: "" + df.format(sunrise) +
                          "" (USNO "" + df.format(exprise) + "")"");
                }
                if (deltaset > MAX_DEV) {
                    errln(""FAIL: "" + day.format(cal.getTime()) +
                          "", Sunset: "" + df2.format( [MASK] ) +
                          "" (USNO "" + df.format(expset) +
                          "" d="" + deltaset + ""s)"");
                } else {
                    logln(day.format(cal.getTime()) +
                          "", Sunset: "" + df.format( [MASK] ) +
                          "" (USNO "" + df.format(expset) + "")"");
                }
            } else {
                logln(day.format(cal.getTime()) +
                      "", Sunrise: "" + df.format(sunrise) +
                      "" (USNO "" + df.format(exprise) + "")"" +
                      "", Sunset: "" + df.format( [MASK] ) +
                      "" (USNO "" + df.format(expset) + "")"");
            }
            cal.add(Calendar.DATE, 1);
        }

//        CalendarAstronomer a = new CalendarAstronomer(-(71+5/60), 42+37/60);
//        cal.clear();
//        cal.set(cal.YEAR, 1986);
//        cal.set(cal.MONTH, cal.MARCH);
//        cal.set(cal.DATE, 10);
//        cal.set(cal.YEAR, 1988);
//        cal.set(cal.MONTH, cal.JULY);
//        cal.set(cal.DATE, 27);
//        a.setDate(cal.getTime());
//        long r = a.getSunRiseSet2(true);
    }

    @Test
    public void TestBasics() {
        // Check that our JD computation is the same as the book's (p. 88)
        CalendarAstronomer astro = new CalendarAstronomer();
        GregorianCalendar cal3 = new GregorianCalendar(TimeZone.getTimeZone(""GMT""), Locale.US);
        DateFormat d3 = DateFormat.getDateTimeInstance(cal3, DateFormat.MEDIUM,DateFormat.MEDIUM,Locale.US);
        cal3.clear();
        cal3.set(Calendar.YEAR, 1980);
        cal3.set(Calendar.MONTH, Calendar.JULY);
        cal3.set(Calendar.DATE, 27);
        astro.setDate(cal3.getTime());
        double jd = astro.getJulianDay() - 2447891.5;
        double exp = -3444;
        if (jd == exp) {
            logln(d3.format(cal3.getTime()) + "" => "" + jd);
        } else {
            errln(""FAIL: "" + d3.format(cal3.getTime()) + "" => "" + jd +
                  "", expected "" + exp);
        }


//        cal3.clear();
//        cal3.set(cal3.YEAR, 1990);
//        cal3.set(cal3.MONTH, Calendar.JANUARY);
//        cal3.set(cal3.DATE, 1);
//        cal3.add(cal3.DATE, -1);
//        astro.setDate(cal3.getTime());
//        astro.foo();
    }
    
    @Test
    public void TestMoonAge(){
        GregorianCalendar gc = new GregorianCalendar(new SimpleTimeZone(0,""GMT""));
        CalendarAstronomer calastro = new CalendarAstronomer();
        // more testcases are around the date 05/20/2012
        //ticket#3785  UDate ud0 = 1337557623000.0;
        double testcase[][] = {{2012, 5, 20 , 16 , 48, 59},
                {2012, 5, 20 , 16 , 47, 34},
                {2012, 5, 21, 00, 00, 00},
                {2012, 5, 20, 14, 55, 59},
                {2012, 5, 21, 7, 40, 40},
                {2023, 9, 25, 10,00, 00},
                {2008, 7, 7, 15, 00, 33}, 
                {1832, 9, 24, 2, 33, 41 },
                {2016, 1, 31, 23, 59, 59},
                {2099, 5, 20, 14, 55, 59}
        };
        // Moon phase angle - Got from http://www.moonsystem.to/checkupe.htm
        double angle[] = {356.8493418421329, 356.8386760059673, 0.09625415252237701, 355.9986960782416, 3.5714026601303317, 124.26906744384183, 59.80247650195558, 357.54163205513123, 268.41779281511094, 4.82340276581624};
        double precision = PI/32;
        for(int i=0; i<testcase.length; i++){
            gc.clear();
            String testString = ""CASE[""+i+""]: Year ""+(int)testcase[i][0]+"" Month ""+(int)testcase[i][1]+"" Day ""+
                                    (int)testcase[i][2]+"" Hour ""+(int)testcase[i][3]+"" Minutes ""+(int)testcase[i][4]+
                                    "" Seconds ""+(int)testcase[i][5];
            gc.set((int)testcase[i][0],(int)testcase[i][1]-1,(int)testcase[i][2],(int)testcase[i][3],(int)testcase[i][4], (int)testcase[i][5]);
            calastro.setDate(gc.getTime());
            double expectedAge = (angle[i]*PI)/180;
            double got = calastro.getMoonAge();
            logln(testString);
            if(!(got>expectedAge-precision && got<expectedAge+precision)){
                errln(""FAIL: expected "" + expectedAge +
                        "" got "" + got);
            }else{
                logln(""PASS: expected "" + expectedAge +
                        "" got "" + got);
            }
        }
    }
}
","sunset
",noon,sunrise,sunsetTime,sunset,
"
package io.netty.handler.ssl;

import io.netty.bootstrap.Bootstrap;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.DefaultEventLoopGroup;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.local.LocalAddress;
import io.netty.channel.local.LocalChannel;
import io.netty.channel.local.LocalServerChannel;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import io.netty.handler.ssl.util.SelfSignedCertificate;
import io.netty.handler.ssl.util.SimpleTrustManagerFactory;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.concurrent.Promise;
import io.netty.util.internal.EmptyArrays;
import io.netty.util.internal.ThrowableUtil;

import javax.net.ssl.ExtendedSSLSession;
import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.KeyManagerFactorySpi;
import javax.net.ssl.ManagerFactoryParameters;
import javax.net.ssl.SNIHostName;
import javax.net.ssl.SNIMatcher;
import javax.net.ssl.SNIServerName;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509ExtendedKeyManager;
import javax.net.ssl.X509ExtendedTrustManager;
import java.io.IOException;
import java.net.Socket;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.PrivateKey;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

/**
 * In extra class to be able to run tests with java7 without trying to load classes that not exists in java7.
 */
final class SniClientJava8TestUtil {

    private SniClientJava8TestUtil() { }

    static void testSniClient(SslProvider sslClientProvider, SslProvider sslServerProvider, final boolean match)
            throws Exception {
        final String sniHost = ""sni.netty.io"";
        SelfSignedCertificate cert = new SelfSignedCertificate();
        LocalAddress address = new LocalAddress(""test"");
        EventLoopGroup group = new DefaultEventLoopGroup(1);
        SslContext sslServerContext = null;
        SslContext sslClientContext = null;

        Channel sc = null;
        Channel cc = null;
        try {
            sslServerContext = SslContextBuilder.forServer(cert.key(), cert.cert())
                    .sslProvider(sslServerProvider).build();
            final Promise<Void> promise = group.next().newPromise();
            ServerBootstrap sb = new ServerBootstrap();

            final SslContext finalContext = sslServerContext;
            sc = sb.group(group).channel(LocalServerChannel.class).childHandler(new ChannelInitializer<Channel>() {
                @Override
                protected void initChannel(Channel ch) throws Exception {
                    SslHandler handler = finalContext.newHandler(ch.alloc());
                    SSLParameters  [MASK]  = handler.engine().getSSLParameters();
                    SNIMatcher matcher = new SNIMatcher(0) {
                        @Override
                        public boolean matches(SNIServerName sniServerName) {
                            return match;
                        }
                    };
                     [MASK] .setSNIMatchers(Collections.singleton(matcher));
                    handler.engine().setSSLParameters( [MASK] );

                    ch.pipeline().addFirst(handler);
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                        @Override
                        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
                            if (evt instanceof SslHandshakeCompletionEvent) {
                                SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;
                                if (match) {
                                    if (event.isSuccess()) {
                                        promise.setSuccess(null);
                                    } else {
                                        promise.setFailure(event.cause());
                                    }
                                } else {
                                    if (event.isSuccess()) {
                                        promise.setFailure(new AssertionError(""expected SSLException""));
                                    } else {
                                        Throwable cause = event.cause();
                                        if (cause instanceof SSLException) {
                                            promise.setSuccess(null);
                                        } else {
                                            promise.setFailure(
                                                    new AssertionError(""cause not of type SSLException: ""
                                                            + ThrowableUtil.stackTraceToString(cause)));
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }).bind(address).syncUninterruptibly().channel();

            sslClientContext = SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE)
                    .sslProvider(sslClientProvider).build();

            SslHandler sslHandler = new SslHandler(
                    sslClientContext.newEngine(ByteBufAllocator.DEFAULT, sniHost, -1));
            Bootstrap cb = new Bootstrap();
            cc = cb.group(group).channel(LocalChannel.class).handler(sslHandler)
                    .connect(address).syncUninterruptibly().channel();

            promise.syncUninterruptibly();
            sslHandler.handshakeFuture().syncUninterruptibly();
        } finally {
            if (cc != null) {
                cc.close().syncUninterruptibly();
            }
            if (sc != null) {
                sc.close().syncUninterruptibly();
            }

            ReferenceCountUtil.release(sslServerContext);
            ReferenceCountUtil.release(sslClientContext);

            cert.delete();

            group.shutdownGracefully();
        }
    }

    static void assertSSLSession(boolean clientSide, SSLSession session, String name) {
        assertSSLSession(clientSide, session, new SNIHostName(name));
    }

    private static void assertSSLSession(boolean clientSide, SSLSession session, SNIServerName name) {
        assertNotNull(session);
        if (session instanceof ExtendedSSLSession) {
            ExtendedSSLSession extendedSSLSession = (ExtendedSSLSession) session;
            List<SNIServerName> names = extendedSSLSession.getRequestedServerNames();
            assertEquals(1, names.size());
            assertEquals(name, names.get(0));
            assertTrue(extendedSSLSession.getLocalSupportedSignatureAlgorithms().length > 0);
            if (clientSide) {
                assertEquals(0, extendedSSLSession.getPeerSupportedSignatureAlgorithms().length);
            } else {
                assertTrue(extendedSSLSession.getPeerSupportedSignatureAlgorithms().length >= 0);
            }
        }
    }

    static TrustManagerFactory newSniX509TrustmanagerFactory(String name) {
        return new SniX509TrustmanagerFactory(new SNIHostName(name));
    }

    private static final class SniX509TrustmanagerFactory extends SimpleTrustManagerFactory {

        private final SNIServerName name;

        SniX509TrustmanagerFactory(SNIServerName name) {
            this.name = name;
        }

        @Override
        protected void engineInit(KeyStore keyStore) throws Exception {
            // NOOP
        }

        @Override
        protected void engineInit(ManagerFactoryParameters managerFactoryParameters) throws Exception {
            // NOOP
        }

        @Override
        protected TrustManager[] engineGetTrustManagers() {
            return new TrustManager[] { new X509ExtendedTrustManager() {
                @Override
                public void checkClientTrusted(X509Certificate[] x509Certificates, String s, Socket socket)
                        throws CertificateException {
                    fail();
                }

                @Override
                public void checkServerTrusted(X509Certificate[] x509Certificates, String s, Socket socket)
                        throws CertificateException {
                    fail();
                }

                @Override
                public void checkClientTrusted(X509Certificate[] x509Certificates, String s, SSLEngine sslEngine)
                        throws CertificateException {
                    fail();
                }

                @Override
                public void checkServerTrusted(X509Certificate[] x509Certificates, String s, SSLEngine sslEngine)
                        throws CertificateException {
                    assertSSLSession(sslEngine.getUseClientMode(), sslEngine.getHandshakeSession(), name);
                }

                @Override
                public void checkClientTrusted(X509Certificate[] x509Certificates, String s)
                        throws CertificateException {
                    fail();
                }

                @Override
                public void checkServerTrusted(X509Certificate[] x509Certificates, String s)
                        throws CertificateException {
                    fail();
                }

                @Override
                public X509Certificate[] getAcceptedIssuers() {
                    return EmptyArrays.EMPTY_X509_CERTIFICATES;
                }
            } };
        }
    }

    static KeyManagerFactory newSniX509KeyManagerFactory(SelfSignedCertificate cert, String hostname)
            throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException,
                   IOException, CertificateException {
        return new SniX509KeyManagerFactory(
                new SNIHostName(hostname), SslContext.buildKeyManagerFactory(
                new X509Certificate[] { cert.cert() }, null,  cert.key(), null, null, null));
    }

    private static final class SniX509KeyManagerFactory extends KeyManagerFactory {

        SniX509KeyManagerFactory(final SNIServerName name, final KeyManagerFactory factory) {
            super(new KeyManagerFactorySpi() {
                @Override
                protected void engineInit(KeyStore keyStore, char[] chars)
                        throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException {
                    factory.init(keyStore, chars);
                }

                @Override
                protected void engineInit(ManagerFactoryParameters managerFactoryParameters)
                        throws InvalidAlgorithmParameterException {
                    factory.init(managerFactoryParameters);
                }

                @Override
                protected KeyManager[] engineGetKeyManagers() {
                    List<KeyManager> managers = new ArrayList<KeyManager>();
                    for (final KeyManager km: factory.getKeyManagers()) {
                        if (km instanceof X509ExtendedKeyManager) {
                            managers.add(new X509ExtendedKeyManager() {
                                @Override
                                public String[] getClientAliases(String s, Principal[] principals) {
                                    return ((X509ExtendedKeyManager) km).getClientAliases(s, principals);
                                }

                                @Override
                                public String chooseClientAlias(String[] strings, Principal[] principals,
                                                                Socket socket) {
                                    return ((X509ExtendedKeyManager) km).chooseClientAlias(strings, principals, socket);
                                }

                                @Override
                                public String[] getServerAliases(String s, Principal[] principals) {
                                    return ((X509ExtendedKeyManager) km).getServerAliases(s, principals);
                                }

                                @Override
                                public String chooseServerAlias(String s, Principal[] principals, Socket socket) {
                                    return ((X509ExtendedKeyManager) km).chooseServerAlias(s, principals, socket);
                                }

                                @Override
                                public X509Certificate[] getCertificateChain(String s) {
                                    return ((X509ExtendedKeyManager) km).getCertificateChain(s);
                                }

                                @Override
                                public PrivateKey getPrivateKey(String s) {
                                    return ((X509ExtendedKeyManager) km).getPrivateKey(s);
                                }

                                @Override
                                public String chooseEngineClientAlias(String[] strings, Principal[] principals,
                                                                      SSLEngine sslEngine) {
                                    return ((X509ExtendedKeyManager) km)
                                            .chooseEngineClientAlias(strings, principals, sslEngine);
                                }

                                @Override
                                public String chooseEngineServerAlias(String s, Principal[] principals,
                                                                      SSLEngine sslEngine) {

                                    SSLSession session = sslEngine.getHandshakeSession();
                                    assertSSLSession(sslEngine.getUseClientMode(), session, name);
                                    return ((X509ExtendedKeyManager) km)
                                            .chooseEngineServerAlias(s, principals, sslEngine);
                                }
                            });
                        } else {
                            managers.add(km);
                        }
                    }
                    return managers.toArray(new KeyManager[0]);
                }
            }, factory.getProvider(), factory.getAlgorithm());
        }
    }
}
","parameters
",sslParameters,sslParameters,sslParameters,sslParameters,
"

package libcore.java.util.function;

import junit.framework.TestCase;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.IntPredicate;

public class IntPredicateTest extends TestCase {

  public void testAnd() throws Exception {
    int arg = 5;

    AtomicBoolean  [MASK]  = new AtomicBoolean(false);
    AtomicBoolean alwaysTrue2Invoked = new AtomicBoolean(false);
    AtomicBoolean alwaysFalseInvoked = new AtomicBoolean(false);
    AtomicBoolean alwaysFalse2Invoked = new AtomicBoolean(false);
    AtomicBoolean[] invocationState = {
         [MASK] , alwaysTrue2Invoked, alwaysFalseInvoked, alwaysFalse2Invoked };

    IntPredicate alwaysTrue =
        x -> {  [MASK] .set(true); assertEquals(x, arg); return true; };
    IntPredicate alwaysTrue2 =
        x -> { alwaysTrue2Invoked.set(true); assertEquals(x, arg); return true; };
    IntPredicate alwaysFalse =
        x -> { alwaysFalseInvoked.set(true); assertEquals(x, arg); return false; };
    IntPredicate alwaysFalse2 =
        x -> { alwaysFalse2Invoked.set(true); assertEquals(x, arg); return false; };

    // true && true
    resetToFalse(invocationState);
    assertTrue(alwaysTrue.and(alwaysTrue2).test(arg));
    assertTrue( [MASK] .get() && alwaysTrue2Invoked.get());

    // true && false
    resetToFalse(invocationState);
    assertFalse(alwaysTrue.and(alwaysFalse).test(arg));
    assertTrue( [MASK] .get() && alwaysFalseInvoked.get());

    // false && false
    resetToFalse(invocationState);
    assertFalse(alwaysFalse.and(alwaysFalse2).test(arg));
    assertTrue(alwaysFalseInvoked.get() && !alwaysFalse2Invoked.get());

    // false && true
    resetToFalse(invocationState);
    assertFalse(alwaysFalse.and(alwaysTrue).test(arg));
    assertTrue(alwaysFalseInvoked.get() && ! [MASK] .get());
  }

  public void testAnd_null() throws Exception {
    IntPredicate alwaysTrue = x -> true;
    try {
      alwaysTrue.and(null);
      fail();
    } catch (NullPointerException expected) {}
  }

  public void testNegate() throws Exception {
    int arg = 5;
    IntPredicate alwaysTrue = x -> { assertEquals(x, arg); return true; };
    assertFalse(alwaysTrue.negate().test(arg));

    IntPredicate alwaysFalse = x -> { assertEquals(x, arg); return false; };
    assertTrue(alwaysFalse.negate().test(arg));
  }

  public void testOr() throws Exception {
    int arg = 5;

    AtomicBoolean  [MASK]  = new AtomicBoolean(false);
    AtomicBoolean alwaysTrue2Invoked = new AtomicBoolean(false);
    AtomicBoolean alwaysFalseInvoked = new AtomicBoolean(false);
    AtomicBoolean alwaysFalse2Invoked = new AtomicBoolean(false);
    AtomicBoolean[] invocationState = {
         [MASK] , alwaysTrue2Invoked, alwaysFalseInvoked, alwaysFalse2Invoked };

    IntPredicate alwaysTrue =
        x -> {  [MASK] .set(true); assertEquals(x, arg); return true; };
    IntPredicate alwaysTrue2 =
        x -> { alwaysTrue2Invoked.set(true); assertEquals(x, arg); return true; };
    IntPredicate alwaysFalse =
        x -> { alwaysFalseInvoked.set(true); assertEquals(x, arg); return false; };
    IntPredicate alwaysFalse2 =
        x -> { alwaysFalse2Invoked.set(true); assertEquals(x, arg); return false; };

    // true || true
    resetToFalse(invocationState);
    assertTrue(alwaysTrue.or(alwaysTrue2).test(arg));
    assertTrue( [MASK] .get() && !alwaysTrue2Invoked.get());

    // true || false
    resetToFalse(invocationState);
    assertTrue(alwaysTrue.or(alwaysFalse).test(arg));
    assertTrue( [MASK] .get() && !alwaysFalseInvoked.get());

    // false || false
    resetToFalse(invocationState);
    assertFalse(alwaysFalse.or(alwaysFalse2).test(arg));
    assertTrue(alwaysFalseInvoked.get() && alwaysFalse2Invoked.get());

    // false || true
    resetToFalse(invocationState);
    assertTrue(alwaysFalse.or(alwaysTrue).test(arg));
    assertTrue(alwaysFalseInvoked.get() &&  [MASK] .get());
  }

  public void testOr_null() throws Exception {
    IntPredicate alwaysTrue = x -> true;
    try {
      alwaysTrue.or(null);
      fail();
    } catch (NullPointerException expected) {}
  }

  private static void resetToFalse(AtomicBoolean... toResets) {
    for (AtomicBoolean toReset : toResets) {
      toReset.set(false);
    }
  }
}
","alwaysTrueInvoked
",alwaysTrue,alwaysTrueInv,invoked,predicateInvoked,
"
package com.google.devtools.build.lib.query2.query.output;

import com.google.common.base.Preconditions;
import com.google.common.flogger.GoogleLogger;
import com.google.common.hash.HashFunction;
import com.google.common.hash.HashingOutputStream;
import com.google.common.io.BaseEncoding;
import com.google.common.io.ByteStreams;
import com.google.devtools.build.lib.packages.Attribute;
import com.google.devtools.build.lib.packages.Attribute.ComputedDefault;
import com.google.devtools.build.lib.packages.AttributeFormatter;
import com.google.devtools.build.lib.packages.BuildType.SelectorList;
import com.google.devtools.build.lib.packages.RawAttributeMapper;
import com.google.devtools.build.lib.packages.Rule;
import com.google.devtools.build.lib.packages.RuleClass;
import com.google.devtools.build.lib.query2.proto.proto2api.Build;
import com.google.protobuf.CodedOutputStream;
import java.io.IOException;
import java.util.Map;

/**
 * Contains the logic for condensing the various properties of rules that contribute to their
 * ""affectedness"" into a simple hash value. The resulting hash may be compared across queries to
 * tell if a rule has changed in a potentially meaningful way.
 */
class SyntheticAttributeHashCalculator {

  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();

  private SyntheticAttributeHashCalculator() {}

  /**
   * Returns a hash of various properties of a rule which might contribute to the rule's
   * ""affectedness"". This includes, but is not limited to, attribute values and error-state.
   *
   * @param rule The rule instance to calculate the hash for.
   * @param serializedAttributes Any available attribute which have already been serialized. This is
   *     an optimization to avoid re-serializing attributes internally.
   * @param extraDataForAttrHash Extra data to add to the hash.
   */
  static String compute(
      Rule rule,
      Map<Attribute, Build.Attribute> serializedAttributes,
      Object extraDataForAttrHash,
      HashFunction hashFunction,
      boolean includeAttributeSourceAspects) {
    HashingOutputStream hashingOutputStream =
        new HashingOutputStream(hashFunction, ByteStreams.nullOutputStream());
    CodedOutputStream codedOut = CodedOutputStream.newInstance(hashingOutputStream);

    RuleClass ruleClass = rule.getRuleClassObject();
    if (ruleClass.isStarlark()) {
      try {
        codedOut.writeByteArrayNoTag(
            Preconditions.checkNotNull(ruleClass.getRuleDefinitionEnvironmentDigest(), rule));
      } catch (IOException e) {
        throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
      }
    }

    RawAttributeMapper  [MASK]  = RawAttributeMapper.of(rule);
    for (Attribute attr : rule.getAttributes()) {
      String attrName = attr.getName();

      if (attrName.equals(""generator_location"")) {
        // generator_location can be ignored for the purpose of telling if a rule has changed.
        continue;
      }

      Object valueToHash =  [MASK] .getRawAttributeValue(rule, attr);

      if (valueToHash instanceof ComputedDefault) {
        // ConfiguredDefaults need special handling to detect changes in evaluated values.
        ComputedDefault computedDefault = (ComputedDefault) valueToHash;
        if (!computedDefault.dependencies().isEmpty()) {
          // TODO(b/29038463): We're skipping computed defaults that depend on other configurable
          // attributes because there currently isn't a way to evaluate such a computed default;
          // there isn't *one* value it evaluates to.
          continue;
        }

        try {
          valueToHash = computedDefault.getDefault( [MASK] );
        } catch (IllegalArgumentException e) {
          // TODO(mschaller): Catching IllegalArgumentException isn't ideal. It's thrown by
          // AbstractAttributeMapper#get if the attribute's type doesn't match its value, which
          // would happen if a ComputedDefault function accessed an attribute whose value was
          // configurable. We check whether the ComputedDefault declared any configurable
          // attribute dependencies above, but someone could make a mistake and fail to declare
          // something. There's no mechanism that enforces correct declaration right now.
          // This allows us to recover from such an error by skipping an attribute, as opposed to
          // crashing.
          logger.atWarning().log(
              ""Recovering from failed evaluation of ComputedDefault attribute value: %s"", e);
          continue;
        }
      }

      Build.Attribute attrPb;
      if (valueToHash instanceof SelectorList<?> || !serializedAttributes.containsKey(attr)) {
        // We didn't already serialize the attribute or it's a SelectorList. Latter may
        // have been flattened while we want the full representation, so we start from scratch.
        attrPb =
            AttributeFormatter.getAttributeProto(
                attr,
                valueToHash,
                /* explicitlySpecified= */ false, // We care about value, not how it was set.
                /* encodeBooleanAndTriStateAsIntegerAndString= */ false,
                /* sourceAspect= */ null,
                includeAttributeSourceAspects);
      } else {
        attrPb = serializedAttributes.get(attr);
      }

      try {
        attrPb.writeTo(codedOut);
      } catch (IOException e) {
        throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
      }
    }

    try {
      // Rules can be considered changed when the containing package goes in/out of error.
      codedOut.writeBoolNoTag(rule.getPackage().containsErrors());
    } catch (IOException e) {
      throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
    }

    try {
      // Include a summary of any package-wide data that applies to this target (e.g. custom make
      // variables aka `vardef`).
      codedOut.writeStringNoTag((String) extraDataForAttrHash);
    } catch (IOException e) {
      throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
    }

    try {
      // Flush coded out to make sure all bytes make it to the underlying digest stream.
      codedOut.flush();
    } catch (IOException e) {
      throw new IllegalStateException(""Unexpected flush failure"", e);
    }

    return BaseEncoding.base64().encode(hashingOutputStream.hash().asBytes());
  }
}
","rawAttributeMapper
",attributeM,rawAttributeMapper,rawAttributeMapper,rawAttributeMapper,
"
package com.facebook.drawee.drawable;

import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.os.SystemClock;
import androidx.annotation.VisibleForTesting;
import com.facebook.common.internal.Preconditions;

/** Drawable that automatically rotates underlying drawable. */
public class AutoRotateDrawable extends ForwardingDrawable implements Runnable, CloneableDrawable {
  private static final int DEGREES_IN_FULL_ROTATION = 360;
  private static final int FRAME_INTERVAL_MS = 20;

  // Specified duration in milliseconds for one complete rotation.
  private int mInterval;
  // Specified rotation direction
  private boolean mClockwise;

  // Current angle by which the drawable is rotated.
  @VisibleForTesting float mRotationAngle = 0;

  // Whether we have our next frame scheduled for update
  private boolean mIsScheduled = false;

  /**
   * Creates a new AutoRotateDrawable with given underlying drawable, interval and a clockwise
   * rotation.
   *
   * @param drawable underlying drawable to apply the rotation to
   * @param interval duration in milliseconds of one complete rotation
   */
  public AutoRotateDrawable(Drawable drawable, int interval) {
    this(drawable, interval, true);
  }

  /**
   * Creates a new AutoRotateDrawable with given underlying drawable and interval.
   *
   * @param drawable underlying drawable to apply the rotation to
   * @param interval duration in milliseconds of one complete rotation
   * @param clockwise defines whether the rotation is clockwise or not
   */
  public AutoRotateDrawable(Drawable drawable, int interval, boolean clockwise) {
    super(Preconditions.checkNotNull(drawable));
    mInterval = interval;
    mClockwise = clockwise;
  }

  /** Resets to the initial state. */
  public void reset() {
    mRotationAngle = 0;
    mIsScheduled = false;
    unscheduleSelf(this);
    invalidateSelf();
  }

  /** Define whether the rotation is clockwise or not. By default is the rotation clockwise. */
  public void setClockwise(boolean clockwise) {
    mClockwise = clockwise;
  }

  @Override
  public void draw(Canvas canvas) {
    int  [MASK]  = canvas.save();

    Rect bounds = getBounds();
    int width = bounds.right - bounds.left;
    int height = bounds.bottom - bounds.top;

    float angle = mRotationAngle;
    if (!mClockwise) {
      angle = DEGREES_IN_FULL_ROTATION - mRotationAngle;
    }
    canvas.rotate(angle, bounds.left + width / 2, bounds.top + height / 2);
    super.draw(canvas);
    canvas.restoreToCount( [MASK] );

    scheduleNextFrame();
  }

  @Override
  public void run() {
    mIsScheduled = false;
    mRotationAngle += getIncrement();
    invalidateSelf();
  }

  @Override
  public AutoRotateDrawable cloneDrawable() {
    Drawable delegateCopy = DrawableUtils.cloneDrawable(getDrawable());
    return new AutoRotateDrawable(delegateCopy, mInterval, mClockwise);
  }

  /**
   * Schedule the next frame for drawing.
   *
   * <p>Ideally, we'd like to call this from the callback (i.e. {@code run()}), but if we do there's
   * no place where we can call scheduleNextFrame() for the first time. As a tradeoff, we call this
   * from draw(), which means scheduleNextFrame() could technically be called multiple times for the
   * same frame, so we must handle that gracefully.
   */
  private void scheduleNextFrame() {
    if (!mIsScheduled) {
      mIsScheduled = true;
      scheduleSelf(this, SystemClock.uptimeMillis() + FRAME_INTERVAL_MS);
    }
  }

  private int getIncrement() {
    return (int) (((float) FRAME_INTERVAL_MS) / mInterval * DEGREES_IN_FULL_ROTATION);
  }
}
","saveCount
",count,startCount,saveCount,saveCount,
"

package com.google.devtools.build.lib.query2.query.output;

import com.google.common.base.Preconditions;
import com.google.common.flogger.GoogleLogger;
import com.google.common.hash.HashFunction;
import com.google.common.hash.HashingOutputStream;
import com.google.common.io.BaseEncoding;
import com.google.common.io.ByteStreams;
import com.google.devtools.build.lib.packages.Attribute;
import com.google.devtools.build.lib.packages.Attribute.ComputedDefault;
import com.google.devtools.build.lib.packages.AttributeFormatter;
import com.google.devtools.build.lib.packages.BuildType.SelectorList;
import com.google.devtools.build.lib.packages.RawAttributeMapper;
import com.google.devtools.build.lib.packages.Rule;
import com.google.devtools.build.lib.packages.RuleClass;
import com.google.devtools.build.lib.query2.proto.proto2api.Build;
import com.google.protobuf.CodedOutputStream;
import java.io.IOException;
import java.util.Map;

/**
 * Contains the logic for condensing the various properties of rules that contribute to their
 * ""affectedness"" into a simple hash value. The resulting hash may be compared across queries to
 * tell if a rule has changed in a potentially meaningful way.
 */
class SyntheticAttributeHashCalculator {

  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();

  private SyntheticAttributeHashCalculator() {}

  /**
   * Returns a hash of various properties of a rule which might contribute to the rule's
   * ""affectedness"". This includes, but is not limited to, attribute values and error-state.
   *
   * @param rule The rule instance to calculate the hash for.
   * @param serializedAttributes Any available attribute which have already been serialized. This is
   *     an optimization to avoid re-serializing attributes internally.
   * @param extraDataForAttrHash Extra data to add to the hash.
   */
  static String compute(
      Rule rule,
      Map<Attribute, Build.Attribute> serializedAttributes,
      Object extraDataForAttrHash,
      HashFunction hashFunction,
      boolean includeAttributeSourceAspects) {
    HashingOutputStream hashingOutputStream =
        new HashingOutputStream(hashFunction, ByteStreams.nullOutputStream());
    CodedOutputStream codedOut = CodedOutputStream.newInstance(hashingOutputStream);

    RuleClass ruleClass = rule.getRuleClassObject();
    if (ruleClass.isStarlark()) {
      try {
        codedOut.writeByteArrayNoTag(
            Preconditions.checkNotNull(ruleClass.getRuleDefinitionEnvironmentDigest(), rule));
      } catch (IOException e) {
        throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
      }
    }

    RawAttributeMapper rawAttributeMapper = RawAttributeMapper.of(rule);
    for (Attribute attr : rule.getAttributes()) {
      String attrName = attr.getName();

      if (attrName.equals(""generator_location"")) {
        // generator_location can be ignored for the purpose of telling if a rule has changed.
        continue;
      }

      Object valueToHash = rawAttributeMapper.getRawAttributeValue(rule, attr);

      if (valueToHash instanceof ComputedDefault) {
        // ConfiguredDefaults need special handling to detect changes in evaluated values.
        ComputedDefault  [MASK]  = (ComputedDefault) valueToHash;
        if (! [MASK] .dependencies().isEmpty()) {
          // TODO(b/29038463): We're skipping computed defaults that depend on other configurable
          // attributes because there currently isn't a way to evaluate such a computed default;
          // there isn't *one* value it evaluates to.
          continue;
        }

        try {
          valueToHash =  [MASK] .getDefault(rawAttributeMapper);
        } catch (IllegalArgumentException e) {
          // TODO(mschaller): Catching IllegalArgumentException isn't ideal. It's thrown by
          // AbstractAttributeMapper#get if the attribute's type doesn't match its value, which
          // would happen if a ComputedDefault function accessed an attribute whose value was
          // configurable. We check whether the ComputedDefault declared any configurable
          // attribute dependencies above, but someone could make a mistake and fail to declare
          // something. There's no mechanism that enforces correct declaration right now.
          // This allows us to recover from such an error by skipping an attribute, as opposed to
          // crashing.
          logger.atWarning().log(
              ""Recovering from failed evaluation of ComputedDefault attribute value: %s"", e);
          continue;
        }
      }

      Build.Attribute attrPb;
      if (valueToHash instanceof SelectorList<?> || !serializedAttributes.containsKey(attr)) {
        // We didn't already serialize the attribute or it's a SelectorList. Latter may
        // have been flattened while we want the full representation, so we start from scratch.
        attrPb =
            AttributeFormatter.getAttributeProto(
                attr,
                valueToHash,
                /* explicitlySpecified= */ false, // We care about value, not how it was set.
                /* encodeBooleanAndTriStateAsIntegerAndString= */ false,
                /* sourceAspect= */ null,
                includeAttributeSourceAspects);
      } else {
        attrPb = serializedAttributes.get(attr);
      }

      try {
        attrPb.writeTo(codedOut);
      } catch (IOException e) {
        throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
      }
    }

    try {
      // Rules can be considered changed when the containing package goes in/out of error.
      codedOut.writeBoolNoTag(rule.getPackage().containsErrors());
    } catch (IOException e) {
      throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
    }

    try {
      // Include a summary of any package-wide data that applies to this target (e.g. custom make
      // variables aka `vardef`).
      codedOut.writeStringNoTag((String) extraDataForAttrHash);
    } catch (IOException e) {
      throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
    }

    try {
      // Flush coded out to make sure all bytes make it to the underlying digest stream.
      codedOut.flush();
    } catch (IOException e) {
      throw new IllegalStateException(""Unexpected flush failure"", e);
    }

    return BaseEncoding.base64().encode(hashingOutputStream.hash().asBytes());
  }
}
","computedDefault
",computedDefaultProCache,computedDefaultCache,computedDefault,computedDefaultValue,
"

package jenkins.install;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.not;

import edu.umd.cs.findbugs.annotations.NonNull;
import hudson.FilePath;
import hudson.model.DownloadService;
import hudson.model.UpdateSite;
import hudson.security.AuthorizationStrategy;
import hudson.security.SecurityRealm;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.TrustAnchor;
import java.security.cert.X509Certificate;
import java.util.HashSet;
import java.util.Set;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import jenkins.model.Jenkins;
import jenkins.util.JSONSignatureValidator;
import org.eclipse.jetty.server.Request;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.ServerConnector;
import org.eclipse.jetty.server.handler.AbstractHandler;
import org.htmlunit.Page;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import org.junit.rules.TemporaryFolder;
import org.jvnet.hudson.test.Issue;
import org.jvnet.hudson.test.JenkinsRule;
import org.jvnet.hudson.test.SmokeTest;

/**
 * Tests of {@link SetupWizard}.
 * @author Oleg Nenashev
 */
@Category(SmokeTest.class)
public class SetupWizardTest {

    @Rule
    public JenkinsRule j = new JenkinsRule();

    @Rule
    public TemporaryFolder tmpdir = new TemporaryFolder();

    @Before
    public void initSetupWizard() throws IOException, InterruptedException {
        final SetupWizard  [MASK]  = j.jenkins.getSetupWizard();
         [MASK] .init(true);

        // Retrieve admin credentials
        final FilePath adminPassFile =  [MASK] .getInitialAdminPasswordFile();
        ByteArrayOutputStream ostream = new ByteArrayOutputStream();
        adminPassFile.copyTo(ostream);
        final String password = ostream.toString(StandardCharsets.UTF_8);
    }

    @Test
    public void shouldReturnPluginListsByDefault() throws Exception {
        JenkinsRule.WebClient wc = j.createWebClient();
        // TODO: This is a hack, wc.login does not work with the form
        j.jenkins.setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);
        j.jenkins.setAuthorizationStrategy(AuthorizationStrategy.UNSECURED);
        // wc.setCredentialsProvider(adminCredentialsProvider);
        // wc.login(""admin"");

        String response = jsonRequest(wc, ""setupWizard/platformPluginList"");
        assertThat(""Missing plugin is suggestions "", response, containsString(""active-directory""));
        assertThat(""Missing category is suggestions "", response, containsString(""Pipelines and Continuous Delivery""));
    }

    @Test
    @Issue(""JENKINS-34833"")
    public void shouldReturnUpdateSiteJSONIfSpecified() throws Exception {
        // Init the update site
        CustomLocalUpdateSite us = new CustomLocalUpdateSite(tmpdir.getRoot());
        us.init();
        j.jenkins.getUpdateCenter().getSites().add(us);

        // Prepare the connection
        JenkinsRule.WebClient wc = j.createWebClient();
        // TODO: This is a hack, wc.login does not work with the form
        j.jenkins.setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);
        j.jenkins.setAuthorizationStrategy(AuthorizationStrategy.UNSECURED);
        // wc.setCredentialsProvider(adminCredentialsProvider);
        // wc.login(""admin"");

        String response = jsonRequest(wc, ""setupWizard/platformPluginList"");
        assertThat(""Missing plugin in suggestions "", response, containsString(""antisamy-markup-formatter""));
        assertThat(""Missing category in suggestions "", response, containsString(""Organization and Administration""));
        assertThat(""Unexpected plugin in suggestions "", response, not(containsString(""active-directory"")));
        assertThat(""Unexpected category in suggestions "", response, not(containsString(""Pipelines and Continuous Delivery"")));
    }

    @Test
    @Issue(""JENKINS-34833"")
    public void shouldReturnWrappedUpdateSiteJSONIfSpecified() throws Exception {
        // Init the update site
        CustomLocalUpdateSiteWithWrapperJSON us = new CustomLocalUpdateSiteWithWrapperJSON(tmpdir.getRoot());
        us.init();
        j.jenkins.getUpdateCenter().getSites().add(us);

        // Prepare the connection
        JenkinsRule.WebClient wc = j.createWebClient();
        // TODO: This is a hack, wc.login does not work with the form
        j.jenkins.setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);
        j.jenkins.setAuthorizationStrategy(AuthorizationStrategy.UNSECURED);
        // wc.setCredentialsProvider(adminCredentialsProvider);
        // wc.login(""admin"");

        String response = jsonRequest(wc, ""setupWizard/platformPluginList"");
        assertThat(""Missing plugin in suggestions "", response, containsString(""dashboard-view""));
        assertThat(""Missing category in suggestions "", response, containsString(""Administration and Organization""));
        assertThat(""Unexpected plugin in suggestions "", response, not(containsString(""matrix-auth"")));
        assertThat(""Unexpected category in suggestions "", response, not(containsString(""Pipelines and Continuous Delivery"")));
    }

    @Test
    public void shouldProhibitAccessToPluginListWithoutAuth() throws Exception {
        JenkinsRule.WebClient wc = j.createWebClient();
        wc.assertFails(""setupWizard/platformPluginList"", 403);
        wc.assertFails(""setupWizard/createAdminUser"", 403);
        wc.assertFails(""setupWizard/completeInstall"", 403);
    }

    private String jsonRequest(JenkinsRule.WebClient wc, String path) throws Exception {
        // Try to call the actions method to retrieve the data
        final Page res;
        try {
            res = wc.goTo(path, null);
        } catch (Exception ex) {
            ex.getMessage();
            throw new AssertionError(""Cannot get a response from "" + path, ex);
        }
        final String responseJSON = res.getWebResponse().getContentAsString();
        return responseJSON;
    }

    private static final class CustomLocalUpdateSite extends UpdateSite {

        private final File tmpdir;

        CustomLocalUpdateSite(File tmpdir) throws MalformedURLException {
            super(""custom-uc"", tmpdir.toURI().toURL() + ""update-center.json"");
            this.tmpdir = tmpdir;
        }

        public void init() throws IOException {
            Path newPath = tmpdir.toPath().resolve(""platform-plugins.json"");
            Files.writeString(newPath, ""[ { ""
                    + ""\""category\"":\""Organization and Administration\"", ""
                    + ""\""plugins\"": [ { \""name\"": \""antisamy-markup-formatter\"" } ]""
                    + ""} ]"", StandardCharsets.UTF_8);
        }
    }

    private static final class CustomLocalUpdateSiteWithWrapperJSON extends UpdateSite {

        private final File tmpdir;

        CustomLocalUpdateSiteWithWrapperJSON(File tmpdir) throws MalformedURLException {
            super(""custom-uc2"", tmpdir.toURI().toURL() + ""update-center.json"");
            this.tmpdir = tmpdir;
        }

        public void init() throws IOException {
            Path newPath = tmpdir.toPath().resolve(""platform-plugins.json"");
            Files.writeString(newPath, ""{ \""categories\"" : [ { ""
                    + ""\""category\"":\""Administration and Organization\"", ""
                    + ""\""plugins\"": [ { \""name\"": \""dashboard-view\""} ]""
                    + ""} ] }"", StandardCharsets.UTF_8);
        }
    }

    @Test
    public void testRemoteUpdateSiteFailingValidation() throws Exception {
        URL baseUrl;
        final String serverContext = ""/_relative/"";
        Server server = new Server();
        ServerConnector connector = new ServerConnector(server);
        server.addConnector(connector);
        server.setHandler(new RemoteUpdateSiteHandler(serverContext, true));
        try {
            server.start();
            baseUrl = new URL(""http"", ""localhost"", connector.getLocalPort(), serverContext);

            // Init the update site
            CustomRemoteUpdateSite us = new CustomRemoteUpdateSite(baseUrl.toString(), false);
            j.jenkins.getUpdateCenter().getSites().add(us);

            // Prepare the connection
            JenkinsRule.WebClient wc = j.createWebClient();
            // TODO: This is a hack, wc.login does not work with the form
            j.jenkins.setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);
            j.jenkins.setAuthorizationStrategy(AuthorizationStrategy.UNSECURED);
            // wc.setCredentialsProvider(adminCredentialsProvider);
            // wc.login(""admin"");

            String response = jsonRequest(wc, ""setupWizard/platformPluginList"");
            // We need to assert that signature check fails, and we're falling back to the bundled resource
            assertThat(""Missing plugin in suggestions "", response, not(containsString(""my-plugin"")));
            assertThat(""Missing category in suggestions "", response, not(containsString(""Very Useful Category"")));
        } finally {
            server.stop();
        }
    }

    @Test
    public void testRemoteUpdateSiteSkippingValidation() throws Exception {
        URL baseUrl;
        final String serverContext = ""/_relative/"";
        Server server = new Server();
        ServerConnector connector = new ServerConnector(server);
        server.addConnector(connector);
        server.setHandler(new RemoteUpdateSiteHandler(serverContext, true));
        try {
            server.start();
            DownloadService.signatureCheck = false;
            baseUrl = new URL(""http"", ""localhost"", connector.getLocalPort(), serverContext);

            // Init the update site
            CustomRemoteUpdateSite us = new CustomRemoteUpdateSite(baseUrl.toString(), false);
            j.jenkins.getUpdateCenter().getSites().add(us);


            // Prepare the connection
            JenkinsRule.WebClient wc = j.createWebClient();
            // TODO: This is a hack, wc.login does not work with the form
            j.jenkins.setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);
            j.jenkins.setAuthorizationStrategy(AuthorizationStrategy.UNSECURED);
            // wc.setCredentialsProvider(adminCredentialsProvider);
            // wc.login(""admin"");

            String response = jsonRequest(wc, ""setupWizard/platformPluginList"");
            // We need to assert that signature check fails, and we're falling back to the bundled resource
            assertThat(""Missing plugin in suggestions "", response, containsString(""my-plugin""));
            assertThat(""Missing category in suggestions "", response, containsString(""Very Useful Category""));
            assertThat(""Unexpected plugin in suggestions "", response, not(containsString(""matrix-auth"")));
            assertThat(""Unexpected category in suggestions "", response, not(containsString(""Pipelines and Continuous Delivery"")));
        } finally {
            DownloadService.signatureCheck = true;
            server.stop();
        }
    }

    @Test
    public void testRemoteUpdateSitePerformingValidation() throws Exception {
        URL baseUrl;
        final String serverContext = ""/_relative/"";
        Server server = new Server();
        ServerConnector connector = new ServerConnector(server);
        server.addConnector(connector);
        server.setHandler(new RemoteUpdateSiteHandler(serverContext, true));
        try {
            server.start();
            baseUrl = new URL(""http"", ""localhost"", connector.getLocalPort(), serverContext);

            // Init the update site
            CustomRemoteUpdateSite us = new CustomRemoteUpdateSite(baseUrl.toString(), true);
            j.jenkins.getUpdateCenter().getSites().add(us);


            // Prepare the connection
            JenkinsRule.WebClient wc = j.createWebClient();
            // TODO: This is a hack, wc.login does not work with the form
            j.jenkins.setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);
            j.jenkins.setAuthorizationStrategy(AuthorizationStrategy.UNSECURED);
            // wc.setCredentialsProvider(adminCredentialsProvider);
            // wc.login(""admin"");

            String response = jsonRequest(wc, ""setupWizard/platformPluginList"");
            // We need to assert that signature check fails, and we're falling back to the bundled resource
            assertThat(""Missing plugin in suggestions "", response, containsString(""my-plugin""));
            assertThat(""Missing category in suggestions "", response, containsString(""Very Useful Category""));
            assertThat(""Unexpected plugin in suggestions "", response, not(containsString(""matrix-auth"")));
            assertThat(""Unexpected category in suggestions "", response, not(containsString(""Pipelines and Continuous Delivery"")));
        } finally {
            server.stop();
        }
    }

    private static final class CustomRemoteUpdateSite extends UpdateSite {
        private boolean customValidator;

        CustomRemoteUpdateSite(String baseUrl, boolean customValidator) throws MalformedURLException {
            super(""custom-uc2"", baseUrl + ""update-center.json"");
            this.customValidator = customValidator;
        }

        @NonNull
        @Override
        protected JSONSignatureValidator getJsonSignatureValidator(String name) {
            if (customValidator) {
                return new CustomJSONSignatureValidator(CERT);
            }
            return super.getJsonSignatureValidator(name);
        }
    }

    private static class RemoteUpdateSiteHandler extends AbstractHandler {
        private String serverContext;
        private boolean includeSignature;

        // TODO we can always include the signature, a signature that isn't configured client-side behaves as if unsigned.
        RemoteUpdateSiteHandler(String serverContext, boolean includeSignature) {
            this.serverContext = serverContext;
            this.includeSignature = includeSignature;
        }

        @Override
        public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
            String responseBody = getWebServerResource(target, request.getParameter(""version""));
            if (responseBody != null) {
                baseRequest.setHandled(true);
                response.setContentType(""text/plain; charset=utf-8"");
                response.setStatus(HttpServletResponse.SC_OK);
                response.getOutputStream().write(responseBody.getBytes(StandardCharsets.UTF_8));
            } else {
                response.sendError(404);
            }
        }

        private String getWebServerResource(String target, String version) throws IOException {
            if (target.equals(serverContext + ""platform-plugins.json"")) {
                if (version == null) {
                    throw new IOException(""?version parameter value is missing"");
                }
                if (!version.equals(Jenkins.getVersion().toString())) {
                    throw new IOException(""Unexpected ?version parameter value: "" + version);
                }
                if (includeSignature) {
                    return ""{ \""categories\"":[ {\n"" +
                            ""\""category\"":\""Very Useful Category\"",\n"" +
                            ""\""plugins\"":[ {\""name\"":\""my-plugin\"", \""suggested\"":false } ]\n"" +
                            ""} ],\n"" +
                            ""\""signature\"":{\n"" +
                            ""\""certificates\"":[\n"" +
                            ""\""MIIFdDCCA1wCCQC9xxIN0UapszANBgkqhkiG9w0BAQsFADB8MRowGAYDVQQKDBFsb2"" +
                            ""NhbC1kZXZlbG9wbWVudDEaMBgGA1UECwwRbG9jYWwtZGV2ZWxvcG1lbnQxGjAYBgNVBA"" +
                            ""MMEWxvY2FsLWRldmVsb3BtZW50MSYwJAYJKoZIhvcNAQkBFhdleGFtcGxlQGV4YW1wbG"" +
                            ""UuaW52YWxpZDAeFw0yMTAzMTgxODM0MzFaFw0yNjAyMjAxODM0MzFaMHwxGjAYBgNVBA"" +
                            ""oMEWxvY2FsLWRldmVsb3BtZW50MRowGAYDVQQLDBFsb2NhbC1kZXZlbG9wbWVudDEaMB"" +
                            ""gGA1UEAwwRbG9jYWwtZGV2ZWxvcG1lbnQxJjAkBgkqhkiG9w0BCQEWF2V4YW1wbGVAZX"" +
                            ""hhbXBsZS5pbnZhbGlkMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAz0k6D4"" +
                            ""HtPoSvLUKrtcHkBHTyd4Zd1EZkwD7V3CgoLOFYboozjPX3U+q3paGUaQZ9Ejggbq5Cws"" +
                            ""v7PHpn89OQ20Cy53RF19pChX2Zx/uuF5SjMapchtAJIwj0EjQNo5MqYuRjm6kOFA6ZwD"" +
                            ""13nLxeH1YfWeKN7xPkmbMkc1ruXrZNd9XPYtmGNFR8oH/N1CYc7dZ3RNZLwMNZv3981y"" +
                            ""VcZ19T5JvyxlTCaWDsr6ODgNx0zG0mc0nAdDi+TSNxzJfoIF+klkc9IODsqhrE6CpD0R"" +
                            ""1Wny7sedUc/cxviO2lmKGq+3bqUIq4Xlr/q8kCFVC478QM9zj6/SmFzMioXGq4JFHj0m"" +
                            ""1Am6pIpay1hqCZeKXXIRMs80KC3XCQ2+z+woP/Iu4fJyclwGxfPh0zq+cPDwtyH5VkX1"" +
                            ""QBMv3ge2Ks7wESTd3HaZrkt+/2Mk9eo7o0IVxeq/BQ9rwvtzfrxynuhLBXOTh1ViZYC5"" +
                            ""8wYT8UZ/3F8GKveW3LlgXf0cdpTl7xGUdw4dOq5IkgPgJZZ6oB757NXPLa68wlcx8acR"" +
                            ""A7xv4IqdjuSDEZVF48UJi57GPJKnhi+9bWFpz7l1c0Yh2LGY3DoHPJ4WXctFrHTaY3+v"" +
                            ""AyiSBgFMCwYyxTdI33b5MeMlS56xuBUxZCqsnwlqvDH2jECa+oqzOa29s0EftdMn8CAw"" +
                            ""EAATANBgkqhkiG9w0BAQsFAAOCAgEAQ42dkh6fmFVoCRzh/UUC/XCyiXL3DvzzPmjuwK"" +
                            ""B2l3+C2ysvTtpCsiVj3KZcJztxbPMysllQ5M6VGbKuzwxtsBNn+XQwpbM9MBYJH7q9Xl"" +
                            ""1p+T3/KOHY3mbXh5+Ka1m7cJHkj6E1P6yIykDLC3pF4MEzqMW33NBxymeax3Xgztq+sP"" +
                            ""xfV0qv8102rezFOsO5ke1a52zlLgyuzTMPLgc1mBiQfM1q0b+aQl05dU54k1dEN8DVCP"" +
                            ""BZXbFc2s6ewXmPu+yyDqK/iMORa8jmHJtZpL+UMzPNrLxC7k32LQBVt/OZFiQDCW9oAT"" +
                            ""I7wVKhC/yls/cP5mfrhckrP/uxqTKwOS6TgkwT/rHQ11TzBlLCKX1RqfGn20zQ/lMyvf"" +
                            ""K4uFBpiMZkg/m9Wr5DiOMLHj44thlI3oH9Qko3kBLj4nr01Vg29IJgsPbkNYKrOwGFXg"" +
                            ""CWqpNJZEVqjA5SNpRNFMUpRtDLrJla3xIWRxo/rCCe5GNBoJeT9d0TlKu//lCOQUwzcW"" +
                            ""E8K5yesjWXPXCXDRA0a+/LSi9YIqGUNWAvoPQ5FWyRekcAu5mKr6BqaertX2dzF3/PYJ"" +
                            ""2VgW9jT8nDi1D0zmEdbrtKVGuKqR04SI6ZI8NvyheUbzsV0q4Qt2V2uHcQ4j8AErff7W"" +
                            ""DPFdn7P7FyaV0h0zBv6/XJs1JSb3nwtHA=\""\n"" +
                            ""],\n"" +
                            ""\""correct_digest\"":\""Gm5yn9FM+pTT5yHYCZZchmXjd4U=\"",\n"" +
                            ""\""correct_digest512\"":\""67a9853b8a3fe322a321af26915c7fd503d89be787b3"" +
                            ""f7c1e8d8a8413d7458ad75f12f75fe1b5d9c672e048e1bd3b60fc294779f8606701e"" +
                            ""0435b41dc5602e97\"",\n"" +
                            ""\""correct_signature\"":\""XjqrkmZ4FB8WDewkKymuoG13P477SlnugZ/rIea6/tP2"" +
                            ""7urcwHhLq9HpvfqFHBN+xcMStXat+m2E0MZvxEg4Tdaiw2rELHvPCglm1pUPIBeXSNMp"" +
                            ""poyTy+qg9w2Z3nNGB8ZoCkJy2/Bq28P/CzKwgBuBeKObAk6t6Xuhwm+MbxDHAg1j/Hma"" +
                            ""n9pj9X9AeOW6mlGXG7wVgtS3CwGf7dtNQNnNjIWosvMe4WLw9Yo2JuVBi+p3VtxMfwaf"" +
                            ""MbZEwGK9Dh1EFZHiBsjb+ksvSFfEa/h3C2EXQYi8+jIbGYO0HCVZPvFv3TRvj30ogku2"" +
                            ""yXvUrK0uAw5e65e2dZmRMr5yCrOfzRYAafxd47peSn2+kyWquxsTzUqwhelquvY3w9fE"" +
                            ""3Hmv4tSIU9lJvBUeu/IQEDJ3ET5XzFX3fHhw5O3FV54eLWLsTx4tfRWVfn90Nu/YEpz5"" +
                            ""F67CZE75ci9wGzOTcqVkC9aW2jqAS8TlpgkDgaflggG2mjJIjOHuyrUBMD9X0Ie7UUY/"" +
                            ""6H/j4fnTkHy+ea80VKhrn9S+qggIjbvp9VH+xgl0vHQ5I3+NwOchVOdIsCU6dZkZeOko"" +
                            ""hfcc4LLSihJ86zovi9PJmVRv2CATGwghika6hhfAhKjh7ZbD0Dcd3qO3qbqud/LEN5l7"" +
                            ""fJBaO4iMMKWzlV0Sa7k1q/zWxp8=\"",\n"" +
                            ""\""correct_signature512\"":\""a197809570f986fa34f3e264b11a3beed3e08794b"" +
                            ""0f8991302a1418544ef7d75beb296c5fa0e17b8eeb06305e5279ea8680ee2f161b2e"" +
                            ""c9c926b2491aa1286ecd82865e9141f790114762fa09e1f23f4f521f283875308222"" +
                            ""6a6cb28f1439312ec1eec66aea7f220035b2808bd3f30300f81a6685e8f89b82a20f"" +
                            ""470706bc83c2ffb2e5d65c0a682263d291849dddafe0be442d9b73e3737a86b5992d"" +
                            ""96698272b9d9efaa8c2475a4020e5cd8d56b715fb6844d98539ab4c31eb7a8080b82"" +
                            ""31ee2452fc765407203f858af5211a3288ee8f2f9cefa4dd02f5164a1b241681cf7c"" +
                            ""81b203ded13e47484a041dc10eb988c398a0a94bed8ddd70a0c65a6a378f09e5e138"" +
                            ""a802300731865fc9e894c7eeeaf59efbe8f8f845ae101cbcd32ebba017d4413c806c"" +
                            ""bca1a0ef0e586fe1f43b9d015574ef8d2da0808df574fe6946c6301d82b2267f9751"" +
                            ""e977888568946870b17c001f3a09203f71f79035b55b7d77b2fd2ef00db89a0839cd"" +
                            ""21ee5bd2bc1b552c67d48f8d0c76888b8b64d1007a6594d0975b6b3220d180daadb0"" +
                            ""75607a406b5e5ecd4f44c79536017bb37847d6e5bbd309579e88527e7dddb459c8d7"" +
                            ""22157ea22dbb2686a2ef4e3d9ca27b59144326ea1f6eab27b51dadb7355414c41f9d"" +
                            ""0c9185a63ab3b0a4da40a37cb2680d0999d46cddddfdad2d10fe11d1104486db5923"" +
                            ""a95c2b1ad98f26882ee91c3c5f347b6\""\n"" +
                            ""} }"";
                } else {
                    return ""{ \""categories\"" : [ { ""
                            + ""\""category\"":\""Very Useful Category\"", ""
                            + ""\""plugins\"": [ { \""name\"": \""my-plugin\""} ]""
                            + ""} ] }"";
                }
            }
            return null;
        }
    }

    private static class CustomJSONSignatureValidator extends JSONSignatureValidator {
        private String cert;

        CustomJSONSignatureValidator(String cert) {
            super(""Custom JSON signature validator"");
            this.cert = cert;
        }

        @Override
        protected Set<TrustAnchor> loadTrustAnchors(CertificateFactory cf) throws IOException {
            Set<TrustAnchor> trustAnchors = new HashSet<>();
            try {
                Certificate certificate = cf.generateCertificate(new ByteArrayInputStream(cert.getBytes(StandardCharsets.UTF_8)));
                trustAnchors.add(new TrustAnchor((X509Certificate) certificate, null));
            } catch (CertificateException ex) {
                throw new IOException(ex);
            }
            return trustAnchors;
        }
    }

    // Used to test signature validation in remote platform-plugins JSON
    // Generated using:
    // openssl genrsa -out demo.key 4096
    // openssl req -new -x509 -days 1800 -key demo.key -out demo.crt -subj ""/C=/ST=/L=/O=local-development/OU=local-development/CN=local-development/emailAddress=example@example.invalid""
    // Then signed using update-center2 args: --key demo.key --certificate demo.crt --pretty-json --root-certificate demo.crt --generate-platform-plugins --skip-update-center --www-dir output
    private static final String CERT = ""-----BEGIN CERTIFICATE-----\n"" +
            ""MIIFdDCCA1wCCQC9xxIN0UapszANBgkqhkiG9w0BAQsFADB8MRowGAYDVQQKDBFs\n"" +
            ""b2NhbC1kZXZlbG9wbWVudDEaMBgGA1UECwwRbG9jYWwtZGV2ZWxvcG1lbnQxGjAY\n"" +
            ""BgNVBAMMEWxvY2FsLWRldmVsb3BtZW50MSYwJAYJKoZIhvcNAQkBFhdleGFtcGxl\n"" +
            ""QGV4YW1wbGUuaW52YWxpZDAeFw0yMTAzMTgxODM0MzFaFw0yNjAyMjAxODM0MzFa\n"" +
            ""MHwxGjAYBgNVBAoMEWxvY2FsLWRldmVsb3BtZW50MRowGAYDVQQLDBFsb2NhbC1k\n"" +
            ""ZXZlbG9wbWVudDEaMBgGA1UEAwwRbG9jYWwtZGV2ZWxvcG1lbnQxJjAkBgkqhkiG\n"" +
            ""9w0BCQEWF2V4YW1wbGVAZXhhbXBsZS5pbnZhbGlkMIICIjANBgkqhkiG9w0BAQEF\n"" +
            ""AAOCAg8AMIICCgKCAgEAz0k6D4HtPoSvLUKrtcHkBHTyd4Zd1EZkwD7V3CgoLOFY\n"" +
            ""boozjPX3U+q3paGUaQZ9Ejggbq5Cwsv7PHpn89OQ20Cy53RF19pChX2Zx/uuF5Sj\n"" +
            ""MapchtAJIwj0EjQNo5MqYuRjm6kOFA6ZwD13nLxeH1YfWeKN7xPkmbMkc1ruXrZN\n"" +
            ""d9XPYtmGNFR8oH/N1CYc7dZ3RNZLwMNZv3981yVcZ19T5JvyxlTCaWDsr6ODgNx0\n"" +
            ""zG0mc0nAdDi+TSNxzJfoIF+klkc9IODsqhrE6CpD0R1Wny7sedUc/cxviO2lmKGq\n"" +
            ""+3bqUIq4Xlr/q8kCFVC478QM9zj6/SmFzMioXGq4JFHj0m1Am6pIpay1hqCZeKXX\n"" +
            ""IRMs80KC3XCQ2+z+woP/Iu4fJyclwGxfPh0zq+cPDwtyH5VkX1QBMv3ge2Ks7wES\n"" +
            ""Td3HaZrkt+/2Mk9eo7o0IVxeq/BQ9rwvtzfrxynuhLBXOTh1ViZYC58wYT8UZ/3F\n"" +
            ""8GKveW3LlgXf0cdpTl7xGUdw4dOq5IkgPgJZZ6oB757NXPLa68wlcx8acRA7xv4I\n"" +
            ""qdjuSDEZVF48UJi57GPJKnhi+9bWFpz7l1c0Yh2LGY3DoHPJ4WXctFrHTaY3+vAy\n"" +
            ""iSBgFMCwYyxTdI33b5MeMlS56xuBUxZCqsnwlqvDH2jECa+oqzOa29s0EftdMn8C\n"" +
            ""AwEAATANBgkqhkiG9w0BAQsFAAOCAgEAQ42dkh6fmFVoCRzh/UUC/XCyiXL3Dvzz\n"" +
            ""PmjuwKB2l3+C2ysvTtpCsiVj3KZcJztxbPMysllQ5M6VGbKuzwxtsBNn+XQwpbM9\n"" +
            ""MBYJH7q9Xl1p+T3/KOHY3mbXh5+Ka1m7cJHkj6E1P6yIykDLC3pF4MEzqMW33NBx\n"" +
            ""ymeax3Xgztq+sPxfV0qv8102rezFOsO5ke1a52zlLgyuzTMPLgc1mBiQfM1q0b+a\n"" +
            ""Ql05dU54k1dEN8DVCPBZXbFc2s6ewXmPu+yyDqK/iMORa8jmHJtZpL+UMzPNrLxC\n"" +
            ""7k32LQBVt/OZFiQDCW9oATI7wVKhC/yls/cP5mfrhckrP/uxqTKwOS6TgkwT/rHQ\n"" +
            ""11TzBlLCKX1RqfGn20zQ/lMyvfK4uFBpiMZkg/m9Wr5DiOMLHj44thlI3oH9Qko3\n"" +
            ""kBLj4nr01Vg29IJgsPbkNYKrOwGFXgCWqpNJZEVqjA5SNpRNFMUpRtDLrJla3xIW\n"" +
            ""Rxo/rCCe5GNBoJeT9d0TlKu//lCOQUwzcWE8K5yesjWXPXCXDRA0a+/LSi9YIqGU\n"" +
            ""NWAvoPQ5FWyRekcAu5mKr6BqaertX2dzF3/PYJ2VgW9jT8nDi1D0zmEdbrtKVGuK\n"" +
            ""qR04SI6ZI8NvyheUbzsV0q4Qt2V2uHcQ4j8AErff7WDPFdn7P7FyaV0h0zBv6/XJ\n"" +
            ""s1JSb3nwtHA=\n"" +
            ""-----END CERTIFICATE-----\n"";

}
","wizard
",setupWizard,setupWizard,setupWizard,setupWizard,
"

package com.tencent.tinker.lib.service;

import static com.tencent.tinker.lib.util.TinkerServiceInternals.getTinkerPatchServiceName;

import android.app.ActivityManager;
import android.app.IntentService;
import android.app.Notification;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.IBinder;
import android.os.SystemClock;

import com.tencent.tinker.lib.patch.AbstractPatch;
import com.tencent.tinker.lib.tinker.Tinker;
import com.tencent.tinker.loader.TinkerRuntimeException;
import com.tencent.tinker.loader.shareutil.ShareConstants;
import com.tencent.tinker.loader.shareutil.ShareIntentUtil;
import com.tencent.tinker.loader.shareutil.SharePatchFileUtil;
import com.tencent.tinker.loader.shareutil.ShareTinkerLog;

import java.io.File;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Created by zhangshaowen on 16/3/14.
 */
public class TinkerPatchService extends IntentService {
    private static final String TAG = ""Tinker.TinkerPatchService"";

    private static final String PATCH_PATH_EXTRA = ""patch_path_extra"";
    private static final String PATCH_USE_EMERGENCY_MODE = ""patch_use_emergency_mode"";
    private static final String RESULT_CLASS_EXTRA = ""patch_result_class"";

    private static AbstractPatch upgradePatchProcessor = null;
    private static int notificationId = ShareConstants.TINKER_PATCH_SERVICE_NOTIFICATION;
    private static Class<? extends AbstractResultService> resultServiceClass = null;

    public TinkerPatchService() {
        super(""TinkerPatchService"");
        setIntentRedelivery(true);
    }

    public static void runPatchService(final Context context, final String path) {
        runPatchService(context, path, false);
    }

    public static void runPatchService(final Context context, final String path, boolean useEmergencyMode) {
        ShareTinkerLog.i(TAG, ""run patch service..."");
        Intent intent = new Intent(context, TinkerPatchService.class);
        intent.putExtra(PATCH_PATH_EXTRA, path);
        intent.putExtra(PATCH_USE_EMERGENCY_MODE, useEmergencyMode);
        intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());
        try {
            context.startService(intent);
        } catch (Throwable thr) {
            ShareTinkerLog.e(TAG, ""run patch service fail, exception:"" + thr);
        }
    }

    public static void setPatchProcessor(AbstractPatch upgradePatch, Class<? extends AbstractResultService> serviceClass) {
        upgradePatchProcessor = upgradePatch;
        resultServiceClass = serviceClass;
        //try to load
        try {
            Class.forName(serviceClass.getName());
        } catch (ClassNotFoundException e) {
            ShareTinkerLog.printErrStackTrace(TAG, e, ""patch processor class not found."");
        }
    }

    public static String getPatchPathExtra(Intent intent) {
        if (intent == null) {
            throw new TinkerRuntimeException(""getPatchPathExtra, but intent is null"");
        }
        return ShareIntentUtil.getStringExtra(intent, PATCH_PATH_EXTRA);
    }

    public static boolean getPatchUseEmergencyMode(Intent intent) {
        if (intent == null) {
            throw new TinkerRuntimeException(""getPatchUseEmergencyMode, but intent is null"");
        }
        return ShareIntentUtil.getBooleanExtra(intent, PATCH_USE_EMERGENCY_MODE, false);
    }

    public static String getPatchResultExtra(Intent intent) {
        if (intent == null) {
            throw new TinkerRuntimeException(""getPatchResultExtra, but intent is null"");
        }
        return ShareIntentUtil.getStringExtra(intent, RESULT_CLASS_EXTRA);
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        increasingPriority();
        doApplyPatch(this, intent);
    }

    /**
     * set the tinker notification id you want
     * @param id
     */
    public static void setTinkerNotificationId(int id) {
        notificationId = id;
    }

    private static final String RUNNING_MARKER_FILE_RELPATH_PREFIX = ""patch_service_status/running_"";

    /**
     * Check if TinkerPatchService is running.
     * @param context
     */
    public static boolean isRunning(Context context) {
        try {
            final String serviceName = getTinkerPatchServiceName(context);
            if (serviceName == null) {
                return false;
            }
            final ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            if (am == null) {
                return false;
            }
            final List<ActivityManager.RunningAppProcessInfo> runningProcInfos = am.getRunningAppProcesses();
            if (runningProcInfos == null || runningProcInfos.size() == 0) {
                return false;
            }
            int targetPid = 0;
            for (ActivityManager.RunningAppProcessInfo procInfo : runningProcInfos) {
                if (procInfo.processName.equals(serviceName)) {
                    targetPid = procInfo.pid;
                    break;
                }
            }
            if (targetPid == 0) {
                return false;
            }
            final File tinkerBaseDir = SharePatchFileUtil.getPatchDirectory(context);
            final File runningMarkerFile = new File(tinkerBaseDir, RUNNING_MARKER_FILE_RELPATH_PREFIX + targetPid);
            return runningMarkerFile.exists();
        } catch (Throwable ignored) {
            return false;
        }
    }

    static void markRunning(Context context) {
        final File tinkerBaseDir = SharePatchFileUtil.getPatchDirectory(context);
        final File runningMarkerFile = new File(tinkerBaseDir,
                RUNNING_MARKER_FILE_RELPATH_PREFIX + android.os.Process.myPid());
        if (runningMarkerFile.exists()) {
            return;
        }
        final File runningMarkerDir = runningMarkerFile.getParentFile();
        if (runningMarkerDir.exists()) {
            final File[] markerFiles = runningMarkerDir.listFiles();
            if (markerFiles != null) {
                for (File markerFile : markerFiles) {
                    markerFile.delete();
                }
            }
        } else {
            runningMarkerDir.mkdirs();
        }
        try {
            if (!runningMarkerFile.createNewFile()) {
                throw new IllegalStateException();
            }
        } catch (Throwable thr) {
            ShareTinkerLog.printErrStackTrace(TAG, thr, ""Fail to create running marker file."");
        }
    }

    static void unmarkRunning(Context context) {
        final File tinkerBaseDir = SharePatchFileUtil.getPatchDirectory(context);
        final File runningMarkerFile = new File(tinkerBaseDir,
                RUNNING_MARKER_FILE_RELPATH_PREFIX + android.os.Process.myPid());
        if (runningMarkerFile.exists()) {
            runningMarkerFile.delete();
        }
    }

    private static AtomicBoolean sIsPatchApplying = new AtomicBoolean(false);

    private static void doApplyPatch(Context context, Intent intent) {
        // Since we may retry with IntentService, we should prevent
        // racing here again.
        if (!sIsPatchApplying.compareAndSet(false, true)) {
            ShareTinkerLog.w(TAG, ""TinkerPatchService doApplyPatch is running by another runner."");
            return;
        }

        try {
            markRunning(context);

            Tinker tinker = Tinker.with(context);
            tinker.getPatchReporter().onPatchServiceStart(intent);

            if (intent == null) {
                ShareTinkerLog.e(TAG, ""TinkerPatchService received a null intent, ignoring."");
                return;
            }
            String path = getPatchPathExtra(intent);
            if (path == null) {
                ShareTinkerLog.e(TAG, ""TinkerPatchService can't get the path extra, ignoring."");
                return;
            }
            File  [MASK]  = new File(path);

            final boolean useEmergencyMode = getPatchUseEmergencyMode(intent);

            long begin = SystemClock.elapsedRealtime();
            boolean result;
            long cost;
            Throwable e = null;

            PatchResult patchResult = new PatchResult();
            try {
                if (upgradePatchProcessor == null) {
                    throw new TinkerRuntimeException(""upgradePatchProcessor is null."");
                }
                result = upgradePatchProcessor.tryPatch(context, path, useEmergencyMode, patchResult);
            } catch (Throwable throwable) {
                e = throwable;
                result = false;
                tinker.getPatchReporter().onPatchException( [MASK] , e);
            }

            cost = SystemClock.elapsedRealtime() - begin;
            tinker.getPatchReporter()
                    .onPatchResult( [MASK] , result, cost);

            patchResult.isSuccess = result;
            patchResult.rawPatchFilePath = path;
            patchResult.useEmergencyMode = useEmergencyMode;
            patchResult.totalCostTime = cost;
            patchResult.type = tinker.getCustomPatcher() == null ? PatchResult.PATCH_TYPE_BSDIFF : PatchResult.PATCH_TYPE_CUSTOM;
            patchResult.e = e;


            unmarkRunning(context);
            sIsPatchApplying.set(false);

            AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));
        } finally {
            unmarkRunning(context);
        }
    }

    private void increasingPriority() {
        if (Build.VERSION.SDK_INT >= 26) {
            ShareTinkerLog.i(TAG, ""for system version >= Android O, we just ignore increasingPriority ""
                    + ""job to avoid crash or toasts."");
            return;
        }

        if (""ZUK"".equals(Build.MANUFACTURER)) {
            ShareTinkerLog.i(TAG, ""for ZUK device, we just ignore increasingPriority ""
                    + ""job to avoid crash."");
            return;
        }

        ShareTinkerLog.i(TAG, ""try to increase patch process priority"");
        try {
            Notification notification = new Notification();
            if (Build.VERSION.SDK_INT < 18) {
                startForeground(notificationId, notification);
            } else {
                startForeground(notificationId, notification);
                // start InnerService
                startService(new Intent(this, InnerService.class));
            }
        } catch (Throwable e) {
            ShareTinkerLog.i(TAG, ""try to increase patch process priority error:"" + e);
        }
    }

    /**
     * I don't want to do this, believe me
     */
    public static class InnerService extends Service {
        @Override
        public void onCreate() {
            super.onCreate();
            try {
                startForeground(notificationId, new Notification());
            } catch (Throwable e) {
                ShareTinkerLog.e(TAG, ""InnerService set service for push exception:%s."", e);
            }
            stopSelf();
        }

        @Override
        public void onDestroy() {
            stopForeground(true);
            super.onDestroy();
        }

        @Override
        public IBinder onBind(Intent intent) {
            return null;
        }
    }
}

","patchFile
",context,patchRoot,patchFile,patchFile,
"package jadx.core.dex.regions.conditions;

import java.util.Collections;
import java.util.List;

import org.jetbrains.annotations.Nullable;

import jadx.core.dex.nodes.BlockNode;
import jadx.core.dex.nodes.IConditionRegion;
import jadx.core.dex.nodes.IRegion;
import jadx.core.dex.nodes.InsnNode;
import jadx.core.dex.regions.AbstractRegion;
import jadx.core.utils.BlockUtils;

public abstract class ConditionRegion extends AbstractRegion implements IConditionRegion {

	@Nullable
	private IfCondition condition;
	private List<BlockNode> conditionBlocks = Collections.emptyList();

	public ConditionRegion(IRegion parent) {
		super(parent);
	}

	@Override
	@Nullable
	public IfCondition getCondition() {
		return condition;
	}

	@Override
	public List<BlockNode> getConditionBlocks() {
		return conditionBlocks;
	}

	@Override
	public void invertCondition() {
		if (condition != null) {
			condition = IfCondition.invert(condition);
		}
	}

	@Override
	public boolean simplifyCondition() {
		if (condition == null) {
			return false;
		}
		IfCondition updated = IfCondition.simplify(condition);
		if (updated != condition) {
			condition = updated;
			return true;
		}
		return false;
	}

	@Override
	public int getConditionSourceLine() {
		for (BlockNode block : conditionBlocks) {
			InsnNode lastInsn = BlockUtils.getLastInsn(block);
			if (lastInsn != null) {
				int  [MASK]  = lastInsn.getSourceLine();
				if ( [MASK]  != 0) {
					return  [MASK] ;
				}
			}
		}
		return 0;
	}

	/**
	 * Prefer way for update condition info
	 */
	public void updateCondition(IfInfo info) {
		this.condition = info.getCondition();
		this.conditionBlocks = info.getMergedBlocks();
	}

	public void updateCondition(IfCondition condition, List<BlockNode> conditionBlocks) {
		this.condition = condition;
		this.conditionBlocks = conditionBlocks;
	}

	public void updateCondition(BlockNode block) {
		this.condition = IfCondition.fromIfBlock(block);
		this.conditionBlocks = Collections.singletonList(block);
	}
}
","sourceLine
",sourceLine,sourceLine,sourceLine,sourceLine,
"

package com.google.devtools.build.lib.query2.query.output;

import com.google.common.base.Preconditions;
import com.google.common.flogger.GoogleLogger;
import com.google.common.hash.HashFunction;
import com.google.common.hash.HashingOutputStream;
import com.google.common.io.BaseEncoding;
import com.google.common.io.ByteStreams;
import com.google.devtools.build.lib.packages.Attribute;
import com.google.devtools.build.lib.packages.Attribute.ComputedDefault;
import com.google.devtools.build.lib.packages.AttributeFormatter;
import com.google.devtools.build.lib.packages.BuildType.SelectorList;
import com.google.devtools.build.lib.packages.RawAttributeMapper;
import com.google.devtools.build.lib.packages.Rule;
import com.google.devtools.build.lib.packages.RuleClass;
import com.google.devtools.build.lib.query2.proto.proto2api.Build;
import com.google.protobuf.CodedOutputStream;
import java.io.IOException;
import java.util.Map;

/**
 * Contains the logic for condensing the various properties of rules that contribute to their
 * ""affectedness"" into a simple hash value. The resulting hash may be compared across queries to
 * tell if a rule has changed in a potentially meaningful way.
 */
class SyntheticAttributeHashCalculator {

  private static final GoogleLogger logger = GoogleLogger.forEnclosingClass();

  private SyntheticAttributeHashCalculator() {}

  /**
   * Returns a hash of various properties of a rule which might contribute to the rule's
   * ""affectedness"". This includes, but is not limited to, attribute values and error-state.
   *
   * @param rule The rule instance to calculate the hash for.
   * @param serializedAttributes Any available attribute which have already been serialized. This is
   *     an optimization to avoid re-serializing attributes internally.
   * @param  [MASK]  Extra data to add to the hash.
   */
  static String compute(
      Rule rule,
      Map<Attribute, Build.Attribute> serializedAttributes,
      Object  [MASK] ,
      HashFunction hashFunction,
      boolean includeAttributeSourceAspects) {
    HashingOutputStream hashingOutputStream =
        new HashingOutputStream(hashFunction, ByteStreams.nullOutputStream());
    CodedOutputStream codedOut = CodedOutputStream.newInstance(hashingOutputStream);

    RuleClass ruleClass = rule.getRuleClassObject();
    if (ruleClass.isStarlark()) {
      try {
        codedOut.writeByteArrayNoTag(
            Preconditions.checkNotNull(ruleClass.getRuleDefinitionEnvironmentDigest(), rule));
      } catch (IOException e) {
        throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
      }
    }

    RawAttributeMapper rawAttributeMapper = RawAttributeMapper.of(rule);
    for (Attribute attr : rule.getAttributes()) {
      String attrName = attr.getName();

      if (attrName.equals(""generator_location"")) {
        // generator_location can be ignored for the purpose of telling if a rule has changed.
        continue;
      }

      Object valueToHash = rawAttributeMapper.getRawAttributeValue(rule, attr);

      if (valueToHash instanceof ComputedDefault) {
        // ConfiguredDefaults need special handling to detect changes in evaluated values.
        ComputedDefault computedDefault = (ComputedDefault) valueToHash;
        if (!computedDefault.dependencies().isEmpty()) {
          // TODO(b/29038463): We're skipping computed defaults that depend on other configurable
          // attributes because there currently isn't a way to evaluate such a computed default;
          // there isn't *one* value it evaluates to.
          continue;
        }

        try {
          valueToHash = computedDefault.getDefault(rawAttributeMapper);
        } catch (IllegalArgumentException e) {
          // TODO(mschaller): Catching IllegalArgumentException isn't ideal. It's thrown by
          // AbstractAttributeMapper#get if the attribute's type doesn't match its value, which
          // would happen if a ComputedDefault function accessed an attribute whose value was
          // configurable. We check whether the ComputedDefault declared any configurable
          // attribute dependencies above, but someone could make a mistake and fail to declare
          // something. There's no mechanism that enforces correct declaration right now.
          // This allows us to recover from such an error by skipping an attribute, as opposed to
          // crashing.
          logger.atWarning().log(
              ""Recovering from failed evaluation of ComputedDefault attribute value: %s"", e);
          continue;
        }
      }

      Build.Attribute attrPb;
      if (valueToHash instanceof SelectorList<?> || !serializedAttributes.containsKey(attr)) {
        // We didn't already serialize the attribute or it's a SelectorList. Latter may
        // have been flattened while we want the full representation, so we start from scratch.
        attrPb =
            AttributeFormatter.getAttributeProto(
                attr,
                valueToHash,
                /* explicitlySpecified= */ false, // We care about value, not how it was set.
                /* encodeBooleanAndTriStateAsIntegerAndString= */ false,
                /* sourceAspect= */ null,
                includeAttributeSourceAspects);
      } else {
        attrPb = serializedAttributes.get(attr);
      }

      try {
        attrPb.writeTo(codedOut);
      } catch (IOException e) {
        throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
      }
    }

    try {
      // Rules can be considered changed when the containing package goes in/out of error.
      codedOut.writeBoolNoTag(rule.getPackage().containsErrors());
    } catch (IOException e) {
      throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
    }

    try {
      // Include a summary of any package-wide data that applies to this target (e.g. custom make
      // variables aka `vardef`).
      codedOut.writeStringNoTag((String)  [MASK] );
    } catch (IOException e) {
      throw new IllegalStateException(""Unexpected IO failure writing to digest stream"", e);
    }

    try {
      // Flush coded out to make sure all bytes make it to the underlying digest stream.
      codedOut.flush();
    } catch (IOException e) {
      throw new IllegalStateException(""Unexpected flush failure"", e);
    }

    return BaseEncoding.base64().encode(hashingOutputStream.hash().asBytes());
  }
}
","extraDataForAttrHash
",extraData,extraData,packageWideData,packageDataSummary,
"

package com.facebook.imagepipeline.producers;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import com.facebook.common.memory.PooledByteBuffer;
import com.facebook.common.memory.PooledByteBufferFactory;
import com.facebook.imagepipeline.common.Priority;
import com.facebook.imagepipeline.core.ImagePipelineConfig;
import com.facebook.imagepipeline.image.EncodedImage;
import com.facebook.imagepipeline.request.ImageRequest;
import com.facebook.imagepipeline.testing.FakeClock;
import com.facebook.imagepipeline.testing.TestExecutorService;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import org.junit.*;
import org.junit.runner.*;
import org.mockito.*;
import org.mockito.invocation.*;
import org.mockito.stubbing.*;
import org.robolectric.*;
import org.robolectric.annotation.*;

/** Basic tests for LocalFileFetchProducer */
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE)
public class LocalFileFetchProducerTest {
  private static final String PRODUCER_NAME = LocalFileFetchProducer.PRODUCER_NAME;
  private static final int INPUT_STREAM_LENGTH = 100;
  private static final String TEST_FILENAME = ""dummy.jpg"";
  @Mock public PooledByteBufferFactory mPooledByteBufferFactory;
  @Mock public Consumer<EncodedImage> mConsumer;
  @Mock public ImageRequest mImageRequest;
  @Mock public ProducerListener2 mProducerListener;
  @Mock public Exception mException;
  @Mock public ImagePipelineConfig mConfig;
  private TestExecutorService mExecutor;
  private SettableProducerContext mProducerContext;
  private final String mRequestId = ""mRequestId"";
  private File mFile;
  private LocalFileFetchProducer mLocalFileFetchProducer;
  private EncodedImage mCapturedEncodedImage;

  @Before
  public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mExecutor = new TestExecutorService(new FakeClock());
    mLocalFileFetchProducer = new LocalFileFetchProducer(mExecutor, mPooledByteBufferFactory);
    mFile = new File(RuntimeEnvironment.application.getExternalFilesDir(null), TEST_FILENAME);
    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(mFile));
    bos.write(new byte[INPUT_STREAM_LENGTH], 0, INPUT_STREAM_LENGTH);
    bos.close();

    mProducerContext =
        new SettableProducerContext(
            mImageRequest,
            mRequestId,
            mProducerListener,
            mock(Object.class),
            ImageRequest.RequestLevel.FULL_FETCH,
            false,
            true,
            Priority.MEDIUM,
            mConfig);
    when(mImageRequest.getSourceFile()).thenReturn(mFile);
    doAnswer(
            new Answer() {
              @Override
              public Object answer(InvocationOnMock invocation) throws Throwable {
                mCapturedEncodedImage =
                    EncodedImage.cloneOrNull((EncodedImage) invocation.getArguments()[0]);
                return null;
              }
            })
        .when(mConsumer)
        .onNewResult(notNull(EncodedImage.class), anyInt());
  }

  @Test
  public void testLocalFileFetchCancelled() {
    mLocalFileFetchProducer.produceResults(mConsumer, mProducerContext);
    mProducerContext.cancel();
    verify(mProducerListener).onProducerStart(mProducerContext, PRODUCER_NAME);
    verify(mProducerListener)
        .onProducerFinishWithCancellation(mProducerContext, PRODUCER_NAME, null);
    verify(mConsumer).onCancellation();
    mExecutor.runUntilIdle();
    verifyZeroInteractions(mPooledByteBufferFactory);
  }

  @Test
  public void testFetchLocalFile() throws Exception {
    PooledByteBuffer  [MASK]  = mock(PooledByteBuffer.class);
    when(mPooledByteBufferFactory.newByteBuffer(any(InputStream.class), eq(INPUT_STREAM_LENGTH)))
        .thenReturn( [MASK] );
    mLocalFileFetchProducer.produceResults(mConsumer, mProducerContext);
    mExecutor.runUntilIdle();
    assertEquals(
        2,
        mCapturedEncodedImage
            .getByteBufferRef()
            .getUnderlyingReferenceTestOnly()
            .getRefCountTestOnly());
    assertSame( [MASK] , mCapturedEncodedImage.getByteBufferRef().get());
    verify(mProducerListener).onProducerStart(mProducerContext, PRODUCER_NAME);
    verify(mProducerListener).onProducerFinishWithSuccess(mProducerContext, PRODUCER_NAME, null);
    verify(mProducerListener).onUltimateProducerReached(mProducerContext, PRODUCER_NAME, true);
  }

  @Test(expected = RuntimeException.class)
  public void testFetchLocalFileFailsByThrowing() throws Exception {
    when(mPooledByteBufferFactory.newByteBuffer(any(InputStream.class), eq(INPUT_STREAM_LENGTH)))
        .thenThrow(mException);
    verify(mConsumer).onFailure(mException);
    verify(mProducerListener).onProducerStart(mProducerContext, PRODUCER_NAME);
    verify(mProducerListener)
        .onProducerFinishWithFailure(mProducerContext, PRODUCER_NAME, mException, null);
    verify(mProducerListener).onUltimateProducerReached(mProducerContext, PRODUCER_NAME, false);
  }

  @After
  public void tearDown() throws Exception {
    mFile.delete();
  }
}
","pooledByteBuffer
",buffer,mPooledByteBufferRef,buffer,pooledByteBuffer,
"package io.netty.handler.ssl;

import io.netty.bootstrap.Bootstrap;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.DefaultEventLoopGroup;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.local.LocalAddress;
import io.netty.channel.local.LocalChannel;
import io.netty.channel.local.LocalServerChannel;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import io.netty.handler.ssl.util.SelfSignedCertificate;
import io.netty.handler.ssl.util.SimpleTrustManagerFactory;
import io.netty.util.ReferenceCountUtil;
import io.netty.util.concurrent.Promise;
import io.netty.util.internal.EmptyArrays;
import io.netty.util.internal.ThrowableUtil;

import javax.net.ssl.ExtendedSSLSession;
import javax.net.ssl.KeyManager;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.KeyManagerFactorySpi;
import javax.net.ssl.ManagerFactoryParameters;
import javax.net.ssl.SNIHostName;
import javax.net.ssl.SNIMatcher;
import javax.net.ssl.SNIServerName;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509ExtendedKeyManager;
import javax.net.ssl.X509ExtendedTrustManager;
import java.io.IOException;
import java.net.Socket;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.PrivateKey;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

/**
 * In extra class to be able to run tests with java7 without trying to load classes that not exists in java7.
 */
final class SniClientJava8TestUtil {

    private SniClientJava8TestUtil() { }

    static void testSniClient(SslProvider sslClientProvider, SslProvider sslServerProvider, final boolean match)
            throws Exception {
        final String sniHost = """"sni.netty.io"""";
        SelfSignedCertificate cert = new SelfSignedCertificate();
        LocalAddress address = new LocalAddress(""""test"""");
        EventLoopGroup group = new DefaultEventLoopGroup(1);
        SslContext  [MASK]  = null;
        SslContext sslClientContext = null;

        Channel sc = null;
        Channel cc = null;
        try {
             [MASK]  = SslContextBuilder.forServer(cert.key(), cert.cert())
                    .sslProvider(sslServerProvider).build();
            final Promise<Void> promise = group.next().newPromise();
            ServerBootstrap sb = new ServerBootstrap();

            final SslContext finalContext =  [MASK] ;
            sc = sb.group(group).channel(LocalServerChannel.class).childHandler(new ChannelInitializer<Channel>() {
                @Override
                protected void initChannel(Channel ch) throws Exception {
                    SslHandler handler = finalContext.newHandler(ch.alloc());
                    SSLParameters parameters = handler.engine().getSSLParameters();
                    SNIMatcher matcher = new SNIMatcher(0) {
                        @Override
                        public boolean matches(SNIServerName sniServerName) {
                            return match;
                        }
                    };
                    parameters.setSNIMatchers(Collections.singleton(matcher));
                    handler.engine().setSSLParameters(parameters);

                    ch.pipeline().addFirst(handler);
                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                        @Override
                        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
                            if (evt instanceof SslHandshakeCompletionEvent) {
                                SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;
                                if (match) {
                                    if (event.isSuccess()) {
                                        promise.setSuccess(null);
                                    } else {
                                        promise.setFailure(event.cause());
                                    }
                                } else {
                                    if (event.isSuccess()) {
                                        promise.setFailure(new AssertionError(""""expected SSLException""""));
                                    } else {
                                        Throwable cause = event.cause();
                                        if (cause instanceof SSLException) {
                                            promise.setSuccess(null);
                                        } else {
                                            promise.setFailure(
                                                    new AssertionError(""""cause not of type SSLException: """"
                                                            + ThrowableUtil.stackTraceToString(cause)));
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
            }).bind(address).syncUninterruptibly().channel();

            sslClientContext = SslContextBuilder.forClient().trustManager(InsecureTrustManagerFactory.INSTANCE)
                    .sslProvider(sslClientProvider).build();

            SslHandler sslHandler = new SslHandler(
                    sslClientContext.newEngine(ByteBufAllocator.DEFAULT, sniHost, -1));
            Bootstrap cb = new Bootstrap();
            cc = cb.group(group).channel(LocalChannel.class).handler(sslHandler)
                    .connect(address).syncUninterruptibly().channel();

            promise.syncUninterruptibly();
            sslHandler.handshakeFuture().syncUninterruptibly();
        } finally {
            if (cc != null) {
                cc.close().syncUninterruptibly();
            }
            if (sc != null) {
                sc.close().syncUninterruptibly();
            }

            ReferenceCountUtil.release( [MASK] );
            ReferenceCountUtil.release(sslClientContext);

            cert.delete();

            group.shutdownGracefully();
        }
    }

    static void assertSSLSession(boolean clientSide, SSLSession session, String name) {
        assertSSLSession(clientSide, session, new SNIHostName(name));
    }

    private static void assertSSLSession(boolean clientSide, SSLSession session, SNIServerName name) {
        assertNotNull(session);
        if (session instanceof ExtendedSSLSession) {
            ExtendedSSLSession extendedSSLSession = (ExtendedSSLSession) session;
            List<SNIServerName> names = extendedSSLSession.getRequestedServerNames();
            assertEquals(1, names.size());
            assertEquals(name, names.get(0));
            assertTrue(extendedSSLSession.getLocalSupportedSignatureAlgorithms().length > 0);
            if (clientSide) {
                assertEquals(0, extendedSSLSession.getPeerSupportedSignatureAlgorithms().length);
            } else {
                assertTrue(extendedSSLSession.getPeerSupportedSignatureAlgorithms().length >= 0);
            }
        }
    }

    static TrustManagerFactory newSniX509TrustmanagerFactory(String name) {
        return new SniX509TrustmanagerFactory(new SNIHostName(name));
    }

    private static final class SniX509TrustmanagerFactory extends SimpleTrustManagerFactory {

        private final SNIServerName name;

        SniX509TrustmanagerFactory(SNIServerName name) {
            this.name = name;
        }

        @Override
        protected void engineInit(KeyStore keyStore) throws Exception {
            // NOOP
        }

        @Override
        protected void engineInit(ManagerFactoryParameters managerFactoryParameters) throws Exception {
            // NOOP
        }

        @Override
        protected TrustManager[] engineGetTrustManagers() {
            return new TrustManager[] { new X509ExtendedTrustManager() {
                @Override
                public void checkClientTrusted(X509Certificate[] x509Certificates, String s, Socket socket)
                        throws CertificateException {
                    fail();
                }

                @Override
                public void checkServerTrusted(X509Certificate[] x509Certificates, String s, Socket socket)
                        throws CertificateException {
                    fail();
                }

                @Override
                public void checkClientTrusted(X509Certificate[] x509Certificates, String s, SSLEngine sslEngine)
                        throws CertificateException {
                    fail();
                }

                @Override
                public void checkServerTrusted(X509Certificate[] x509Certificates, String s, SSLEngine sslEngine)
                        throws CertificateException {
                    assertSSLSession(sslEngine.getUseClientMode(), sslEngine.getHandshakeSession(), name);
                }

                @Override
                public void checkClientTrusted(X509Certificate[] x509Certificates, String s)
                        throws CertificateException {
                    fail();
                }

                @Override
                public void checkServerTrusted(X509Certificate[] x509Certificates, String s)
                        throws CertificateException {
                    fail();
                }

                @Override
                public X509Certificate[] getAcceptedIssuers() {
                    return EmptyArrays.EMPTY_X509_CERTIFICATES;
                }
            } };
        }
    }

    static KeyManagerFactory newSniX509KeyManagerFactory(SelfSignedCertificate cert, String hostname)
            throws NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException,
                   IOException, CertificateException {
        return new SniX509KeyManagerFactory(
                new SNIHostName(hostname), SslContext.buildKeyManagerFactory(
                new X509Certificate[] { cert.cert() }, null,  cert.key(), null, null, null));
    }

    private static final class SniX509KeyManagerFactory extends KeyManagerFactory {

        SniX509KeyManagerFactory(final SNIServerName name, final KeyManagerFactory factory) {
            super(new KeyManagerFactorySpi() {
                @Override
                protected void engineInit(KeyStore keyStore, char[] chars)
                        throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException {
                    factory.init(keyStore, chars);
                }

                @Override
                protected void engineInit(ManagerFactoryParameters managerFactoryParameters)
                        throws InvalidAlgorithmParameterException {
                    factory.init(managerFactoryParameters);
                }

                @Override
                protected KeyManager[] engineGetKeyManagers() {
                    List<KeyManager> managers = new ArrayList<KeyManager>();
                    for (final KeyManager km: factory.getKeyManagers()) {
                        if (km instanceof X509ExtendedKeyManager) {
                            managers.add(new X509ExtendedKeyManager() {
                                @Override
                                public String[] getClientAliases(String s, Principal[] principals) {
                                    return ((X509ExtendedKeyManager) km).getClientAliases(s, principals);
                                }

                                @Override
                                public String chooseClientAlias(String[] strings, Principal[] principals,
                                                                Socket socket) {
                                    return ((X509ExtendedKeyManager) km).chooseClientAlias(strings, principals, socket);
                                }

                                @Override
                                public String[] getServerAliases(String s, Principal[] principals) {
                                    return ((X509ExtendedKeyManager) km).getServerAliases(s, principals);
                                }

                                @Override
                                public String chooseServerAlias(String s, Principal[] principals, Socket socket) {
                                    return ((X509ExtendedKeyManager) km).chooseServerAlias(s, principals, socket);
                                }

                                @Override
                                public X509Certificate[] getCertificateChain(String s) {
                                    return ((X509ExtendedKeyManager) km).getCertificateChain(s);
                                }

                                @Override
                                public PrivateKey getPrivateKey(String s) {
                                    return ((X509ExtendedKeyManager) km).getPrivateKey(s);
                                }

                                @Override
                                public String chooseEngineClientAlias(String[] strings, Principal[] principals,
                                                                      SSLEngine sslEngine) {
                                    return ((X509ExtendedKeyManager) km)
                                            .chooseEngineClientAlias(strings, principals, sslEngine);
                                }

                                @Override
                                public String chooseEngineServerAlias(String s, Principal[] principals,
                                                                      SSLEngine sslEngine) {

                                    SSLSession session = sslEngine.getHandshakeSession();
                                    assertSSLSession(sslEngine.getUseClientMode(), session, name);
                                    return ((X509ExtendedKeyManager) km)
                                            .chooseEngineServerAlias(s, principals, sslEngine);
                                }
                            });
                        } else {
                            managers.add(km);
                        }
                    }
                    return managers.toArray(new KeyManager[0]);
                }
            }, factory.getProvider(), factory.getAlgorithm());
        }
    }
}
""    ","sslServerContext
",sslContext,sslContext,sslContext,sslContext,
"

package com.google.testing.coverage;

import static com.google.common.truth.Truth.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import com.google.common.collect.ImmutableSet;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Arrays;
import java.util.List;
import java.util.TreeMap;
import org.jacoco.core.analysis.IBundleCoverage;
import org.jacoco.core.analysis.IClassCoverage;
import org.jacoco.core.analysis.IPackageCoverage;
import org.jacoco.report.IReportVisitor;
import org.jacoco.report.ISourceFileLocator;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/** Tests the uninstrumented class processing logic in {@link JacocoLCOVFormatter}. */
@RunWith(JUnit4.class)
public class JacocoLCOVFormatterUninstrumentedTest {

  private StringWriter writer;
  private IBundleCoverage mockBundle;

  private static IClassCoverage mockIClassCoverage(
      String className, String  [MASK] , String sourceFileName) {
    IClassCoverage mocked = mock(IClassCoverage.class);
    when(mocked.getName()).thenReturn(className);
    when(mocked.getPackageName()).thenReturn( [MASK] );
    when(mocked.getSourceFileName()).thenReturn(sourceFileName);
    return mocked;
  }

  private Description createSuiteDescription(String name) {
    Description suite = Description.createSuiteDescription(name);
    suite.addChild(Description.createTestDescription(Object.class, ""child""));
    return suite;
  }

  @Before
  public void setupTest() {
    // Initialize writer for storing coverage report outputs
    writer = new StringWriter();
    // Initialize mock Jacoco bundle containing the mock coverage
    // Classes
    List<IClassCoverage> mockClassCoverages =
        Arrays.asList(mockIClassCoverage(""Foo"", ""com/example"", ""Foo.java""));
    // Package
    IPackageCoverage mockPackageCoverage = mock(IPackageCoverage.class);
    when(mockPackageCoverage.getClasses()).thenReturn(mockClassCoverages);
    // Bundle
    mockBundle = mock(IBundleCoverage.class);
    when(mockBundle.getPackages()).thenReturn(Arrays.asList(mockPackageCoverage));
  }

  @Test
  public void testVisitBundleWithSimpleUnixPath() throws IOException {
    // Paths
    ImmutableSet<String> execPaths = ImmutableSet.of(""/parent/dir/com/example/Foo.java"");
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    for (String sourcePath : execPaths) {
      assertThat(coverageOutput).contains(sourcePath);
    }
  }

  @Test
  public void testVisitBundleWithSimpleWindowsPath() throws IOException {
    // Paths
    ImmutableSet<String> execPaths = ImmutableSet.of(""C:/parent/dir/com/example/Foo.java"");
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    for (String sourcePath : execPaths) {
      assertThat(coverageOutput).contains(sourcePath);
    }
  }

  @Test
  public void testVisitBundleWithMappedUnixPath() throws IOException {
    // Paths
    String srcPath = ""/some/other/dir/Foo.java"";
    ImmutableSet<String> execPaths = ImmutableSet.of(srcPath + ""////com/example/Foo.java"");
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).contains(srcPath);
  }

  @Test
  public void testVisitBundleWithMappedWindowsPath() throws IOException {
    // Paths
    String srcPath = ""C:/some/other/dir/Foo.java"";
    ImmutableSet<String> execPaths = ImmutableSet.of(srcPath + ""////com/example/Foo.java"");
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).contains(srcPath);
  }

  @Test
  public void testVisitBundleWithNoMatchHasEmptyOutput() throws IOException {
    // Non-matching path
    ImmutableSet<String> execPaths = ImmutableSet.of(""/path/does/not/match/anything.txt"");
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).isEmpty();
  }

  @Test
  public void testVisitBundleWithNoExecPathsHasEmptyOutput() throws IOException {
    // Empty list of exec paths
    ImmutableSet<String> execPaths = ImmutableSet.of();
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).isEmpty();
  }

  @Test
  public void testVisitBundleWithoutExecPathsDoesNotPruneOutput() throws IOException {
    // No paths, don't attempt to demangle paths and prune the output, just output with
    // class-paths as is.
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter();
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).isNotEmpty();
  }

  @Test
  public void testVisitBundleWithExactMatch() throws IOException {
    // It's possible, albeit unlikely, that the execPath and the package based path match exactly
    String srcPath = ""com/example/Foo.java"";
    ImmutableSet<String> execPaths = ImmutableSet.of(srcPath);
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).contains(srcPath);
  }
}
","packageName
",packageName,packageName,packageName,packageName,
"

package com.google.testing.coverage;

import static com.google.common.truth.Truth.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import com.google.common.collect.ImmutableSet;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Arrays;
import java.util.List;
import java.util.TreeMap;
import org.jacoco.core.analysis.IBundleCoverage;
import org.jacoco.core.analysis.IClassCoverage;
import org.jacoco.core.analysis.IPackageCoverage;
import org.jacoco.report.IReportVisitor;
import org.jacoco.report.ISourceFileLocator;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.Description;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/** Tests the uninstrumented class processing logic in {@link JacocoLCOVFormatter}. */
@RunWith(JUnit4.class)
public class JacocoLCOVFormatterUninstrumentedTest {

  private StringWriter writer;
  private IBundleCoverage mockBundle;

  private static IClassCoverage mockIClassCoverage(
      String className, String packageName, String sourceFileName) {
    IClassCoverage mocked = mock(IClassCoverage.class);
    when(mocked.getName()).thenReturn(className);
    when(mocked.getPackageName()).thenReturn(packageName);
    when(mocked.getSourceFileName()).thenReturn(sourceFileName);
    return mocked;
  }

  private Description createSuiteDescription(String name) {
    Description suite = Description.createSuiteDescription(name);
    suite.addChild(Description.createTestDescription(Object.class, ""child""));
    return suite;
  }

  @Before
  public void setupTest() {
    // Initialize writer for storing coverage report outputs
    writer = new StringWriter();
    // Initialize mock Jacoco bundle containing the mock coverage
    // Classes
    List<IClassCoverage> mockClassCoverages =
        Arrays.asList(mockIClassCoverage(""Foo"", ""com/example"", ""Foo.java""));
    // Package
    IPackageCoverage mockPackageCoverage = mock(IPackageCoverage.class);
    when(mockPackageCoverage.getClasses()).thenReturn(mockClassCoverages);
    // Bundle
    mockBundle = mock(IBundleCoverage.class);
    when(mockBundle.getPackages()).thenReturn(Arrays.asList(mockPackageCoverage));
  }

  @Test
  public void testVisitBundleWithSimpleUnixPath() throws IOException {
    // Paths
    ImmutableSet<String> execPaths = ImmutableSet.of(""/parent/dir/com/example/Foo.java"");
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    for (String sourcePath : execPaths) {
      assertThat(coverageOutput).contains(sourcePath);
    }
  }

  @Test
  public void testVisitBundleWithSimpleWindowsPath() throws IOException {
    // Paths
    ImmutableSet<String> execPaths = ImmutableSet.of(""C:/parent/dir/com/example/Foo.java"");
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    for (String sourcePath : execPaths) {
      assertThat(coverageOutput).contains(sourcePath);
    }
  }

  @Test
  public void testVisitBundleWithMappedUnixPath() throws IOException {
    // Paths
    String  [MASK]  = ""/some/other/dir/Foo.java"";
    ImmutableSet<String> execPaths = ImmutableSet.of( [MASK]  + ""////com/example/Foo.java"");
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).contains( [MASK] );
  }

  @Test
  public void testVisitBundleWithMappedWindowsPath() throws IOException {
    // Paths
    String  [MASK]  = ""C:/some/other/dir/Foo.java"";
    ImmutableSet<String> execPaths = ImmutableSet.of( [MASK]  + ""////com/example/Foo.java"");
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).contains( [MASK] );
  }

  @Test
  public void testVisitBundleWithNoMatchHasEmptyOutput() throws IOException {
    // Non-matching path
    ImmutableSet<String> execPaths = ImmutableSet.of(""/path/does/not/match/anything.txt"");
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).isEmpty();
  }

  @Test
  public void testVisitBundleWithNoExecPathsHasEmptyOutput() throws IOException {
    // Empty list of exec paths
    ImmutableSet<String> execPaths = ImmutableSet.of();
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).isEmpty();
  }

  @Test
  public void testVisitBundleWithoutExecPathsDoesNotPruneOutput() throws IOException {
    // No paths, don't attempt to demangle paths and prune the output, just output with
    // class-paths as is.
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter();
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).isNotEmpty();
  }

  @Test
  public void testVisitBundleWithExactMatch() throws IOException {
    // It's possible, albeit unlikely, that the execPath and the package based path match exactly
    String  [MASK]  = ""com/example/Foo.java"";
    ImmutableSet<String> execPaths = ImmutableSet.of( [MASK] );
    JacocoLCOVFormatter formatter = new JacocoLCOVFormatter(execPaths);
    IReportVisitor visitor =
        formatter.createVisitor(
            new PrintWriter(writer), new TreeMap<String, BranchCoverageDetail>());

    visitor.visitBundle(mockBundle, mock(ISourceFileLocator.class));
    visitor.visitEnd();

    String coverageOutput = writer.toString();
    assertThat(coverageOutput).contains( [MASK] );
  }
}
","srcPath
",source,execPath,sourcePath,sourcePath,
"package com.example.butterknife.functional;

import android.view.View;
import butterknife.BindView;
import butterknife.ButterKnife;
import butterknife.Unbinder;
import org.junit.Test;

import static com.google.common.truth.Truth.assertThat;

public final class BindViewTest {
  static class TargetView {
    @BindView(1) View actual;
  }

  @Test public void view() {
    View tree = ViewTree.create(1);
    View expected = tree.findViewById(1);

    TargetView  [MASK]  = new TargetView();
    Unbinder unbinder = ButterKnife.bind( [MASK] , tree);
    assertThat( [MASK] .actual).isSameAs(expected);

    unbinder.unbind();
    assertThat( [MASK] .actual).isNull();
  }
}
","target
",targetView,targetView,targetView,target,
"
package io.netty.handler.codec.compression;

import static io.netty.handler.codec.compression.Bzip2Constants.HUFFMAN_DECODE_MAX_CODE_LENGTH;
import static io.netty.handler.codec.compression.Bzip2Constants.HUFFMAN_GROUP_RUN_LENGTH;
import static io.netty.handler.codec.compression.Bzip2Constants.HUFFMAN_MAX_ALPHABET_SIZE;

/**
 * A decoder for the Bzip2 Huffman coding stage.
 */
final class Bzip2HuffmanStageDecoder {
    /**
     * A reader that provides bit-level reads.
     */
    private final Bzip2BitReader reader;

    /**
     * The Huffman table number to use for each group of 50 symbols.
     */
    byte[] selectors;

    /**
     * The minimum code length for each Huffman table.
     */
    private final int[] minimumLengths;

    /**
     * An array of values for each Huffman table that must be subtracted from the numerical value of
     * a Huffman code of a given bit length to give its canonical code index.
     */
    private final int[][] codeBases;

    /**
     * An array of values for each Huffman table that gives the highest numerical value of a Huffman
     * code of a given bit length.
     */
    private final int[][] codeLimits;

    /**
     * A mapping for each Huffman table from canonical code index to output symbol.
     */
    private final int[][] codeSymbols;

    /**
     * The Huffman table for the current group.
     */
    private int currentTable;

    /**
     * The index of the current group within the selectors array.
     */
    private int groupIndex = -1;

    /**
     * The byte position within the current group. A new group is selected every 50 decoded bytes.
     */
    private int groupPosition = -1;

    /**
     * Total number of used Huffman tables in range 2..6.
     */
    final int totalTables;

    /**
     * The total number of codes (uniform for each table).
     */
    final int alphabetSize;

    /**
     * Table for Move To Front transformations.
     */
    final Bzip2MoveToFrontTable tableMTF = new Bzip2MoveToFrontTable();

    // For saving state if end of current ByteBuf was reached
    int currentSelector;

    /**
     * The Canonical Huffman code lengths for each table.
     */
    final byte[][] tableCodeLengths;

    // For saving state if end of current ByteBuf was reached
    int currentGroup;
    int currentLength = -1;
    int currentAlpha;
    boolean modifyLength;

    Bzip2HuffmanStageDecoder(final Bzip2BitReader reader, final int totalTables, final int alphabetSize) {
        this.reader = reader;
        this.totalTables = totalTables;
        this.alphabetSize = alphabetSize;

        minimumLengths = new int[totalTables];
        codeBases = new int[totalTables][HUFFMAN_DECODE_MAX_CODE_LENGTH + 2];
        codeLimits = new int[totalTables][HUFFMAN_DECODE_MAX_CODE_LENGTH + 1];
        codeSymbols = new int[totalTables][HUFFMAN_MAX_ALPHABET_SIZE];
        tableCodeLengths = new byte[totalTables][HUFFMAN_MAX_ALPHABET_SIZE];
    }

    /**
     * Constructs Huffman decoding tables from lists of Canonical Huffman code lengths.
     */
    void createHuffmanDecodingTables() {
        final int alphabetSize = this.alphabetSize;

        for (int table = 0; table < tableCodeLengths.length; table++) {
            final int[] tableBases = codeBases[table];
            final int[] tableLimits = codeLimits[table];
            final int[] tableSymbols = codeSymbols[table];
            final byte[] codeLengths = tableCodeLengths[table];

            int minimumLength = HUFFMAN_DECODE_MAX_CODE_LENGTH;
            int  [MASK]  = 0;

            // Find the minimum and maximum code length for the table
            for (int i = 0; i < alphabetSize; i++) {
                final byte currLength = codeLengths[i];
                 [MASK]  = Math.max(currLength,  [MASK] );
                minimumLength = Math.min(currLength, minimumLength);
            }
            minimumLengths[table] = minimumLength;

            // Calculate the first output symbol for each code length
            for (int i = 0; i < alphabetSize; i++) {
                tableBases[codeLengths[i] + 1]++;
            }
            for (int i = 1, b = tableBases[0]; i < HUFFMAN_DECODE_MAX_CODE_LENGTH + 2; i++) {
                b += tableBases[i];
                tableBases[i] = b;
            }

            // Calculate the first and last Huffman code for each code length (codes at a given
            // length are sequential in value)
            for (int i = minimumLength, code = 0; i <=  [MASK] ; i++) {
                int base = code;
                code += tableBases[i + 1] - tableBases[i];
                tableBases[i] = base - tableBases[i];
                tableLimits[i] = code - 1;
                code <<= 1;
            }

            // Populate the mapping from canonical code index to output symbol
            for (int bitLength = minimumLength, codeIndex = 0; bitLength <=  [MASK] ; bitLength++) {
                for (int symbol = 0; symbol < alphabetSize; symbol++) {
                    if (codeLengths[symbol] == bitLength) {
                        tableSymbols[codeIndex++] = symbol;
                    }
                }
            }
        }

        currentTable = selectors[0];
    }

    /**
     * Decodes and returns the next symbol.
     * @return The decoded symbol
     */
    int nextSymbol() {
        // Move to next group selector if required
        if (++groupPosition % HUFFMAN_GROUP_RUN_LENGTH == 0) {
            groupIndex++;
            if (groupIndex == selectors.length) {
                throw new DecompressionException(""error decoding block"");
            }
            currentTable = selectors[groupIndex] & 0xff;
        }

        final Bzip2BitReader reader = this.reader;
        final int currentTable = this.currentTable;
        final int[] tableLimits = codeLimits[currentTable];
        final int[] tableBases = codeBases[currentTable];
        final int[] tableSymbols = codeSymbols[currentTable];
        int codeLength = minimumLengths[currentTable];

        // Starting with the minimum bit length for the table, read additional bits one at a time
        // until a complete code is recognised
        int codeBits = reader.readBits(codeLength);
        for (; codeLength <= HUFFMAN_DECODE_MAX_CODE_LENGTH; codeLength++) {
            if (codeBits <= tableLimits[codeLength]) {
                // Convert the code to a symbol index and return
                return tableSymbols[codeBits - tableBases[codeLength]];
            }
            codeBits = codeBits << 1 | reader.readBits(1);
        }

        throw new DecompressionException(""a valid code was not recognised"");
    }
}
","maximumLength
",maximalCodeCodeLen,maxCodeLen,maxCodeLength,maximumLength,
"
package com.google.android.exoplayer2.upstream;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

/**
 * Calculate any percentile over a sliding window of weighted values. A maximum weight is
 * configured. Once the total weight of the values reaches the maximum weight, the oldest value is
 * reduced in weight until it reaches zero and is removed. This maintains a constant total weight,
 * equal to the maximum allowed, at the steady state.
 *
 * <p>This class can be used for bandwidth estimation based on a sliding window of past transfer
 * rate observations. This is an alternative to sliding mean and exponential averaging which suffer
 * from susceptibility to outliers and slow adaptation to step functions.
 *
 * <p>See the following Wikipedia articles:
 *
 * <ul>
 *   <li><a href=""http://en.wikipedia.org/wiki/Moving_average"">Moving average</a>
 *   <li><a href=""http://en.wikipedia.org/wiki/Selection_algorithm"">Selection algorithm</a>
 * </ul>
 *
 * @deprecated com.google.android.exoplayer2 is deprecated. Please migrate to androidx.media3 (which
 *     contains the same ExoPlayer code). See <a
 *     href=""https://developer.android.com/guide/topics/media/media3/getting-started/migration-guide"">the
 *     migration guide</a> for more details, including a script to help with the migration.
 */
@Deprecated
public class SlidingPercentile {

  // Orderings.
  private static final Comparator<Sample> INDEX_COMPARATOR = (a, b) -> a.index - b.index;
  private static final Comparator<Sample> VALUE_COMPARATOR =
      (a, b) -> Float.compare(a.value, b.value);

  private static final int SORT_ORDER_NONE = -1;
  private static final int SORT_ORDER_BY_VALUE = 0;
  private static final int SORT_ORDER_BY_INDEX = 1;

  private static final int MAX_RECYCLED_SAMPLES = 5;

  private final int maxWeight;
  private final ArrayList<Sample> samples;

  private final Sample[] recycledSamples;

  private int currentSortOrder;
  private int nextSampleIndex;
  private int totalWeight;
  private int recycledSampleCount;

  /**
   * @param maxWeight The maximum weight.
   */
  public SlidingPercentile(int maxWeight) {
    this.maxWeight = maxWeight;
    recycledSamples = new Sample[MAX_RECYCLED_SAMPLES];
    samples = new ArrayList<>();
    currentSortOrder = SORT_ORDER_NONE;
  }

  /** Resets the sliding percentile. */
  public void reset() {
    samples.clear();
    currentSortOrder = SORT_ORDER_NONE;
    nextSampleIndex = 0;
    totalWeight = 0;
  }

  /**
   * Adds a new weighted value.
   *
   * @param weight The weight of the new observation.
   * @param value The value of the new observation.
   */
  public void addSample(int weight, float value) {
    ensureSortedByIndex();

    Sample newSample =
        recycledSampleCount > 0 ? recycledSamples[--recycledSampleCount] : new Sample();
    newSample.index = nextSampleIndex++;
    newSample.weight = weight;
    newSample.value = value;
    samples.add(newSample);
    totalWeight += weight;

    while (totalWeight > maxWeight) {
      int excessWeight = totalWeight - maxWeight;
      Sample oldestSample = samples.get(0);
      if (oldestSample.weight <= excessWeight) {
        totalWeight -= oldestSample.weight;
        samples.remove(0);
        if (recycledSampleCount < MAX_RECYCLED_SAMPLES) {
          recycledSamples[recycledSampleCount++] = oldestSample;
        }
      } else {
        oldestSample.weight -= excessWeight;
        totalWeight -= excessWeight;
      }
    }
  }

  /**
   * Computes a percentile by integration.
   *
   * @param percentile The desired percentile, expressed as a fraction in the range (0,1].
   * @return The requested percentile value or {@link Float#NaN} if no samples have been added.
   */
  public float getPercentile(float percentile) {
    ensureSortedByValue();
    float  [MASK]  = percentile * totalWeight;
    int accumulatedWeight = 0;
    for (int i = 0; i < samples.size(); i++) {
      Sample currentSample = samples.get(i);
      accumulatedWeight += currentSample.weight;
      if (accumulatedWeight >=  [MASK] ) {
        return currentSample.value;
      }
    }
    // Clamp to maximum value or NaN if no values.
    return samples.isEmpty() ? Float.NaN : samples.get(samples.size() - 1).value;
  }

  /** Sorts the samples by index. */
  private void ensureSortedByIndex() {
    if (currentSortOrder != SORT_ORDER_BY_INDEX) {
      Collections.sort(samples, INDEX_COMPARATOR);
      currentSortOrder = SORT_ORDER_BY_INDEX;
    }
  }

  /** Sorts the samples by value. */
  private void ensureSortedByValue() {
    if (currentSortOrder != SORT_ORDER_BY_VALUE) {
      Collections.sort(samples, VALUE_COMPARATOR);
      currentSortOrder = SORT_ORDER_BY_VALUE;
    }
  }

  private static class Sample {

    public int index;
    public int weight;
    public float value;
  }
}
","desiredWeight
",range,percentileValue,targetWeight,targetWeight,
"

package com.google.devtools.j2objc.util;

import com.google.devtools.j2objc.Options;
import com.google.devtools.j2objc.ast.AbstractTypeDeclaration;
import com.google.devtools.j2objc.ast.ArrayAccess;
import com.google.devtools.j2objc.ast.ArrayCreation;
import com.google.devtools.j2objc.ast.ArrayInitializer;
import com.google.devtools.j2objc.ast.Assignment;
import com.google.devtools.j2objc.ast.CastExpression;
import com.google.devtools.j2objc.ast.ClassInstanceCreation;
import com.google.devtools.j2objc.ast.ConditionalExpression;
import com.google.devtools.j2objc.ast.EnumDeclaration;
import com.google.devtools.j2objc.ast.Expression;
import com.google.devtools.j2objc.ast.FieldAccess;
import com.google.devtools.j2objc.ast.FunctionInvocation;
import com.google.devtools.j2objc.ast.InfixExpression;
import com.google.devtools.j2objc.ast.PackageDeclaration;
import com.google.devtools.j2objc.ast.ParenthesizedExpression;
import com.google.devtools.j2objc.ast.PostfixExpression;
import com.google.devtools.j2objc.ast.PrefixExpression;
import com.google.devtools.j2objc.ast.SimpleName;
import com.google.devtools.j2objc.ast.TreeNode;
import com.google.devtools.j2objc.ast.TreeUtil;
import com.google.devtools.j2objc.ast.TypeDeclaration;
import com.google.devtools.j2objc.ast.TypeLiteral;
import com.google.devtools.j2objc.types.FunctionElement;
import com.google.j2objc.annotations.ReflectionSupport;
import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.AnnotationValue;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.ArrayType;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;

/**
 * General collection of utility methods.
 *
 * @author Keith Stanger, Tom Ball
 */
public final class TranslationUtil {

  private final TypeUtil typeUtil;
  private final NameTable nameTable;
  private final Options options;
  private final ElementUtil elementUtil;
  private final URLClassLoader jreEmulLoader;

  public TranslationUtil(TypeUtil typeUtil, NameTable nameTable, Options options,
      ElementUtil elementUtil) {
    this.typeUtil = typeUtil;
    this.nameTable = nameTable;
    this.options = options;
    this.elementUtil = elementUtil;
    this.jreEmulLoader = getJreEmulClassPath(options);

  }

  public static TypeElement getSuperType(AbstractTypeDeclaration node) {
    // Use the AST as the source of truth where possible.
    if (node instanceof TypeDeclaration) {
      TypeMirror superclassTypeMirror = ((TypeDeclaration) node).getSuperclassTypeMirror();
      return superclassTypeMirror == null ? null : TypeUtil.asTypeElement(superclassTypeMirror);
    } else {
      return ElementUtil.getSuperclass(node.getTypeElement());
    }
  }

  public static List<TypeElement> getInterfaceTypes(AbstractTypeDeclaration node) {
    // Use the AST as the source of truth where possible.
    List<? extends TypeMirror> astInterfaces = null;
    if (node instanceof TypeDeclaration) {
      astInterfaces = ((TypeDeclaration) node).getSuperInterfaceTypeMirrors();
    } else if (node instanceof EnumDeclaration) {
      astInterfaces = ((EnumDeclaration) node).getSuperInterfaceTypeMirrors();
    } else {  // AnnotationTypeDeclaration
      return ElementUtil.getInterfaces(node.getTypeElement());
    }

    List<TypeElement> result = new ArrayList<>();
    for (TypeMirror typeMirror : astInterfaces) {
      result.add(TypeUtil.asTypeElement(typeMirror));
    }
    return result;
  }

  public boolean needsReflection(AbstractTypeDeclaration node) {
    return needsReflection(node.getTypeElement());
  }

  public boolean needsReflection(PackageDeclaration node) {
    ReflectionSupport.Level level = getReflectionSupportLevelOnPackage(node.getPackageElement());
    return needsReflection(level);
  }

  public boolean needsReflection(TypeElement type) {
    if (ElementUtil.isLambda(type)) {
      return false;
    }
    if (isJUnitTestClass(type) || ElementUtil.isRuntimeAnnotation(type)) {
      return true;
    }
    PackageElement packageElement = ElementUtil.getPackage(type);
    ReflectionSupport.Level level = null;
    while (type != null) {
      level = getReflectionSupportLevel(ElementUtil.getAnnotation(type, ReflectionSupport.class));
      if (level != null) {
        return level == ReflectionSupport.Level.FULL;
      }
      type = ElementUtil.getDeclaringClass(type);
    }
    // Check package level annotations
    level = getReflectionSupportLevelOnPackage(packageElement);

    return needsReflection(level);
  }

  private boolean needsReflection(ReflectionSupport.Level level) {
    if (level != null) {
      return level == ReflectionSupport.Level.FULL;
    } else {
      return !options.stripReflection();
    }
  }

  private boolean isJUnitTestClass(TypeElement type) {
    if (ElementUtil.isPackageInfo(type)) {
      return false;
    }
    return isJUnit3TestClass(type) || isJUnit4TestClass(type);
  }

  public boolean isJUnit3TestClass(TypeElement type) {
    TypeElement testType = typeUtil.resolveJavaType(""junit.framework.Test"");
    return testType != null && typeUtil.isAssignable(type.asType(), testType.asType());
  }

  private boolean isJUnit4TestClass(TypeElement type) {
    if (ElementUtil.hasQualifiedNamedAnnotation(type, ""org.junit.runner.RunWith"")) {
      return true;
    }
    for (Element e : type.getEnclosedElements()) {
      if (ElementUtil.hasQualifiedNamedAnnotation(e, ""org.junit.Test"")) {
        return true;
      }
    }
    return false;
  }

  private ReflectionSupport.Level getReflectionSupportLevelOnPackage(PackageElement node) {
    ReflectionSupport.Level level = getReflectionSupportLevel(
        ElementUtil.getAnnotation(node, ReflectionSupport.class));
    if (level != null) {
      return level;
    }
    // Check if package-info.java contains ReflectionSupport annotation
    level = options.getPackageInfoLookup().getReflectionSupportLevel(
        node.getQualifiedName().toString());
    return level;
  }

  public static ReflectionSupport.Level getReflectionSupportLevel(
      AnnotationMirror reflectionSupport) {
    if (reflectionSupport == null) {
      return null;
    }
    VariableElement level = (VariableElement)
        ElementUtil.getAnnotationValue(reflectionSupport, ""value"");
    return level != null
        ? ReflectionSupport.Level.valueOf(level.getSimpleName().toString()) : null;
  }

  /**
   * If possible give this expression an unbalanced extra retain. If a non-null
   * result is returned, then the returned expression has an unbalanced extra
   * retain and the passed in expression is removed from the tree and must be
   * discarded. If null is returned then the passed in expression is left
   * untouched. The caller must ensure the result is eventually consumed.
   */
  public static Expression retainResult(Expression node) {
    switch (node.getKind()) {
      case ARRAY_CREATION:
        ((ArrayCreation) node).setHasRetainedResult(true);
        return TreeUtil.remove(node);
      case CLASS_INSTANCE_CREATION:
        ((ClassInstanceCreation) node).setHasRetainedResult(true);
        return TreeUtil.remove(node);
      case FUNCTION_INVOCATION: {
        FunctionInvocation invocation = (FunctionInvocation) node;
        if (invocation.getFunctionElement().getRetainedResultName() != null) {
          invocation.setHasRetainedResult(true);
          return TreeUtil.remove(node);
        }
        return null;
      }
      default:
        return null;
    }
  }

  public static boolean isAssigned(Expression node) {
    TreeNode parent = node.getParent();

    while (parent instanceof ParenthesizedExpression) {
      node = (Expression) parent;
      parent = node.getParent();
    }

    if (parent instanceof PostfixExpression) {
      PostfixExpression.Operator op = ((PostfixExpression) parent).getOperator();
      if (op == PostfixExpression.Operator.INCREMENT
          || op == PostfixExpression.Operator.DECREMENT) {
        return true;
      }
    } else if (parent instanceof PrefixExpression) {
      PrefixExpression.Operator op = ((PrefixExpression) parent).getOperator();
      if (op == PrefixExpression.Operator.INCREMENT || op == PrefixExpression.Operator.DECREMENT
          || op == PrefixExpression.Operator.ADDRESS_OF) {
        return true;
      }
    } else if (parent instanceof Assignment) {
      return node == ((Assignment) parent).getLeftHandSide();
    }
    return false;
  }

  /**
   * Returns whether the expression might have any side effects. If true, it
   * would be unsafe to prune the given node from the tree.
   */
  public static boolean hasSideEffect(Expression expr) {
    VariableElement var = TreeUtil.getVariableElement(expr);
    if (var != null && ElementUtil.isVolatile(var)) {
      return true;
    }
    switch (expr.getKind()) {
      case BOOLEAN_LITERAL:
      case CHARACTER_LITERAL:
      case NULL_LITERAL:
      case NUMBER_LITERAL:
      case QUALIFIED_NAME:
      case SIMPLE_NAME:
      case STRING_LITERAL:
      case SUPER_FIELD_ACCESS:
      case THIS_EXPRESSION:
        return false;
      case CAST_EXPRESSION:
        return hasSideEffect(((CastExpression) expr).getExpression());
      case CONDITIONAL_EXPRESSION:
        {
          ConditionalExpression condExpr = (ConditionalExpression) expr;
          return hasSideEffect(condExpr.getExpression())
              || hasSideEffect(condExpr.getThenExpression())
              || hasSideEffect(condExpr.getElseExpression());
        }
      case FIELD_ACCESS:
        return hasSideEffect(((FieldAccess) expr).getExpression());
      case INFIX_EXPRESSION:
        for (Expression operand : ((InfixExpression) expr).getOperands()) {
          if (hasSideEffect(operand)) {
            return true;
          }
        }
        return false;
      case PARENTHESIZED_EXPRESSION:
        return hasSideEffect(((ParenthesizedExpression) expr).getExpression());
      case PREFIX_EXPRESSION:
        {
          PrefixExpression preExpr = (PrefixExpression) expr;
          PrefixExpression.Operator op = preExpr.getOperator();
          return op == PrefixExpression.Operator.INCREMENT
              || op == PrefixExpression.Operator.DECREMENT
              || hasSideEffect(preExpr.getOperand());
        }
      default:
        return true;
    }
  }

  /**
   * Returns the modifier for an assignment expression being converted to a
   * function. The result will be ""Array"" if the lhs is an array access,
   * ""Strong"" if the lhs is a field with a strong reference, and an empty string
   * for local variables and weak fields.
   */
  public String getOperatorFunctionModifier(Expression expr) {
    VariableElement var = TreeUtil.getVariableElement(expr);
    if (var == null) {
      assert TreeUtil.trimParentheses(expr) instanceof ArrayAccess
          : ""Expression cannot be resolved to a variable or array access."";
      return ""Array"";
    }
    String modifier = """";
    if (ElementUtil.isVolatile(var)) {
      modifier += ""Volatile"";
    } else if (!ElementUtil.isWeakReference(var)
        && var.getKind().isField()
        && options.useStrictFieldAssign()) {
      modifier += ""StrictField"";
    }
    if (!ElementUtil.isWeakReference(var) && (var.getKind().isField() || options.useARC())) {
      modifier += ""Strong"";
    }
    return modifier;
  }

  public Expression createObjectArray(List<Expression> expressions, ArrayType arrayType) {
    if (expressions.isEmpty()) {
      return new ArrayCreation(arrayType, typeUtil, 0);
    }
    ArrayInitializer initializer = new ArrayInitializer(arrayType);
    initializer.getExpressions().addAll(expressions);
    return new ArrayCreation(initializer);
  }

  public Expression createAnnotation(AnnotationMirror annotationMirror) {
    DeclaredType type = annotationMirror.getAnnotationType();
    TypeElement typeElem = (TypeElement) type.asElement();
    FunctionElement element =
        new FunctionElement(""create_"" + nameTable.getFullName(typeElem), type, typeElem);
    FunctionInvocation invocation = new FunctionInvocation(element, type);
    Map<? extends ExecutableElement, ? extends AnnotationValue> values =
        typeUtil.elementUtil().getElementValuesWithDefaults(annotationMirror);
    for (ExecutableElement member : ElementUtil.getSortedAnnotationMembers(typeElem)) {
      TypeMirror valueType = member.getReturnType();
      element.addParameters(valueType);
      invocation.addArgument(createAnnotationValue(valueType, values.get(member)));
    }
    return invocation;
  }

  public Expression createAnnotationValue(TypeMirror type, AnnotationValue aValue) {
    Object value = aValue.getValue();
    if (value instanceof VariableElement) {
      return new SimpleName((VariableElement) value);
    } else if (TypeUtil.isArray(type)) {
      assert value instanceof List;
      ArrayType arrayType = (ArrayType) type;
      @SuppressWarnings(""unchecked"")
      List<? extends AnnotationValue> list = (List<? extends AnnotationValue>) value;
      List<Expression> generatedValues = new ArrayList<>();
      for (AnnotationValue elem : list) {
        generatedValues.add(createAnnotationValue(arrayType.getComponentType(), elem));
      }
      return createObjectArray(generatedValues, arrayType);
    } else if (TypeUtil.isAnnotation(type)) {
      assert value instanceof AnnotationMirror;
      return createAnnotation((AnnotationMirror) value);
    } else if (value instanceof TypeMirror) {
      return new TypeLiteral((TypeMirror) value, typeUtil);
    } else {  // Boolean, Character, Number, String
      return TreeUtil.newLiteral(value, typeUtil);
    }
  }

  /**
   * Returns true if an implementation for a type element should be generated.
   * Normally this is true, but in Java 8 a few interfaces from JSR 250
   * (https://jcp.org/en/jsr/detail?id=250) were added, causing duplicate
   * symbol link errors when building an app that uses the other JSR 250
   * annotations. javax.annotation defined on the bootclasspath are therefore
   * ignored, since translating them won't cause link errors later.
   * <p>
   * If the <code>-Xtranslate-bootclasspath</code> flag is specified
   * (normally only when building the jre_emul libraries), then types
   * are always generated.
   */
  public boolean generateImplementation(TypeElement typeElement) {
    if (options.translateBootclasspathFiles()) {
      return true;
    }
    String className = elementUtil.getBinaryName(typeElement).replace('.', '/');
    if (!className.startsWith(""javax/annotation/"")) {
      return true;
    }
    String resourcePath = className.replace('.', '/') + "".class"";
    return jreEmulLoader.findResource(resourcePath) == null;
  }

  private URLClassLoader getJreEmulClassPath(Options options) {
    List<URL>  [MASK]  = new ArrayList<>();
    for (String path : options.getBootClasspath()) {
      if (path.matches(""^.*jre_emul.*jar$"")) {
        try {
           [MASK] .add(new File(path).toURI().toURL());
        } catch (MalformedURLException e) {
          // Ignore bad path.
        }
      }
    }
    return new URLClassLoader( [MASK] .toArray(new URL[0]));
  }
}
","bootURLs
",urlList ,urlList ,urlList,jsonObject,
"package com.tencent.tinker.build.dexpatcher.util;

import com.tencent.tinker.android.dex.ClassData;
import com.tencent.tinker.android.dex.ClassDef;
import com.tencent.tinker.android.dex.Code;
import com.tencent.tinker.android.dex.Dex;
import com.tencent.tinker.android.dex.FieldId;
import com.tencent.tinker.android.dex.MethodId;
import com.tencent.tinker.android.dex.ProtoId;
import com.tencent.tinker.android.dx.instruction.InstructionCodec;
import com.tencent.tinker.android.dx.instruction.InstructionReader;
import com.tencent.tinker.android.dx.instruction.InstructionVisitor;
import com.tencent.tinker.android.dx.instruction.ShortArrayCodeInput;
import com.tencent.tinker.build.util.DexClassesComparator;
import com.tencent.tinker.commons.dexpatcher.DexPatcherLogger;

import java.io.EOFException;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import static com.tencent.tinker.build.util.DexClassesComparator.DexClassInfo;
import static com.tencent.tinker.build.util.DexClassesComparator.DexGroup;

/**
 * Created by tangyinsheng on 2017/2/26.
 */

public class ChangedClassesDexClassInfoCollector {
    private static final String TAG = ""ChangedClassesDexClassInfoCollector"";

    private static final DexPatcherLogger LOGGER = new DexPatcherLogger();
    private final Set<String> excludedClassPatterns = new HashSet<>();
    private boolean includeRefererToRefererAffectedClasses = false;

    public ChangedClassesDexClassInfoCollector setExcludedClassPatterns(Collection<String> loaderClassPatterns) {
        this.excludedClassPatterns.clear();
        this.excludedClassPatterns.addAll(loaderClassPatterns);
        return this;
    }

    public ChangedClassesDexClassInfoCollector clearExcludedClassPatterns() {
        this.excludedClassPatterns.clear();
        return this;
    }

    public ChangedClassesDexClassInfoCollector setLogger(DexPatcherLogger.IDexPatcherLogger loggerImpl) {
        LOGGER.setLoggerImpl(loggerImpl);
        return this;
    }

    public ChangedClassesDexClassInfoCollector setIncludeRefererToRefererAffectedClasses(boolean enabled) {
        this.includeRefererToRefererAffectedClasses = enabled;
        return this;
    }

    public Set<DexClassInfo> doCollect(DexGroup oldDexGroup, DexGroup newDexGroup) {
        final Set<String> classDescsInResult = new HashSet<>();
        final Set<DexClassInfo> result = new HashSet<>();

        DexClassesComparator dexClassCmptor = new DexClassesComparator(""*"");
        dexClassCmptor.setCompareMode(DexClassesComparator.COMPARE_MODE_NORMAL);
        dexClassCmptor.setIgnoredRemovedClassDescPattern(excludedClassPatterns);
        dexClassCmptor.setLogger(LOGGER.getLoggerImpl());
        dexClassCmptor.startCheck(oldDexGroup, newDexGroup);

        // So far we collected infos of all added, changed, and deleted classes.
        result.addAll(dexClassCmptor.getAddedClassInfos());

        final Collection<DexClassInfo[]> changedClassInfos = dexClassCmptor.getChangedClassDescToInfosMap().values();

        for (DexClassInfo[] oldAndNewInfoPair : changedClassInfos) {
            final DexClassInfo newClassInfo = oldAndNewInfoPair[1];

            LOGGER.i(TAG, ""Add class %s to changed classes dex."", newClassInfo.classDesc);
            result.add(newClassInfo);
        }

        for (DexClassInfo classInfo : result) {
            classDescsInResult.add(classInfo.classDesc);
        }

        if (includeRefererToRefererAffectedClasses) {
            // Then we also need to add classes who refer to classes with referrer
            // affected changes to the result. (referrer affected change means the changes
            // that may cause referrer refer to wrong target.)
            dexClassCmptor.setCompareMode(DexClassesComparator.COMPARE_MODE_REFERRER_AFFECTED_CHANGE_ONLY);
            dexClassCmptor.startCheck(oldDexGroup, newDexGroup);

            Set<String> referrerAffectedChangedClassDescs = dexClassCmptor.getChangedClassDescToInfosMap().keySet();
            Set<DexClassInfo> oldClassInfos = oldDexGroup.getClassInfosInDexesWithDuplicateCheck();

            for (DexClassInfo oldClassInfo : oldClassInfos) {
                if (!classDescsInResult.contains(oldClassInfo.classDesc)
                        && isClassReferToAnyClasses(oldClassInfo, referrerAffectedChangedClassDescs)) {
                    LOGGER.i(TAG, ""Add class %s in old dex to changed classes dex since it is affected by modified referee."", oldClassInfo.classDesc);
                    result.add(oldClassInfo);
                }
            }
        }

        return result;
    }

    private boolean isClassReferToAnyClasses(DexClassInfo classInfo, Set<String> refereeClassDescs) {
        if (classInfo.classDef.classDataOffset == ClassDef.NO_OFFSET) {
            return false;
        }
        ClassData classData = classInfo.owner.readClassData(classInfo.classDef);
        for (ClassData.Method method : classData.directMethods) {
            if (isMethodReferToAnyClasses(classInfo, method, refereeClassDescs)) {
                return true;
            }
        }
        for (ClassData.Method method : classData.virtualMethods) {
            if (isMethodReferToAnyClasses(classInfo, method, refereeClassDescs)) {
                return true;
            }
        }
        return false;
    }

    private boolean isMethodReferToAnyClasses(DexClassInfo classInfo, ClassData.Method method, Set<String> refereeClassDescs) {
        if (method.codeOffset == ClassDef.NO_OFFSET) {
            return false;
        }
        Code methodCode = classInfo.owner.readCode(method);
        InstructionReader ir = new InstructionReader(new ShortArrayCodeInput(methodCode.instructions));
        ReferToClassesCheckVisitor rtcv = new ReferToClassesCheckVisitor(classInfo.owner, method, refereeClassDescs);
        try {
            ir.accept(rtcv);
        } catch (EOFException e) {
            // Should not be here.
        }
        return rtcv.isReferToAnyRefereeClasses;
    }

    private static class ReferToClassesCheckVisitor extends InstructionVisitor {
        private final Dex owner;
        private final ClassData.Method method;
        private final Collection<String> refereeClassDescs;

        private boolean isReferToAnyRefereeClasses = false;

        ReferToClassesCheckVisitor(Dex owner, ClassData.Method method, Collection<String> refereeClassDescs) {
            super(null);
            this.owner = owner;
            this.method = method;
            this.refereeClassDescs = refereeClassDescs;
        }

        @Override
        public void visitZeroRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal) {
            processIndexByType(index, indexType);
        }

        @Override
        public void visitOneRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a) {
            processIndexByType(index, indexType);
        }

        @Override
        public void visitTwoRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b) {
            processIndexByType(index, indexType);
        }

        @Override
        public void visitThreeRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c) {
            processIndexByType(index, indexType);
        }

        @Override
        public void visitFourRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d) {
            processIndexByType(index, indexType);
        }

        @Override
        public void visitFiveRegisterInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int b, int c, int d, int e) {
            processIndexByType(index, indexType);
        }

        @Override
        public void visitRegisterRangeInsn(int currentAddress, int opcode, int index, int indexType, int target, long literal, int a, int registerCount) {
            processIndexByType(index, indexType);
        }

        private void processIndexByType(int index, int indexType) {
            String typeName = null;
            String  [MASK]  = null;
            switch (indexType) {
                case InstructionCodec.INDEX_TYPE_TYPE_REF: {
                    typeName = owner.typeNames().get(index);
                     [MASK]  = ""init referrer-affected class"";
                    break;
                }
                case InstructionCodec.INDEX_TYPE_FIELD_REF: {
                    final FieldId fieldId = owner.fieldIds().get(index);
                    typeName = owner.typeNames().get(fieldId.declaringClassIndex);
                     [MASK]  = ""referencing to field: "" + owner.strings().get(fieldId.nameIndex);
                    break;
                }
                case InstructionCodec.INDEX_TYPE_METHOD_REF: {
                    final MethodId methodId = owner.methodIds().get(index);
                    typeName = owner.typeNames().get(methodId.declaringClassIndex);
                     [MASK]  = ""invoking method: "" + getMethodProtoTypeStr(methodId);
                    break;
                }
                default: {
                    break;
                }
            }
            if (typeName != null && refereeClassDescs.contains(typeName)) {
                MethodId methodId = owner.methodIds().get(method.methodIndex);
                LOGGER.i(
                        TAG,
                        ""Method %s in class %s referenced referrer-affected class %s by %s"",
                        getMethodProtoTypeStr(methodId),
                        owner.typeNames().get(methodId.declaringClassIndex),
                        typeName,
                         [MASK] 
                );
                isReferToAnyRefereeClasses = true;
            }
        }

        private String getMethodProtoTypeStr(MethodId methodId) {
            StringBuilder strBuilder = new StringBuilder();
            strBuilder.append(owner.strings().get(methodId.nameIndex));
            ProtoId protoId = owner.protoIds().get(methodId.protoIndex);
            strBuilder.append('(');
            short[] paramTypeIds = owner.parameterTypeIndicesFromMethodId(methodId);
            for (short typeId : paramTypeIds) {
                strBuilder.append(owner.typeNames().get(typeId));
            }
            strBuilder.append(')').append(owner.typeNames().get(protoId.returnTypeIndex));
            return strBuilder.toString();
        }
    }
}
","refInfoInLog
",className,className,referencedClass,changeReason,
"

package android.icu.dev.test.timescale;

import java.util.Date;
import java.util.Locale;

import org.junit.Test;

import android.icu.dev.test.TestFmwk;
import android.icu.util.GregorianCalendar;
import android.icu.util.SimpleTimeZone;
import android.icu.util.TimeZone;
import android.icu.util.UniversalTimeScale;

/**
 * @author Owner
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
public class TimeScaleDataTest extends TestFmwk
{

    /**
     * Default contstructor.
     */
    public TimeScaleDataTest()
    {
    }
    
    private void roundTripTest(long value, int scale)
    {
        long rt = UniversalTimeScale.toLong(UniversalTimeScale.from(value, scale), scale);
        
        if (rt != value) {
            errln(""Round-trip error: time scale = "" + scale + "", value = "" + value + "", round-trip = "" + rt);
        }
    }
    
    private void toLimitTest(long toLimit, long fromLimit, int scale)
    {
        long result = UniversalTimeScale.toLong(toLimit, scale);
        
        if (result != fromLimit) {
            errln(""toLimit failure: scale = "" + scale + "", toLimit = "" + toLimit +
                  "", toLong(toLimit, scale) = "" + result + "", fromLimit = "" + fromLimit);
        }
    }
    
    private void epochOffsetTest(long epochOffset, long units, int scale)
    {
        long universalEpoch = epochOffset * units;
        long local = UniversalTimeScale.toLong(universalEpoch, scale);
        
        if (local != 0) {
            errln(""toLong(epochOffset, scale): scale = "" + scale + "", epochOffset = "" + universalEpoch +
                  "", result = "" + local);
        }
        
        local = UniversalTimeScale.toLong(0, scale);
        
        if (local != -epochOffset) {
            errln(""toLong(0, scale): scale = "" + scale + "", result = "" + local);
        }
        
        long universal = UniversalTimeScale.from(-epochOffset, scale);
        
        if (universal != 0) {
            errln(""from(-epochOffest, scale): scale = "" + scale + "", epochOffset = "" + epochOffset +
                  "", result = "" + universal);
        }
        
        universal = UniversalTimeScale.from(0, scale);
        
        if (universal != universalEpoch) {
            errln(""from(0, scale): scale = "" + scale + "", result = "" + universal);
        }
    }
    
    @Test
    public void TestEpochOffsets()
    {
        for (int scale = 0; scale < UniversalTimeScale.MAX_SCALE; scale += 1) {
            long units       = UniversalTimeScale.getTimeScaleValue(scale, UniversalTimeScale.UNITS_VALUE);
            long epochOffset = UniversalTimeScale.getTimeScaleValue(scale, UniversalTimeScale.EPOCH_OFFSET_VALUE);
            
            epochOffsetTest(epochOffset, units, scale);
        }
    }

    @Test
    public void TestFromLimits()
    {
        for (int scale = 0; scale < UniversalTimeScale.MAX_SCALE; scale += 1) {
            long fromMin = UniversalTimeScale.getTimeScaleValue(scale, UniversalTimeScale.FROM_MIN_VALUE);
            long fromMax = UniversalTimeScale.getTimeScaleValue(scale, UniversalTimeScale.FROM_MAX_VALUE);
            
            roundTripTest(fromMin, scale);
            roundTripTest(fromMax, scale);
        }
    }
    
    @Test
    public void TestToLimits()
    {
        for (int scale = 0; scale < UniversalTimeScale.MAX_SCALE; scale += 1) {
            long fromMin = UniversalTimeScale.getTimeScaleValue(scale, UniversalTimeScale.FROM_MIN_VALUE);
            long fromMax = UniversalTimeScale.getTimeScaleValue(scale, UniversalTimeScale.FROM_MAX_VALUE);
            long  [MASK]    = UniversalTimeScale.getTimeScaleValue(scale, UniversalTimeScale.TO_MIN_VALUE);
            long toMax   = UniversalTimeScale.getTimeScaleValue(scale, UniversalTimeScale.TO_MAX_VALUE);
            
            toLimitTest( [MASK] , fromMin, scale);
            toLimitTest(toMax, fromMax, scale);
       }
    }

    // Test with data from .Net System.DateTime ---------------------------- ***

    /*
     * This data was generated by C++.Net code like
     * Console::WriteLine(L""    {{ {0}, 1, 1, INT64_C({1}) }},"", year, DateTime(year, 1, 1).Ticks);
     * with the DateTime constructor taking int values for year, month, and date.
     */
    static private final long dotNetDateTimeTicks[] = {
        /* year, month, day, ticks */
        100, 1, 1, 31241376000000000L,
        100, 3, 1, 31292352000000000L,
        200, 1, 1, 62798112000000000L,
        200, 3, 1, 62849088000000000L,
        300, 1, 1, 94354848000000000L,
        300, 3, 1, 94405824000000000L,
        400, 1, 1, 125911584000000000L,
        400, 3, 1, 125963424000000000L,
        500, 1, 1, 157469184000000000L,
        500, 3, 1, 157520160000000000L,
        600, 1, 1, 189025920000000000L,
        600, 3, 1, 189076896000000000L,
        700, 1, 1, 220582656000000000L,
        700, 3, 1, 220633632000000000L,
        800, 1, 1, 252139392000000000L,
        800, 3, 1, 252191232000000000L,
        900, 1, 1, 283696992000000000L,
        900, 3, 1, 283747968000000000L,
        1000, 1, 1, 315253728000000000L,
        1000, 3, 1, 315304704000000000L,
        1100, 1, 1, 346810464000000000L,
        1100, 3, 1, 346861440000000000L,
        1200, 1, 1, 378367200000000000L,
        1200, 3, 1, 378419040000000000L,
        1300, 1, 1, 409924800000000000L,
        1300, 3, 1, 409975776000000000L,
        1400, 1, 1, 441481536000000000L,
        1400, 3, 1, 441532512000000000L,
        1500, 1, 1, 473038272000000000L,
        1500, 3, 1, 473089248000000000L,
        1600, 1, 1, 504595008000000000L,
        1600, 3, 1, 504646848000000000L,
        1700, 1, 1, 536152608000000000L,
        1700, 3, 1, 536203584000000000L,
        1800, 1, 1, 567709344000000000L,
        1800, 3, 1, 567760320000000000L,
        1900, 1, 1, 599266080000000000L,
        1900, 3, 1, 599317056000000000L,
        2000, 1, 1, 630822816000000000L,
        2000, 3, 1, 630874656000000000L,
        2100, 1, 1, 662380416000000000L,
        2100, 3, 1, 662431392000000000L,
        2200, 1, 1, 693937152000000000L,
        2200, 3, 1, 693988128000000000L,
        2300, 1, 1, 725493888000000000L,
        2300, 3, 1, 725544864000000000L,
        2400, 1, 1, 757050624000000000L,
        2400, 3, 1, 757102464000000000L,
        2500, 1, 1, 788608224000000000L,
        2500, 3, 1, 788659200000000000L,
        2600, 1, 1, 820164960000000000L,
        2600, 3, 1, 820215936000000000L,
        2700, 1, 1, 851721696000000000L,
        2700, 3, 1, 851772672000000000L,
        2800, 1, 1, 883278432000000000L,
        2800, 3, 1, 883330272000000000L,
        2900, 1, 1, 914836032000000000L,
        2900, 3, 1, 914887008000000000L,
        3000, 1, 1, 946392768000000000L,
        3000, 3, 1, 946443744000000000L,
        1, 1, 1, 0L,
        1601, 1, 1, 504911232000000000L,
        1899, 12, 31, 599265216000000000L,
        1904, 1, 1, 600527520000000000L,
        1970, 1, 1, 621355968000000000L,
        2001, 1, 1, 631139040000000000L,
        9900, 3, 1, 3123873216000000000L,
        9999, 12, 31, 3155378112000000000L
    };

    /*
     * ICU's Universal Time Scale is designed to be tick-for-tick compatible with
     * .Net System.DateTime. Verify that this is so for the
     * .Net-supported date range (years 1-9999 AD).
     * This requires a proleptic Gregorian calendar because that's what .Net uses.
     * Proleptic: No Julian/Gregorian switchover, or a switchover before
     * any date that we test, that is, before 0001 AD.
     */
    @Test
    public void TestDotNet() {
        TimeZone utc;
        final long dayMillis = 86400 * 1000L;    /* 1 day = 86400 seconds */
        final long dayTicks = 86400 * 10000000L;
        final int kYear = 0;  // offset for dotNetDateTimeTicks[] field
        final int kMonth = 1;
        final int kDay = 2;
        final int kTicks = 3;
        final int kIncrement = 4;
        GregorianCalendar cal;
        long icuDate;
        long ticks, millis;
        int i;

        /* Open a proleptic Gregorian calendar. */
        long before0001AD = -1000000 * dayMillis;
        utc = new SimpleTimeZone(0, ""UTC"");
        cal = new GregorianCalendar(utc, Locale.ENGLISH);
        cal.setGregorianChange(new Date(before0001AD));
        for(i = 0; i < dotNetDateTimeTicks.length; i += kIncrement) {
            /* Test conversion from .Net/Universal time to ICU time. */
            millis = UniversalTimeScale.toLong(dotNetDateTimeTicks[i + kTicks], UniversalTimeScale.ICU4C_TIME);
            cal.clear();
            cal.set((int)dotNetDateTimeTicks[i + kYear],
                    (int)dotNetDateTimeTicks[i + kMonth] - 1, /* Java & ICU use January = month 0. */
                    (int)dotNetDateTimeTicks[i + kDay]);
            icuDate = cal.getTimeInMillis();
            if(millis != icuDate) {
                /* Print days not millis. */
                errln(""UniversalTimeScale.toLong(ticks["" + i + ""], ICU4C)="" +
                      (millis/dayMillis) + "" != "" + (icuDate/dayMillis) +
                      ""=ucal_getMillis("" + dotNetDateTimeTicks[i + kYear] +
                      ""-"" + dotNetDateTimeTicks[i + kMonth] +
                      ""-"" + dotNetDateTimeTicks[i + kDay] + "")"");
            }

            /* Test conversion from ICU time to .Net/Universal time. */
            ticks = UniversalTimeScale.from(icuDate, UniversalTimeScale.ICU4C_TIME);
            if(ticks != dotNetDateTimeTicks[i + kTicks]) {
                /* Print days not ticks. */
                errln(""UniversalTimeScale.from(date["" + i + ""], ICU4C)="" +
                      (ticks/dayTicks) + "" != "" + dotNetDateTimeTicks[i + kTicks]/dayTicks +
                      ""=.Net System.DateTime("" + dotNetDateTimeTicks[i + kYear] +
                      ""-"" + dotNetDateTimeTicks[i + kMonth] +
                      ""-"" + dotNetDateTimeTicks[i + kDay] + "").Ticks"");
            }
        }
    }
}
","toMin
","toMin
","toMin
",currentTime,toMin,
"package com.airbnb.lottie.value;

import androidx.annotation.RestrictTo;

/**
 * Data class for use with {@link LottieValueCallback}.
 * You should *not* hold a reference to the frame info parameter passed to your callback. It will be reused.
 */
public class LottieFrameInfo<T> {
  private float startFrame;
  private float endFrame;
  private T startValue;
  private T endValue;
  private float linearKeyframeProgress;
  private float interpolatedKeyframeProgress;
  private float  [MASK] ;

  @RestrictTo(RestrictTo.Scope.LIBRARY)
  public LottieFrameInfo<T> set(
      float startFrame,
      float endFrame,
      T startValue,
      T endValue,
      float linearKeyframeProgress,
      float interpolatedKeyframeProgress,
      float  [MASK] 
  ) {
    this.startFrame = startFrame;
    this.endFrame = endFrame;
    this.startValue = startValue;
    this.endValue = endValue;
    this.linearKeyframeProgress = linearKeyframeProgress;
    this.interpolatedKeyframeProgress = interpolatedKeyframeProgress;
    this. [MASK]  =  [MASK] ;
    return this;
  }

  public float getStartFrame() {
    return startFrame;
  }

  public float getEndFrame() {
    return endFrame;
  }

  public T getStartValue() {
    return startValue;
  }

  public T getEndValue() {
    return endValue;
  }

  public float getLinearKeyframeProgress() {
    return linearKeyframeProgress;
  }

  public float getInterpolatedKeyframeProgress() {
    return interpolatedKeyframeProgress;
  }

  public float getOverallProgress() {
    return  [MASK] ;
  }
}
","overallProgress
",overallProgress,overallProgress,overallProgress,overallProgress,
"
package io.netty.channel.kqueue;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.AddressedEnvelope;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelPromise;
import io.netty.channel.DefaultAddressedEnvelope;
import io.netty.channel.socket.DatagramChannel;
import io.netty.channel.socket.DatagramChannelConfig;
import io.netty.channel.socket.DatagramPacket;
import io.netty.channel.socket.InternetProtocolFamily;
import io.netty.channel.unix.DatagramSocketAddress;
import io.netty.channel.unix.Errors;
import io.netty.channel.unix.IovArray;
import io.netty.channel.unix.UnixChannelUtil;
import io.netty.util.UncheckedBooleanSupplier;
import io.netty.util.internal.ObjectUtil;
import io.netty.util.internal.StringUtil;
import io.netty.util.internal.UnstableApi;

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.NetworkInterface;
import java.net.PortUnreachableException;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.nio.channels.UnresolvedAddressException;

import static io.netty.channel.kqueue.BsdSocket.newSocketDgram;

@UnstableApi
public final class KQueueDatagramChannel extends AbstractKQueueDatagramChannel implements DatagramChannel {
    private static final String EXPECTED_TYPES =
            "" (expected: "" + StringUtil.simpleClassName(DatagramPacket.class) + "", "" +
                    StringUtil.simpleClassName(AddressedEnvelope.class) + '<' +
                    StringUtil.simpleClassName(ByteBuf.class) + "", "" +
                    StringUtil.simpleClassName(InetSocketAddress.class) + "">, "" +
                    StringUtil.simpleClassName(ByteBuf.class) + ')';

    private volatile boolean connected;
    private final KQueueDatagramChannelConfig config;

    public KQueueDatagramChannel() {
        super(null, newSocketDgram(), false);
        config = new KQueueDatagramChannelConfig(this);
    }

    public KQueueDatagramChannel(InternetProtocolFamily protocol) {
        super(null, newSocketDgram(protocol), false);
        config = new KQueueDatagramChannelConfig(this);
    }

    public KQueueDatagramChannel(int fd) {
        this(new BsdSocket(fd), true);
    }

    KQueueDatagramChannel(BsdSocket socket, boolean active) {
        super(null, socket, active);
        config = new KQueueDatagramChannelConfig(this);
    }

    @Override
    public InetSocketAddress remoteAddress() {
        return (InetSocketAddress) super.remoteAddress();
    }

    @Override
    public InetSocketAddress localAddress() {
        return (InetSocketAddress) super.localAddress();
    }

    @Override
    @SuppressWarnings(""deprecation"")
    public boolean isActive() {
        return socket.isOpen() && (config.getActiveOnOpen() && isRegistered() || active);
    }

    @Override
    public boolean isConnected() {
        return connected;
    }

    @Override
    public ChannelFuture joinGroup(InetAddress multicastAddress) {
        return joinGroup(multicastAddress, newPromise());
    }

    @Override
    public ChannelFuture joinGroup(InetAddress multicastAddress, ChannelPromise promise) {
        try {
            NetworkInterface iface = config().getNetworkInterface();
            if (iface == null) {
                iface = NetworkInterface.getByInetAddress(localAddress().getAddress());
            }
            return joinGroup(multicastAddress, iface, null, promise);
        } catch (SocketException e) {
            promise.setFailure(e);
        }
        return promise;
    }

    @Override
    public ChannelFuture joinGroup(
            InetSocketAddress multicastAddress, NetworkInterface networkInterface) {
        return joinGroup(multicastAddress, networkInterface, newPromise());
    }

    @Override
    public ChannelFuture joinGroup(
            InetSocketAddress multicastAddress, NetworkInterface networkInterface,
            ChannelPromise promise) {
        return joinGroup(multicastAddress.getAddress(), networkInterface, null, promise);
    }

    @Override
    public ChannelFuture joinGroup(
            InetAddress multicastAddress, NetworkInterface networkInterface, InetAddress source) {
        return joinGroup(multicastAddress, networkInterface, source, newPromise());
    }

    @Override
    public ChannelFuture joinGroup(
            final InetAddress multicastAddress, final NetworkInterface networkInterface,
            final InetAddress source, final ChannelPromise promise) {

        ObjectUtil.checkNotNull(multicastAddress, ""multicastAddress"");
        ObjectUtil.checkNotNull(networkInterface, ""networkInterface"");

        promise.setFailure(new UnsupportedOperationException(""Multicast not supported""));
        return promise;
    }

    @Override
    public ChannelFuture leaveGroup(InetAddress multicastAddress) {
        return leaveGroup(multicastAddress, newPromise());
    }

    @Override
    public ChannelFuture leaveGroup(InetAddress multicastAddress, ChannelPromise promise) {
        try {
            return leaveGroup(
                    multicastAddress, NetworkInterface.getByInetAddress(localAddress().getAddress()), null, promise);
        } catch (SocketException e) {
            promise.setFailure(e);
        }
        return promise;
    }

    @Override
    public ChannelFuture leaveGroup(
            InetSocketAddress multicastAddress, NetworkInterface networkInterface) {
        return leaveGroup(multicastAddress, networkInterface, newPromise());
    }

    @Override
    public ChannelFuture leaveGroup(
            InetSocketAddress multicastAddress,
            NetworkInterface networkInterface, ChannelPromise promise) {
        return leaveGroup(multicastAddress.getAddress(), networkInterface, null, promise);
    }

    @Override
    public ChannelFuture leaveGroup(
            InetAddress multicastAddress, NetworkInterface networkInterface, InetAddress source) {
        return leaveGroup(multicastAddress, networkInterface, source, newPromise());
    }

    @Override
    public ChannelFuture leaveGroup(
            final InetAddress multicastAddress, final NetworkInterface networkInterface, final InetAddress source,
            final ChannelPromise promise) {
        ObjectUtil.checkNotNull(multicastAddress, ""multicastAddress"");
        ObjectUtil.checkNotNull(networkInterface, ""networkInterface"");

        promise.setFailure(new UnsupportedOperationException(""Multicast not supported""));

        return promise;
    }

    @Override
    public ChannelFuture block(
            InetAddress multicastAddress, NetworkInterface networkInterface,
            InetAddress sourceToBlock) {
        return block(multicastAddress, networkInterface, sourceToBlock, newPromise());
    }

    @Override
    public ChannelFuture block(
            final InetAddress multicastAddress, final NetworkInterface networkInterface,
            final InetAddress sourceToBlock, final ChannelPromise promise) {
        ObjectUtil.checkNotNull(multicastAddress, ""multicastAddress"");
        ObjectUtil.checkNotNull(sourceToBlock, ""sourceToBlock"");
        ObjectUtil.checkNotNull(networkInterface, ""networkInterface"");
        promise.setFailure(new UnsupportedOperationException(""Multicast not supported""));
        return promise;
    }

    @Override
    public ChannelFuture block(InetAddress multicastAddress, InetAddress sourceToBlock) {
        return block(multicastAddress, sourceToBlock, newPromise());
    }

    @Override
    public ChannelFuture block(
            InetAddress multicastAddress, InetAddress sourceToBlock, ChannelPromise promise) {
        try {
            return block(
                    multicastAddress,
                    NetworkInterface.getByInetAddress(localAddress().getAddress()),
                    sourceToBlock, promise);
        } catch (Throwable e) {
            promise.setFailure(e);
        }
        return promise;
    }

    @Override
    protected AbstractKQueueUnsafe newUnsafe() {
        return new KQueueDatagramChannelUnsafe();
    }

    @Override
    protected void doBind(SocketAddress localAddress) throws Exception {
        super.doBind(localAddress);
        active = true;
    }

    @Override
    protected boolean doWriteMessage(Object msg) throws Exception {
        final ByteBuf data;
        InetSocketAddress remoteAddress;
        if (msg instanceof AddressedEnvelope) {
            @SuppressWarnings(""unchecked"")
            AddressedEnvelope<ByteBuf, InetSocketAddress> envelope =
                    (AddressedEnvelope<ByteBuf, InetSocketAddress>) msg;
            data = envelope.content();
            remoteAddress = envelope.recipient();
        } else {
            data = (ByteBuf) msg;
            remoteAddress = null;
        }

        final int dataLen = data.readableBytes();
        if (dataLen == 0) {
            return true;
        }

        final long  [MASK] ;
        if (data.hasMemoryAddress()) {
            long memoryAddress = data.memoryAddress();
            if (remoteAddress == null) {
                 [MASK]  = socket.writeAddress(memoryAddress, data.readerIndex(), data.writerIndex());
            } else {
                 [MASK]  = socket.sendToAddress(memoryAddress, data.readerIndex(), data.writerIndex(),
                        remoteAddress.getAddress(), remoteAddress.getPort());
            }
        } else if (data.nioBufferCount() > 1) {
            IovArray array = ((KQueueEventLoop) eventLoop()).cleanArray();
            array.add(data, data.readerIndex(), data.readableBytes());
            int cnt = array.count();
            assert cnt != 0;

            if (remoteAddress == null) {
                 [MASK]  = socket.writevAddresses(array.memoryAddress(0), cnt);
            } else {
                 [MASK]  = socket.sendToAddresses(array.memoryAddress(0), cnt,
                        remoteAddress.getAddress(), remoteAddress.getPort());
            }
        } else {
            ByteBuffer nioData = data.internalNioBuffer(data.readerIndex(), data.readableBytes());
            if (remoteAddress == null) {
                 [MASK]  = socket.write(nioData, nioData.position(), nioData.limit());
            } else {
                 [MASK]  = socket.sendTo(nioData, nioData.position(), nioData.limit(),
                        remoteAddress.getAddress(), remoteAddress.getPort());
            }
        }

        return  [MASK]  > 0;
    }

    private static void checkUnresolved(AddressedEnvelope<?, ?> envelope) {
        if (envelope.recipient() instanceof InetSocketAddress
                && (((InetSocketAddress) envelope.recipient()).isUnresolved())) {
            throw new UnresolvedAddressException();
        }
    }

    @Override
    protected Object filterOutboundMessage(Object msg) {
        if (msg instanceof DatagramPacket) {
            DatagramPacket packet = (DatagramPacket) msg;
            checkUnresolved(packet);
            ByteBuf content = packet.content();
            return UnixChannelUtil.isBufferCopyNeededForWrite(content) ?
                    new DatagramPacket(newDirectBuffer(packet, content), packet.recipient()) : msg;
        }

        if (msg instanceof ByteBuf) {
            ByteBuf buf = (ByteBuf) msg;
            return UnixChannelUtil.isBufferCopyNeededForWrite(buf) ? newDirectBuffer(buf) : buf;
        }

        if (msg instanceof AddressedEnvelope) {
            @SuppressWarnings(""unchecked"")
            AddressedEnvelope<Object, SocketAddress> e = (AddressedEnvelope<Object, SocketAddress>) msg;
            checkUnresolved(e);

            if (e.content() instanceof ByteBuf &&
                    (e.recipient() == null || e.recipient() instanceof InetSocketAddress)) {

                ByteBuf content = (ByteBuf) e.content();
                return UnixChannelUtil.isBufferCopyNeededForWrite(content) ?
                        new DefaultAddressedEnvelope<ByteBuf, InetSocketAddress>(
                                newDirectBuffer(e, content), (InetSocketAddress) e.recipient()) : e;
            }
        }

        throw new UnsupportedOperationException(
                ""unsupported message type: "" + StringUtil.simpleClassName(msg) + EXPECTED_TYPES);
    }

    @Override
    public KQueueDatagramChannelConfig config() {
        return config;
    }

    @Override
    protected void doDisconnect() throws Exception {
        socket.disconnect();
        connected = active = false;
        resetCachedAddresses();
    }

    @Override
    protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
        if (super.doConnect(remoteAddress, localAddress)) {
            connected = true;
            return true;
        }
        return false;
    }

    @Override
    protected void doClose() throws Exception {
        super.doClose();
        connected = false;
    }

    final class KQueueDatagramChannelUnsafe extends AbstractKQueueUnsafe {

        @Override
        void readReady(KQueueRecvByteAllocatorHandle allocHandle) {
            assert eventLoop().inEventLoop();
            final DatagramChannelConfig config = config();
            if (shouldBreakReadReady(config)) {
                clearReadFilter0();
                return;
            }
            final ChannelPipeline pipeline = pipeline();
            final ByteBufAllocator allocator = config.getAllocator();
            allocHandle.reset(config);
            readReadyBefore();

            Throwable exception = null;
            try {
                ByteBuf byteBuf = null;
                try {
                    boolean connected = isConnected();
                    do {
                        byteBuf = allocHandle.allocate(allocator);
                        allocHandle.attemptedBytesRead(byteBuf.writableBytes());

                        final DatagramPacket packet;
                        if (connected) {
                            try {
                                allocHandle.lastBytesRead(doReadBytes(byteBuf));
                            } catch (Errors.NativeIoException e) {
                                // We need to correctly translate connect errors to match NIO behaviour.
                                if (e.expectedErr() == Errors.ERROR_ECONNREFUSED_NEGATIVE) {
                                    PortUnreachableException error = new PortUnreachableException(e.getMessage());
                                    error.initCause(e);
                                    throw error;
                                }
                                throw e;
                            }
                            if (allocHandle.lastBytesRead() <= 0) {
                                // nothing was read, release the buffer.
                                byteBuf.release();
                                byteBuf = null;
                                break;
                            }
                            packet = new DatagramPacket(byteBuf,
                                    (InetSocketAddress) localAddress(), (InetSocketAddress) remoteAddress());
                        } else {
                            final DatagramSocketAddress remoteAddress;
                            if (byteBuf.hasMemoryAddress()) {
                                // has a memory address so use optimized call
                                remoteAddress = socket.recvFromAddress(byteBuf.memoryAddress(), byteBuf.writerIndex(),
                                        byteBuf.capacity());
                            } else {
                                ByteBuffer nioData = byteBuf.internalNioBuffer(
                                        byteBuf.writerIndex(), byteBuf.writableBytes());
                                remoteAddress = socket.recvFrom(nioData, nioData.position(), nioData.limit());
                            }

                            if (remoteAddress == null) {
                                allocHandle.lastBytesRead(-1);
                                byteBuf.release();
                                byteBuf = null;
                                break;
                            }
                            InetSocketAddress localAddress = remoteAddress.localAddress();
                            if (localAddress == null) {
                                localAddress = (InetSocketAddress) localAddress();
                            }
                            allocHandle.lastBytesRead(remoteAddress.receivedAmount());
                            byteBuf.writerIndex(byteBuf.writerIndex() + allocHandle.lastBytesRead());

                            packet = new DatagramPacket(byteBuf, localAddress, remoteAddress);
                        }

                        allocHandle.incMessagesRead(1);

                        readPending = false;
                        pipeline.fireChannelRead(packet);

                        byteBuf = null;

                    // We use the TRUE_SUPPLIER as it is also ok to read less then what we did try to read (as long
                    // as we read anything).
                    } while (allocHandle.continueReading(UncheckedBooleanSupplier.TRUE_SUPPLIER));
                } catch (Throwable t) {
                    if (byteBuf != null) {
                        byteBuf.release();
                    }
                    exception = t;
                }

                allocHandle.readComplete();
                pipeline.fireChannelReadComplete();

                if (exception != null) {
                    pipeline.fireExceptionCaught(exception);
                }
            } finally {
                readReadyFinally(config);
            }
        }
    }
}
","writtenBytes
",bytesSentSent,numSent,writtenBytes,writtenBytes,
"
package com.google.devtools.build.lib.skyframe;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.devtools.build.lib.analysis.BlazeDirectories;
import com.google.devtools.build.lib.cmdline.RepositoryName;
import com.google.devtools.build.lib.skyframe.ProcessPackageDirectory.ProcessPackageDirectorySkyFunctionException;
import com.google.devtools.build.lib.vfs.PathFragment;
import com.google.devtools.build.lib.vfs.RootedPath;
import com.google.devtools.build.skyframe.SkyFunction;
import com.google.devtools.build.skyframe.SkyKey;
import com.google.devtools.build.skyframe.SkyValue;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * Computes {@link CollectPackagesUnderDirectoryValue} which describes whether the directory is a
 * package, or would have been a package but for a package loading error, and whether non-excluded
 * packages (or errors) exist below each of the directory's subdirectories. As a side effect, loads
 * all of these packages, in order to interleave the disk-bound work of checking for directories and
 * the CPU-bound work of package loading.
 */
public class CollectPackagesUnderDirectoryFunction implements SkyFunction {
  private final BlazeDirectories directories;

  public CollectPackagesUnderDirectoryFunction(BlazeDirectories directories) {
    this.directories = directories;
  }

  @Override
  public SkyValue compute(SkyKey skyKey, Environment env)
      throws InterruptedException, ProcessPackageDirectorySkyFunctionException {
    return new MyTraversalFunction(directories)
        .visitDirectory((RecursivePkgKey) skyKey.argument(), env);
  }

  /** The {@link RecursiveDirectoryTraversalFunction} used by our traversal. */
  public static class MyTraversalFunction
      extends RecursiveDirectoryTraversalFunction<
          MyPackageDirectoryConsumer, CollectPackagesUnderDirectoryValue> {
    protected MyTraversalFunction(BlazeDirectories directories) {
      super(directories);
    }

    @Override
    protected MyPackageDirectoryConsumer getInitialConsumer() {
      return new MyPackageDirectoryConsumer();
    }

    @Override
    protected SkyKey getSkyKeyForSubdirectory(
        RepositoryName repository,
        RootedPath subdirectory,
        ImmutableSet<PathFragment> excludedSubdirectoriesBeneathSubdirectory) {
      return CollectPackagesUnderDirectoryValue.key(
          repository, subdirectory, excludedSubdirectoriesBeneathSubdirectory);
    }

    @Override
    protected CollectPackagesUnderDirectoryValue aggregateWithSubdirectorySkyValues(
        MyPackageDirectoryConsumer consumer, Map<SkyKey, SkyValue> subdirectorySkyValues) {
      // Aggregate the child subdirectory package state.
      ImmutableMap.Builder<RootedPath, Boolean> builder = ImmutableMap.builder();
      for (SkyKey key : subdirectorySkyValues.keySet()) {
        RecursivePkgKey  [MASK]  = (RecursivePkgKey) key.argument();
        CollectPackagesUnderDirectoryValue collectPackagesValue =
            (CollectPackagesUnderDirectoryValue) subdirectorySkyValues.get(key);

        boolean packagesOrErrorsInSubdirectory =
            collectPackagesValue.isDirectoryPackage()
                || collectPackagesValue.getErrorMessage() != null
                || Iterables.contains(
                    collectPackagesValue
                        .getSubdirectoryTransitivelyContainsPackagesOrErrors()
                        .values(),
                    Boolean.TRUE);

        builder.put( [MASK] .getRootedPath(), packagesOrErrorsInSubdirectory);
      }
      ImmutableMap<RootedPath, Boolean> subdirectories = builder.buildOrThrow();
      String errorMessage = consumer.getErrorMessage();
      if (errorMessage != null) {
        return CollectPackagesUnderDirectoryValue.ofError(errorMessage, subdirectories);
      }
      return CollectPackagesUnderDirectoryValue.ofNoError(
          consumer.isDirectoryPackage(), subdirectories);
    }
  }

  private static class MyPackageDirectoryConsumer
      implements RecursiveDirectoryTraversalFunction.PackageDirectoryConsumer {

    private boolean isDirectoryPackage;
    @Nullable private String errorMessage;

    private MyPackageDirectoryConsumer() {}

    @Override
    public void notePackage(PathFragment pkgPath) {
      isDirectoryPackage = true;
    }

    @Override
    public void notePackageError(String noSuchPackageExceptionErrorMessage) {
      this.errorMessage = noSuchPackageExceptionErrorMessage;
    }

    boolean isDirectoryPackage() {
      return isDirectoryPackage;
    }

    @Nullable
    String getErrorMessage() {
      return errorMessage;
    }
  }
}
","recursivePkgKey
",rootKey,recursivePkgKey,recursivePkgKey,pkgKey,
"
package io.netty.handler.codec.http2;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.PooledByteBufAllocator;
import io.netty.buffer.Unpooled;
import io.netty.buffer.UnpooledByteBufAllocator;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.channel.ChannelPromise;
import io.netty.microbench.channel.EmbeddedChannelWriteReleaseHandlerContext;
import io.netty.microbench.util.AbstractMicrobenchmark;
import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.BenchmarkMode;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Level;
import org.openjdk.jmh.annotations.Measurement;
import org.openjdk.jmh.annotations.Mode;
import org.openjdk.jmh.annotations.OutputTimeUnit;
import org.openjdk.jmh.annotations.Param;
import org.openjdk.jmh.annotations.Scope;
import org.openjdk.jmh.annotations.Setup;
import org.openjdk.jmh.annotations.State;
import org.openjdk.jmh.annotations.TearDown;
import org.openjdk.jmh.annotations.Warmup;

import java.util.concurrent.TimeUnit;

import static io.netty.buffer.Unpooled.directBuffer;
import static io.netty.buffer.Unpooled.unreleasableBuffer;
import static io.netty.handler.codec.http2.Http2CodecUtil.DATA_FRAME_HEADER_LENGTH;
import static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_MAX_FRAME_SIZE;
import static io.netty.handler.codec.http2.Http2CodecUtil.MAX_UNSIGNED_BYTE;
import static io.netty.handler.codec.http2.Http2CodecUtil.verifyPadding;
import static io.netty.handler.codec.http2.Http2CodecUtil.writeFrameHeaderInternal;
import static io.netty.handler.codec.http2.Http2FrameTypes.DATA;
import static io.netty.util.internal.ObjectUtil.checkPositive;
import static java.lang.Math.max;
import static java.lang.Math.min;

@Fork(1)
@Warmup(iterations = 5)
@Measurement(iterations = 5)
@State(Scope.Benchmark)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class Http2FrameWriterDataBenchmark extends AbstractMicrobenchmark {
    @Param({ ""64"", ""1024"", ""4096"", ""16384"", ""1048576"", ""4194304"" })
    public int payloadSize;

    @Param({ ""0"", ""100"", ""255"" })
    public int padding;

    @Param({ ""true"", ""false"" })
    public boolean pooled;

    private ByteBuf payload;
    private ChannelHandlerContext ctx;
    private Http2DataWriter writer;
    private Http2DataWriter oldWriter;

    @Setup(Level.Trial)
    public void setup() {
        writer = new DefaultHttp2FrameWriter();
        oldWriter = new OldDefaultHttp2FrameWriter();
        payload = pooled ? PooledByteBufAllocator.DEFAULT.buffer(payloadSize) : Unpooled.buffer(payloadSize);
        payload.writeZero(payloadSize);
        ctx = new EmbeddedChannelWriteReleaseHandlerContext(
                pooled ? PooledByteBufAllocator.DEFAULT : UnpooledByteBufAllocator.DEFAULT,
                new ChannelInboundHandlerAdapter()) {
            @Override
            protected void handleException(Throwable t) {
                handleUnexpectedException(t);
            }
        };
    }

    @TearDown(Level.Trial)
    public void teardown() throws Exception {
        if (payload != null) {
            payload.release();
        }
        if (ctx != null) {
            ctx.close();
        }
    }

    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    public void newWriter() {
        writer.writeData(ctx, 3, payload.retain(), padding, true, ctx.voidPromise());
        ctx.flush();
    }

    @Benchmark
    @BenchmarkMode(Mode.AverageTime)
    public void oldWriter() {
        oldWriter.writeData(ctx, 3, payload.retain(), padding, true, ctx.voidPromise());
        ctx.flush();
    }

    private static final class OldDefaultHttp2FrameWriter implements Http2DataWriter {
        private static final ByteBuf ZERO_BUFFER =
                unreleasableBuffer(directBuffer(MAX_UNSIGNED_BYTE).writeZero(MAX_UNSIGNED_BYTE)).asReadOnly();
        private final int maxFrameSize = DEFAULT_MAX_FRAME_SIZE;
        @Override
        public ChannelFuture writeData(ChannelHandlerContext ctx, int streamId, ByteBuf data,
                                       int padding, boolean endStream, ChannelPromise promise) {
            final Http2CodecUtil.SimpleChannelPromiseAggregator  [MASK]  =
                    new Http2CodecUtil.SimpleChannelPromiseAggregator(promise, ctx.channel(), ctx.executor());
            final DataFrameHeader header = new DataFrameHeader(ctx, streamId);
            boolean needToReleaseHeaders = true;
            boolean needToReleaseData = true;
            try {
                checkPositive(streamId, ""streamId"");
                verifyPadding(padding);

                boolean lastFrame;
                int remainingData = data.readableBytes();
                do {
                    // Determine how much data and padding to write in this frame. Put all padding at the end.
                    int frameDataBytes = min(remainingData, maxFrameSize);
                    int framePaddingBytes = min(padding, max(0, (maxFrameSize - 1) - frameDataBytes));

                    // Decrement the remaining counters.
                    padding -= framePaddingBytes;
                    remainingData -= frameDataBytes;

                    // Determine whether or not this is the last frame to be sent.
                    lastFrame = remainingData == 0 && padding == 0;

                    // Only the last frame is not retained. Until then, the outer finally must release.
                    ByteBuf frameHeader = header.slice(frameDataBytes, framePaddingBytes, lastFrame && endStream);
                    needToReleaseHeaders = !lastFrame;
                    ctx.write(lastFrame ? frameHeader : frameHeader.retain(),  [MASK] .newPromise());

                    // Write the frame data.
                    ByteBuf frameData = data.readSlice(frameDataBytes);
                    // Only the last frame is not retained. Until then, the outer finally must release.
                    needToReleaseData = !lastFrame;
                    ctx.write(lastFrame ? frameData : frameData.retain(),  [MASK] .newPromise());

                    // Write the frame padding.
                    if (paddingBytes(framePaddingBytes) > 0) {
                        ctx.write(ZERO_BUFFER.slice(0, paddingBytes(framePaddingBytes)),
                                 [MASK] .newPromise());
                    }
                } while (!lastFrame);
            } catch (Throwable t) {
                try {
                    if (needToReleaseHeaders) {
                        header.release();
                    }
                    if (needToReleaseData) {
                        data.release();
                    }
                } finally {
                     [MASK] .setFailure(t);
                     [MASK] .doneAllocatingPromises();
                }
                return  [MASK] ;
            }
            return  [MASK] .doneAllocatingPromises();
        }

        private static int paddingBytes(int padding) {
            // The padding parameter contains the 1 byte pad length field as well as the trailing padding bytes.
            // Subtract 1, so to only get the number of padding bytes that need to be appended to the end of a frame.
            return padding - 1;
        }

        private static void writePaddingLength(ByteBuf buf, int padding) {
            if (padding > 0) {
                // It is assumed that the padding length has been bounds checked before this
                // Minus 1, as the pad length field is included in the padding parameter and is 1 byte wide.
                buf.writeByte(padding - 1);
            }
        }

        /**
         * Utility class that manages the creation of frame header buffers for {@code DATA} frames. Attempts
         * to reuse the same buffer repeatedly when splitting data into multiple frames.
         */
        private static final class DataFrameHeader {
            private final int streamId;
            private final ByteBuf buffer;
            private final Http2Flags flags = new Http2Flags();
            private int prevData;
            private int prevPadding;
            private ByteBuf frameHeader;

            DataFrameHeader(ChannelHandlerContext ctx, int streamId) {
                // All padding will be put at the end, so in the worst case we need 3 headers:
                // a repeated no-padding frame of maxFrameSize, a frame that has part data and part
                // padding, and a frame that has the remainder of the padding.
                buffer = ctx.alloc().buffer(3 * DATA_FRAME_HEADER_LENGTH);
                this.streamId = streamId;
            }

            /**
             * Gets the frame header buffer configured for the current frame.
             */
            ByteBuf slice(int data, int padding, boolean endOfStream) {
                // Since we're reusing the current frame header whenever possible, check if anything changed
                // that requires a new header.
                if (data != prevData || padding != prevPadding
                        || endOfStream != flags.endOfStream() || frameHeader == null) {
                    // Update the header state.
                    prevData = data;
                    prevPadding = padding;
                    flags.paddingPresent(padding > 0);
                    flags.endOfStream(endOfStream);
                    frameHeader = buffer.slice(buffer.readerIndex(), DATA_FRAME_HEADER_LENGTH).writerIndex(0);
                    buffer.setIndex(buffer.readerIndex() + DATA_FRAME_HEADER_LENGTH,
                            buffer.writerIndex() + DATA_FRAME_HEADER_LENGTH);

                    int payloadLength = data + padding;
                    writeFrameHeaderInternal(frameHeader, payloadLength, DATA, flags, streamId);
                    writePaddingLength(frameHeader, padding);
                }
                return frameHeader.slice();
            }

            void release() {
                buffer.release();
            }
        }
    }
}
","promiseAggregator
",promise,resFramePromise,promiseAggregator,aggregator,
"

package com.badlogic.gdx.tests;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Colors;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.Texture.TextureFilter;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.BitmapFontCache;
import com.badlogic.gdx.graphics.g2d.GlyphLayout;
import com.badlogic.gdx.graphics.g2d.GlyphLayout.GlyphRun;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.scenes.scene2d.ui.Window;
import com.badlogic.gdx.tests.utils.GdxTest;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.ScreenUtils;
import com.badlogic.gdx.utils.viewport.ScreenViewport;

public class BitmapFontTest extends GdxTest {
        private Stage stage;
        private SpriteBatch spriteBatch;
        private BitmapFont font;
        private ShapeRenderer renderer;
        private BitmapFont multiPageFont;
        private BitmapFont smallFont;
        private GlyphLayout layout;
        private Label label;

        @Override
        public void create () {
                spriteBatch = new SpriteBatch();
                // font = new BitmapFont(Gdx.files.internal(""data/verdana39.fnt""), false);
                font = new BitmapFont(Gdx.files.internal(""data/lsans-32-pad.fnt""), false);
                smallFont = new BitmapFont(); // uses LSans 15, the default
                // font = new FreeTypeFontGenerator(Gdx.files.internal(""data/lsans.ttf"")).generateFont(new FreeTypeFontParameter());
                font.getData().markupEnabled = true;
                font.getData().breakChars = new char[] {'-'};

                multiPageFont = new BitmapFont(Gdx.files.internal(""data/multipagefont.fnt""));

                // Add user defined color
                Colors.put(""PERU"", Color.valueOf(""CD853F""));

                renderer = new ShapeRenderer();
                renderer.setProjectionMatrix(spriteBatch.getProjectionMatrix());

                stage = new Stage(new ScreenViewport());

                Skin skin = new Skin(Gdx.files.internal(""data/uiskin.json""));

                BitmapFont labelFont = skin.get(""default-font"", BitmapFont.class);
                labelFont.getData().markupEnabled = true;

                // Notice that the last [] has been deliberately added to test the effect of excessive pop operations.
                // They are silently ignored, as expected.
                label = new Label(""<<[BLUE]M[RED]u[YELLOW]l[GREEN]t[OLIVE]ic[]o[]l[]o[]r[]*[MAROON]Label[][] [Unknown Color]>>"", skin);
                label.setPosition(100, 200);
                stage.addActor(label);

                Window window = new Window(""[RED]Multicolor[GREEN] Title"", skin);
                window.setPosition(400, 300);
                window.pack();
                stage.addActor(window);

                layout = new GlyphLayout();
        }

        @Override
        public void render () {
                // red.a = (red.a + Gdx.graphics.getDeltaTime() * 0.1f) % 1;

                int viewHeight = Gdx.graphics.getHeight();

                ScreenUtils.clear(0, 0, 0, 1);

                // Test wrapping or truncation with the font directly.
                if (true) {
                        // BitmapFont font = label.getStyle().font;
                        BitmapFont font = this.font;
                        font.getData().markupEnabled = true;
                        font.getRegion().getTexture().setFilter(TextureFilter.Nearest, TextureFilter.Nearest);

                        font.getData().setScale(2f);
                        renderer.begin(ShapeRenderer.ShapeType.Line);
                        renderer.setColor(0, 1, 0, 1);
                        float w = Gdx.input.getX() - 10;
                        // w = 855;
                        renderer.rect(10, 10, w, 500);
                        renderer.end();

                        spriteBatch.begin();
                        String text = ""your new"";
                        // text = ""How quickly da[RED]ft jumping zebras vex."";
                        // text = ""Another font wrap is-sue, this time with multiple whitespace characters."";
                        // text = ""test with AGWlWi AGWlWi issue"";
                        // text = ""AA BB \nEE""; // When wrapping after BB, there should not be a blank line before EE.
                        text = ""[BLUE]A[]A BB [#00f000]EE[] T [GREEN]e[]   \r\r[PINK]\n\nV[][YELLOW]a bb[] ([CYAN]5[]FFFurz)\nV[PURPLE]a[]\nVa\n[PURPLE]V[]a"";
                        if (true) { // Test wrap.
                                layout.setText(font, text, 0, text.length(), font.getColor(), w, Align.center, true, null);
                        } else { // Test truncation.
                                layout.setText(font, text, 0, text.length(), font.getColor(), w, Align.center, false, ""..."");
                        }
                        float meowy = (500 / 2 + layout.height / 2 + 5);
                        font.draw(spriteBatch, layout, 10, 10 + meowy);
                        spriteBatch.end();

                        Gdx.gl.glEnable(GL20.GL_BLEND);
                        Gdx.gl.glBlendFunc(GL20.GL_ONE, GL20.GL_ONE);
                        renderer.begin(ShapeRenderer.ShapeType.Line);
                        float c = 0.8f;

                        // GlyphLayout bounds
                        if (true) {
                                renderer.setColor(c, c, c, 1);
                                renderer.rect(10 + 0.5f * (w - layout.width), 10 + meowy, layout.width, -layout.height);
                        }
                        // GlyphRun bounds
                        for (int i = 0, n = layout.runs.size; i < n; i++) {
                                if (i % 3 == 0)
                                        renderer.setColor(c, 0, c, 1);
                                else if (i % 2 == 0)
                                        renderer.setColor(0, c, c, 1);
                                else
                                        renderer.setColor(c, c, 0, 1);
                                GlyphRun r = layout.runs.get(i);
                                renderer.rect(10 + r.x, 10 + meowy + r.y, r.width, -font.getLineHeight());
                        }
                        renderer.end();
                        font.getData().setScale(1f);
                        return;
                }

                // Test wrapping with label.
                if (false) {
                        label.debug();
                        label.getStyle().font = font;
                        label.setStyle(label.getStyle());
                        label.setText(""How quickly [RED]daft[] jumping zebras vex."");
                        label.setWrap(true);
// label.setEllipsis(true);
                        label.setAlignment(Align.center, Align.right);
                        label.setWidth(Gdx.input.getX() - label.getX());
                        label.setHeight(label.getPrefHeight());
                } else {
                        // Test various font features.
                        spriteBatch.begin();

                        String text = ""Sphinx of black quartz, judge my vow."";
                        font.setColor(Color.RED);

                        float x = 100, y = 20;
                        float  [MASK] ;

                        if (false) {
                                 [MASK]  = 0;
                                font.draw(spriteBatch, text, x, viewHeight - y,  [MASK] , Align.right, false);
                        }

                        if (true) {
                                 [MASK]  = 280;
                                font.draw(spriteBatch, text, x, viewHeight - y,  [MASK] , Align.right, true);
                        }

                        font.draw(spriteBatch, ""["", 50, 60, 100, Align.left, true);
                        font.getData().markupEnabled = true;
                        font.draw(spriteBatch, ""["", 100, 60, 100, Align.left, true);
                        font.getData().markupEnabled = false;

                        // 'R' and 'p' are in different pages
                        String txt2 = ""this font uses "" + multiPageFont.getRegions().size + "" texture pages: RpRpRpRpRpNM"";
                        spriteBatch.renderCalls = 0;

                        // regular draw function
                        multiPageFont.setColor(Color.BLUE);
                        multiPageFont.draw(spriteBatch, txt2, 10, 100);

                        // expert usage.. drawing with bitmap font cache
                        BitmapFontCache cache = multiPageFont.getCache();
                        cache.clear();
                        cache.setColor(Color.BLACK);
                        cache.setText(txt2, 10, 50);
                        cache.setColors(Color.PINK, 3, 6);
                        cache.setColors(Color.ORANGE, 9, 12);
                        cache.setColors(Color.GREEN, 16, txt2.length());
                        cache.draw(spriteBatch, 5, txt2.length() - 5);

                        cache.clear();
                        cache.setColor(Color.BLACK);
                        float textX = 10;
                        textX += cache.setText(""[black] "", textX, 150).width;
                        multiPageFont.getData().markupEnabled = true;
                        textX += cache.addText(""[[[PINK]pink[]] "", textX, 150).width;
                        textX += cache.addText(""[PERU][[peru] "", textX, 150).width;
                        cache.setColor(Color.GREEN);
                        textX += cache.addText(""green "", textX, 150).width;
                        textX += cache.addText(""[#A52A2A]br[#A52A2ADF]ow[#A52A2ABF]n f[#A52A2A9F]ad[#A52A2A7F]in[#A52A2A5F]g o[#A52A2A3F]ut "",
                                textX, 150).width;
                        multiPageFont.getData().markupEnabled = false;

                        cache.draw(spriteBatch);

                        // tinting
                        cache.tint(new Color(1f, 1f, 1f, 0.3f));
                        cache.translate(0f, 40f);
                        cache.draw(spriteBatch);

                        cache = smallFont.getCache();
                        // String neeeds to be pretty long to trigger the crash described in #5834; fixed now
                        final String trogdor = ""TROGDOR! TROGDOR! Trogdor was a man! Or maybe he was a... Dragon-Man!"";
                        cache.clear();
                        cache.addText(trogdor, 24, 37, 500, Align.center, true);
                        cache.setColors(Color.FOREST, 0, trogdor.length());
                        cache.draw(spriteBatch);

                        spriteBatch.end();
                        // System.out.println(spriteBatch.renderCalls);

                        renderer.begin(ShapeType.Line);
                        renderer.setColor(Color.BLACK);
                        renderer.rect(x, viewHeight - y - 200,  [MASK] , 200);
                        renderer.end();
                }

                stage.act(Gdx.graphics.getDeltaTime());
                stage.draw();
        }

        public void resize (int width, int height) {
                spriteBatch.getProjectionMatrix().setToOrtho2D(0, 0, width, height);
                renderer.setProjectionMatrix(spriteBatch.getProjectionMatrix());
                stage.getViewport().update(width, height, true);
        }

        @Override
        public void dispose () {
                spriteBatch.dispose();
                renderer.dispose();
                font.dispose();

                // Restore predefined colors
                Colors.reset();
        }
}
","alignmentWidth
",textWidth,textWidth,rectangleWidth,textWidth,
"package com.google.inject.spi;

import com.google.inject.AbstractModule;
import com.google.inject.Asserts;
import com.google.inject.CreationException;
import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Key;
import com.google.inject.Provider;
import com.google.inject.Stage;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import junit.framework.TestCase;

public class ToolStageInjectorTest extends TestCase {

  @Override
  protected void setUp() throws Exception {
    Foo.s = null;
    Foo.sm = null;
  }

  public void testToolStageInjectorRestrictions() {
    Injector  [MASK]  = Guice.createInjector(Stage.TOOL);
    try {
       [MASK] .injectMembers(new Object());
      fail(""Non-SPI Injector methods must throw an exception in the TOOL stage."");
    } catch (UnsupportedOperationException expected) {
    }

    try {
       [MASK] .getInstance(Injector.class);
      fail(""Non-SPI Injector methods must throw an exception in the TOOL stage."");
    } catch (UnsupportedOperationException expected) {
    }

    try {
       [MASK] .getInstance(Key.get(Injector.class));
      fail(""Non-SPI Injector methods must throw an exception in the TOOL stage."");
    } catch (UnsupportedOperationException expected) {
    }

    try {
       [MASK] .getProvider(Injector.class);
      fail(""Non-SPI Injector methods must throw an exception in the TOOL stage."");
    } catch (UnsupportedOperationException expected) {
    }

    try {
       [MASK] .getProvider(Key.get(Injector.class));
      fail(""Non-SPI Injector methods must throw an exception in the TOOL stage."");
    } catch (UnsupportedOperationException expected) {
    }
  }

  public void testToolStageDoesntInjectInstances() {
    final Foo foo = new Foo();
    Guice.createInjector(
        Stage.TOOL,
        new AbstractModule() {
          @Override
          protected void configure() {
            requestStaticInjection(Foo.class);
            requestInjection(foo);
          }
        });
    assertNull(Foo.s);
    assertNull(Foo.sm);
    assertNull(foo.f);
    assertNull(foo.m);
  }

  public void testToolStageDoesntInjectProviders() {
    final Foo foo = new Foo();
    Guice.createInjector(
        Stage.TOOL,
        new AbstractModule() {
          @Override
          protected void configure() {
            requestStaticInjection(Foo.class);
            bind(Object.class).toProvider(foo);
          }
        });
    assertNull(Foo.s);
    assertNull(Foo.sm);
    assertNull(foo.f);
    assertNull(foo.m);
  }

  public void testToolStageWarnsOfMissingObjectGraph() {
    final Bar bar = new Bar();
    try {
      Guice.createInjector(
          Stage.TOOL,
          new AbstractModule() {
            @Override
            protected void configure() {
              requestStaticInjection(Bar.class);
              requestInjection(bar);
            }
          });
      fail(""expected exception"");
    } catch (CreationException expected) {
      Asserts.assertContains(
          expected.toString(),
          ""No implementation for Collection<String> was bound."",
          ""No implementation for Map<String, String> was bound."",
          ""No implementation for List<String> was bound."",
          ""No implementation for Set<String> was bound."");
    }
  }

  public void testToolStageInjectsTooledMethods() {
    final Tooled tooled = new Tooled();
    Guice.createInjector(
        Stage.TOOL,
        new AbstractModule() {
          @Override
          protected void configure() {
            requestStaticInjection(Tooled.class);
            bind(Object.class).toProvider(tooled);
          }
        });
    assertNull(Tooled.s);
    assertNotNull(Tooled.sm);
    assertNull(tooled.f);
    assertNotNull(tooled.m);
  }

  private static class Bar {
    @SuppressWarnings(""unused"")
    @Inject
    private static List<String> list;

    @SuppressWarnings(""unused"")
    @Inject
    private Set<String> set;

    @SuppressWarnings(""unused"")
    @Inject
    void method(Collection<String> c) {}

    @SuppressWarnings(""unused"")
    @Inject
    static void staticMethod(Map<String, String> map) {}
  }

  private static class Foo implements Provider<Object> {
    @Inject private static S s;
    @Inject private F f;
    private M m;

    @SuppressWarnings(""unused"")
    @Inject
    void method(M m) {
      this.m = m;
    }

    private static SM sm;

    @SuppressWarnings(""unused"")
    @Inject
    static void staticMethod(SM sm) {
      Tooled.sm = sm;
    }

    @Override
    public Object get() {
      return null;
    }
  }

  private static class Tooled implements Provider<Object> {
    @Inject private static S s;
    @Inject private F f;
    private M m;

    @Toolable
    @SuppressWarnings(""unused"")
    @Inject
    void method(M m) {
      this.m = m;
    }

    private static SM sm;

    @Toolable
    @SuppressWarnings(""unused"")
    @Inject
    static void staticMethod(SM sm) {
      Tooled.sm = sm;
    }

    @Override
    public Object get() {
      return null;
    }
  }

  private static class S {}

  private static class F {}

  private static class M {}

  private static class SM {}
}
","injector
",inider,injector,injector,injector,
"
package org.apache.dubbo.metadata.report.support;

import org.apache.dubbo.common.URL;
import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
import org.apache.dubbo.common.logger.LoggerFactory;
import org.apache.dubbo.common.utils.CollectionUtils;
import org.apache.dubbo.common.utils.ConfigUtils;
import org.apache.dubbo.common.utils.JsonUtils;
import org.apache.dubbo.common.utils.NamedThreadFactory;
import org.apache.dubbo.metadata.definition.model.FullServiceDefinition;
import org.apache.dubbo.metadata.definition.model.ServiceDefinition;
import org.apache.dubbo.metadata.report.MetadataReport;
import org.apache.dubbo.metadata.report.identifier.KeyTypeEnum;
import org.apache.dubbo.metadata.report.identifier.MetadataIdentifier;
import org.apache.dubbo.metadata.report.identifier.ServiceMetadataIdentifier;
import org.apache.dubbo.metadata.report.identifier.SubscriberMetadataIdentifier;
import org.apache.dubbo.metrics.event.MetricsEventBus;
import org.apache.dubbo.metrics.metadata.event.MetadataEvent;
import org.apache.dubbo.rpc.model.ApplicationModel;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import static org.apache.dubbo.common.constants.CommonConstants.CONSUMER_SIDE;
import static org.apache.dubbo.common.constants.CommonConstants.CYCLE_REPORT_KEY;
import static org.apache.dubbo.common.constants.CommonConstants.FILE_KEY;
import static org.apache.dubbo.common.constants.CommonConstants.PROVIDER_SIDE;
import static org.apache.dubbo.common.constants.CommonConstants.REGISTRY_LOCAL_FILE_CACHE_ENABLED;
import static org.apache.dubbo.common.constants.CommonConstants.REPORT_DEFINITION_KEY;
import static org.apache.dubbo.common.constants.CommonConstants.REPORT_METADATA_KEY;
import static org.apache.dubbo.common.constants.CommonConstants.RETRY_PERIOD_KEY;
import static org.apache.dubbo.common.constants.CommonConstants.RETRY_TIMES_KEY;
import static org.apache.dubbo.common.constants.CommonConstants.SYNC_REPORT_KEY;
import static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_UNEXPECTED_EXCEPTION;
import static org.apache.dubbo.common.constants.LoggerCodeConstants.PROXY_FAILED_EXPORT_SERVICE;
import static org.apache.dubbo.common.utils.StringUtils.replace;
import static org.apache.dubbo.metadata.report.support.Constants.CACHE;
import static org.apache.dubbo.metadata.report.support.Constants.DEFAULT_METADATA_REPORT_CYCLE_REPORT;
import static org.apache.dubbo.metadata.report.support.Constants.DEFAULT_METADATA_REPORT_RETRY_PERIOD;
import static org.apache.dubbo.metadata.report.support.Constants.DEFAULT_METADATA_REPORT_RETRY_TIMES;
import static org.apache.dubbo.metadata.report.support.Constants.DUBBO_METADATA;
import static org.apache.dubbo.metadata.report.support.Constants.USER_HOME;

public abstract class AbstractMetadataReport implements MetadataReport {

    protected final static String DEFAULT_ROOT = ""dubbo"";

    private static final int ONE_DAY_IN_MILLISECONDS = 60 * 24 * 60 * 1000;
    private static final int FOUR_HOURS_IN_MILLISECONDS = 60 * 4 * 60 * 1000;
    // Log output
    protected final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(getClass());

    // Local disk cache, where the special key value.registries records the list of metadata centers, and the others are the list of notified service providers
    final Properties properties = new Properties();
    private final ExecutorService reportCacheExecutor = Executors.newFixedThreadPool(1, new NamedThreadFactory(""DubboSaveMetadataReport"", true));
    final Map<MetadataIdentifier, Object> allMetadataReports = new ConcurrentHashMap<>(4);

    private final AtomicLong lastCacheChanged = new AtomicLong();
    final Map<MetadataIdentifier, Object> failedReports = new ConcurrentHashMap<>(4);
    private URL reportURL;
    boolean syncReport;
    // Local disk cache file
    File file;
    private AtomicBoolean initialized = new AtomicBoolean(false);
    public MetadataReportRetry metadataReportRetry;
    private ScheduledExecutorService reportTimerScheduler;

    private final boolean reportMetadata;
    private final boolean reportDefinition;
    protected ApplicationModel applicationModel;

    public AbstractMetadataReport(URL reportServerURL) {
        setUrl(reportServerURL);
        applicationModel = reportServerURL.getOrDefaultApplicationModel();

        boolean localCacheEnabled = reportServerURL.getParameter(REGISTRY_LOCAL_FILE_CACHE_ENABLED, true);
        // Start file save timer
        String defaultFilename = System.getProperty(USER_HOME) + DUBBO_METADATA +
            reportServerURL.getApplication() + ""-"" +
            replace(reportServerURL.getAddress(), "":"", ""-"") + CACHE;
        String filename = reportServerURL.getParameter(FILE_KEY, defaultFilename);
        File file = null;
        if (localCacheEnabled && ConfigUtils.isNotEmpty(filename)) {
            file = new File(filename);
            if (!file.exists() && file.getParentFile() != null && !file.getParentFile().exists()) {
                if (!file.getParentFile().mkdirs()) {
                    throw new IllegalArgumentException(""Invalid service store file "" + file + "", cause: Failed to create directory "" + file.getParentFile() + ""!"");
                }
            }
            // if this file exists, firstly delete it.
            if (!initialized.getAndSet(true) && file.exists()) {
                file.delete();
            }
        }
        this.file = file;
        loadProperties();
        syncReport = reportServerURL.getParameter(SYNC_REPORT_KEY, false);
        metadataReportRetry = new MetadataReportRetry(reportServerURL.getParameter(RETRY_TIMES_KEY, DEFAULT_METADATA_REPORT_RETRY_TIMES),
            reportServerURL.getParameter(RETRY_PERIOD_KEY, DEFAULT_METADATA_REPORT_RETRY_PERIOD));
        // cycle report the data switch
        if (reportServerURL.getParameter(CYCLE_REPORT_KEY, DEFAULT_METADATA_REPORT_CYCLE_REPORT)) {
            reportTimerScheduler = Executors.newSingleThreadScheduledExecutor(new NamedThreadFactory(""DubboMetadataReportTimer"", true));
            reportTimerScheduler.scheduleAtFixedRate(this::publishAll, calculateStartTime(), ONE_DAY_IN_MILLISECONDS, TimeUnit.MILLISECONDS);
        }

        this.reportMetadata = reportServerURL.getParameter(REPORT_METADATA_KEY, false);
        this.reportDefinition = reportServerURL.getParameter(REPORT_DEFINITION_KEY, true);
    }

    public URL getUrl() {
        return reportURL;
    }

    protected void setUrl(URL url) {
        if (url == null) {
            throw new IllegalArgumentException(""metadataReport url == null"");
        }
        this.reportURL = url;
    }

    private void doSaveProperties(long version) {
        if (version < lastCacheChanged.get()) {
            return;
        }
        if (file == null) {
            return;
        }
        // Save
        try {
            File lockfile = new File(file.getAbsolutePath() + "".lock"");
            if (!lockfile.exists()) {
                lockfile.createNewFile();
            }
            try (RandomAccessFile raf = new RandomAccessFile(lockfile, ""rw"");
                 FileChannel channel = raf.getChannel()) {
                FileLock lock = channel.tryLock();
                if (lock == null) {
                    throw new IOException(""Can not lock the metadataReport cache file "" + file.getAbsolutePath() + "", ignore and retry later, maybe multi java process use the file, please config: dubbo.metadata.file=xxx.properties"");
                }
                // Save
                try {
                    if (!file.exists()) {
                        file.createNewFile();
                    }

                    Properties tmpProperties;
                    if (!syncReport) {
                        // When syncReport = false, properties.setProperty and properties.store are called from the same
                        // thread(reportCacheExecutor), so deep copy is not required
                        tmpProperties = properties;
                    } else {
                        // Using store method and setProperty method of the this.properties will cause lock contention
                        // under multi-threading, so deep copy a new container
                        tmpProperties = new Properties();
                        Set<Map.Entry<Object, Object>> entries = properties.entrySet();
                        for (Map.Entry<Object, Object> entry : entries) {
                            tmpProperties.setProperty((String) entry.getKey(), (String) entry.getValue());
                        }
                    }

                    try (FileOutputStream outputFile = new FileOutputStream(file)) {
                        tmpProperties.store(outputFile, ""Dubbo metadataReport Cache"");
                    }
                } finally {
                    lock.release();
                }
            }
        } catch (Throwable e) {
            if (version < lastCacheChanged.get()) {
                return;
            } else {
                reportCacheExecutor.execute(new SaveProperties(lastCacheChanged.incrementAndGet()));
            }
            logger.warn(COMMON_UNEXPECTED_EXCEPTION, """", """", ""Failed to save service store file, cause: "" + e.getMessage(), e);
        }
    }

    void loadProperties() {
        if (file != null && file.exists()) {
            try (InputStream in = new FileInputStream(file)) {
                properties.load(in);
                if (logger.isInfoEnabled()) {
                    logger.info(""Load service store file "" + file + "", data: "" + properties);
                }
            } catch (Throwable e) {
                logger.warn(COMMON_UNEXPECTED_EXCEPTION, """", """", ""Failed to load service store file"" + file, e);
            }
        }
    }

    private void saveProperties(MetadataIdentifier metadataIdentifier, String value, boolean add, boolean sync) {
        if (file == null) {
            return;
        }

        try {
            if (add) {
                properties.setProperty(metadataIdentifier.getUniqueKey(KeyTypeEnum.UNIQUE_KEY), value);
            } else {
                properties.remove(metadataIdentifier.getUniqueKey(KeyTypeEnum.UNIQUE_KEY));
            }
            long version = lastCacheChanged.incrementAndGet();
            if (sync) {
                new SaveProperties(version).run();
            } else {
                reportCacheExecutor.execute(new SaveProperties(version));
            }

        } catch (Throwable t) {
            logger.warn(COMMON_UNEXPECTED_EXCEPTION, """", """", t.getMessage(), t);
        }
    }

    @Override
    public String toString() {
        return getUrl().toString();
    }

    private class SaveProperties implements Runnable {
        private long version;

        private SaveProperties(long version) {
            this.version = version;
        }

        @Override
        public void run() {
            doSaveProperties(version);
        }
    }

    @Override
    public void storeProviderMetadata(MetadataIdentifier providerMetadataIdentifier, ServiceDefinition serviceDefinition) {
        if (syncReport) {
            storeProviderMetadataTask(providerMetadataIdentifier, serviceDefinition);
        } else {
            reportCacheExecutor.execute(() -> storeProviderMetadataTask(providerMetadataIdentifier, serviceDefinition));
        }
    }

    private void storeProviderMetadataTask(MetadataIdentifier providerMetadataIdentifier, ServiceDefinition serviceDefinition) {

        MetadataEvent metadataEvent = MetadataEvent.toServiceSubscribeEvent(applicationModel, providerMetadataIdentifier.getUniqueServiceName());
        MetricsEventBus.post(metadataEvent, () ->
            {
                boolean result = true;
                try {
                    if (logger.isInfoEnabled()) {
                        logger.info(""store provider metadata. Identifier : "" + providerMetadataIdentifier + ""; definition: "" + serviceDefinition);
                    }
                    allMetadataReports.put(providerMetadataIdentifier, serviceDefinition);
                    failedReports.remove(providerMetadataIdentifier);
                    String data = JsonUtils.toJson(serviceDefinition);
                    doStoreProviderMetadata(providerMetadataIdentifier, data);
                    saveProperties(providerMetadataIdentifier, data, true, !syncReport);
                } catch (Exception e) {
                    // retry again. If failed again, throw exception.
                    failedReports.put(providerMetadataIdentifier, serviceDefinition);
                    metadataReportRetry.startRetryTask();
                    logger.error(PROXY_FAILED_EXPORT_SERVICE, """", """", ""Failed to put provider metadata "" + providerMetadataIdentifier + "" in  "" + serviceDefinition + "", cause: "" + e.getMessage(), e);
                    result = false;
                }
                return result;
            }, aBoolean -> aBoolean
        );

    }

    @Override
    public void storeConsumerMetadata(MetadataIdentifier consumerMetadataIdentifier, Map<String, String> serviceParameterMap) {
        if (syncReport) {
            storeConsumerMetadataTask(consumerMetadataIdentifier, serviceParameterMap);
        } else {
            reportCacheExecutor.execute(() -> storeConsumerMetadataTask(consumerMetadataIdentifier, serviceParameterMap));
        }
    }

    protected void storeConsumerMetadataTask(MetadataIdentifier consumerMetadataIdentifier, Map<String, String> serviceParameterMap) {
        try {
            if (logger.isInfoEnabled()) {
                logger.info(""store consumer metadata. Identifier : "" + consumerMetadataIdentifier + ""; definition: "" + serviceParameterMap);
            }
            allMetadataReports.put(consumerMetadataIdentifier, serviceParameterMap);
            failedReports.remove(consumerMetadataIdentifier);

            String data = JsonUtils.toJson(serviceParameterMap);
            doStoreConsumerMetadata(consumerMetadataIdentifier, data);
            saveProperties(consumerMetadataIdentifier, data, true, !syncReport);
        } catch (Exception e) {
            // retry again. If failed again, throw exception.
            failedReports.put(consumerMetadataIdentifier, serviceParameterMap);
            metadataReportRetry.startRetryTask();
            logger.error(PROXY_FAILED_EXPORT_SERVICE, """", """", ""Failed to put consumer metadata "" + consumerMetadataIdentifier + "";  "" + serviceParameterMap + "", cause: "" + e.getMessage(), e);
        }
    }

    @Override
    public void destroy() {
        if (reportCacheExecutor != null) {
            reportCacheExecutor.shutdown();
        }
        if (reportTimerScheduler != null) {
            reportTimerScheduler.shutdown();
        }
        if (metadataReportRetry != null) {
            metadataReportRetry.destroy();
            metadataReportRetry = null;
        }
    }

    @Override
    public void saveServiceMetadata(ServiceMetadataIdentifier metadataIdentifier, URL url) {
        if (syncReport) {
            doSaveMetadata(metadataIdentifier, url);
        } else {
            reportCacheExecutor.execute(() -> doSaveMetadata(metadataIdentifier, url));
        }
    }

    @Override
    public void removeServiceMetadata(ServiceMetadataIdentifier metadataIdentifier) {
        if (syncReport) {
            doRemoveMetadata(metadataIdentifier);
        } else {
            reportCacheExecutor.execute(() -> doRemoveMetadata(metadataIdentifier));
        }
    }

    @Override
    public List<String> getExportedURLs(ServiceMetadataIdentifier metadataIdentifier) {
        // TODO, fallback to local cache
        return doGetExportedURLs(metadataIdentifier);
    }

    @Override
    public void saveSubscribedData(SubscriberMetadataIdentifier subscriberMetadataIdentifier, Set<String> urls) {
        if (syncReport) {
            doSaveSubscriberData(subscriberMetadataIdentifier, JsonUtils.toJson(urls));
        } else {
            reportCacheExecutor.execute(() -> doSaveSubscriberData(subscriberMetadataIdentifier, JsonUtils.toJson(urls)));
        }
    }


    @Override
    public List<String> getSubscribedURLs(SubscriberMetadataIdentifier subscriberMetadataIdentifier) {
        String content = doGetSubscribedURLs(subscriberMetadataIdentifier);
        return JsonUtils.toJavaList(content, String.class);
    }

    String getProtocol(URL url) {
        String protocol = url.getSide();
        protocol = protocol == null ? url.getProtocol() : protocol;
        return protocol;
    }

    /**
     * @return if need to continue
     */
    public boolean retry() {
        return doHandleMetadataCollection(failedReports);
    }

    @Override
    public boolean shouldReportDefinition() {
        return reportDefinition;
    }

    @Override
    public boolean shouldReportMetadata() {
        return reportMetadata;
    }

    private boolean doHandleMetadataCollection(Map<MetadataIdentifier, Object> metadataMap) {
        if (metadataMap.isEmpty()) {
            return true;
        }
        Iterator<Map.Entry<MetadataIdentifier, Object>> iterable = metadataMap.entrySet().iterator();
        while (iterable.hasNext()) {
            Map.Entry<MetadataIdentifier, Object> item = iterable.next();
            if (PROVIDER_SIDE.equals(item.getKey().getSide())) {
                this.storeProviderMetadata(item.getKey(), (FullServiceDefinition) item.getValue());
            } else if (CONSUMER_SIDE.equals(item.getKey().getSide())) {
                this.storeConsumerMetadata(item.getKey(), (Map) item.getValue());
            }

        }
        return false;
    }

    /**
     * not private. just for unittest.
     */
    void publishAll() {
        logger.info(""start to publish all metadata."");
        this.doHandleMetadataCollection(allMetadataReports);
    }

    /**
     * between 2:00 am to 6:00 am, the time is random.
     *
     * @return
     */
    long calculateStartTime() {
        Calendar calendar = Calendar.getInstance();
        long nowMill = calendar.getTimeInMillis();
        calendar.set(Calendar.HOUR_OF_DAY, 0);
        calendar.set(Calendar.MINUTE, 0);
        calendar.set(Calendar.SECOND, 0);
        calendar.set(Calendar.MILLISECOND, 0);
        long  [MASK]  = calendar.getTimeInMillis() + ONE_DAY_IN_MILLISECONDS - nowMill;
        return  [MASK]  + (FOUR_HOURS_IN_MILLISECONDS / 2) + ThreadLocalRandom.current().nextInt(FOUR_HOURS_IN_MILLISECONDS);
    }

    class MetadataReportRetry {
        protected final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(getClass());

        final ScheduledExecutorService retryExecutor = Executors.newScheduledThreadPool(0, new NamedThreadFactory(""DubboMetadataReportRetryTimer"", true));
        volatile ScheduledFuture retryScheduledFuture;
        final AtomicInteger retryCounter = new AtomicInteger(0);
        // retry task schedule period
        long retryPeriod;
        // if no failed report, wait how many times to run retry task.
        int retryTimesIfNonFail = 600;

        int retryLimit;

        public MetadataReportRetry(int retryTimes, int retryPeriod) {
            this.retryPeriod = retryPeriod;
            this.retryLimit = retryTimes;
        }

        void startRetryTask() {
            if (retryScheduledFuture == null) {
                synchronized (retryCounter) {
                    if (retryScheduledFuture == null) {
                        retryScheduledFuture = retryExecutor.scheduleWithFixedDelay(() -> {
                            // Check and connect to the metadata
                            try {
                                int times = retryCounter.incrementAndGet();
                                logger.info(""start to retry task for metadata report. retry times:"" + times);
                                if (retry() && times > retryTimesIfNonFail) {
                                    cancelRetryTask();
                                }
                                if (times > retryLimit) {
                                    cancelRetryTask();
                                }
                            } catch (Throwable t) { // Defensive fault tolerance
                                logger.error(COMMON_UNEXPECTED_EXCEPTION, """", """", ""Unexpected error occur at failed retry, cause: "" + t.getMessage(), t);
                            }
                        }, 500, retryPeriod, TimeUnit.MILLISECONDS);
                    }
                }
            }
        }

        void cancelRetryTask() {
            if (retryScheduledFuture != null) {
                retryScheduledFuture.cancel(false);
            }
            retryExecutor.shutdown();
        }

        void destroy() {
            cancelRetryTask();
        }

        /**
         * @deprecated only for test
         */
        @Deprecated
        ScheduledExecutorService getRetryExecutor() {
            return retryExecutor;
        }
    }

    private void doSaveSubscriberData(SubscriberMetadataIdentifier subscriberMetadataIdentifier, List<String> urls) {
        if (CollectionUtils.isEmpty(urls)) {
            return;
        }
        List<String> encodedUrlList = new ArrayList<>(urls.size());
        for (String url : urls) {
            encodedUrlList.add(URL.encode(url));
        }
        doSaveSubscriberData(subscriberMetadataIdentifier, encodedUrlList);
    }

    protected abstract void doStoreProviderMetadata(MetadataIdentifier providerMetadataIdentifier, String serviceDefinitions);

    protected abstract void doStoreConsumerMetadata(MetadataIdentifier consumerMetadataIdentifier, String serviceParameterString);

    protected abstract void doSaveMetadata(ServiceMetadataIdentifier metadataIdentifier, URL url);

    protected abstract void doRemoveMetadata(ServiceMetadataIdentifier metadataIdentifier);

    protected abstract List<String> doGetExportedURLs(ServiceMetadataIdentifier metadataIdentifier);

    protected abstract void doSaveSubscriberData(SubscriberMetadataIdentifier subscriberMetadataIdentifier, String urlListStr);

    protected abstract String doGetSubscribedURLs(SubscriberMetadataIdentifier subscriberMetadataIdentifier);

    /**
     * @deprecated only for unit test
     */
    @Deprecated
    protected ExecutorService getReportCacheExecutor() {
        return reportCacheExecutor;
    }

    /**
     * @deprecated only for unit test
     */
    @Deprecated
    protected MetadataReportRetry getMetadataReportRetry() {
        return metadataReportRetry;
    }
}
","subtract
",now,totalInMillis,currentTimeMillis,serviceDefinition,
"

package com.google.devtools.build.lib.runtime.commands;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.devtools.build.lib.analysis.ConfiguredTarget;
import com.google.devtools.build.lib.analysis.config.CoreOptions;
import com.google.devtools.build.lib.buildtool.BuildRequest;
import com.google.devtools.build.lib.buildtool.BuildRequestOptions;
import com.google.devtools.build.lib.buildtool.BuildResult;
import com.google.devtools.build.lib.buildtool.BuildTool;
import com.google.devtools.build.lib.buildtool.InstrumentationFilterSupport;
import com.google.devtools.build.lib.buildtool.OutputDirectoryLinksUtils;
import com.google.devtools.build.lib.buildtool.PathPrettyPrinter;
import com.google.devtools.build.lib.buildtool.buildevent.TestingCompleteEvent;
import com.google.devtools.build.lib.events.Event;
import com.google.devtools.build.lib.exec.ExecutionOptions;
import com.google.devtools.build.lib.exec.ExecutionOptions.TestOutputFormat;
import com.google.devtools.build.lib.runtime.AggregatingTestListener;
import com.google.devtools.build.lib.runtime.BlazeCommand;
import com.google.devtools.build.lib.runtime.BlazeCommandResult;
import com.google.devtools.build.lib.runtime.BlazeRuntime;
import com.google.devtools.build.lib.runtime.Command;
import com.google.devtools.build.lib.runtime.CommandEnvironment;
import com.google.devtools.build.lib.runtime.TerminalTestResultNotifier;
import com.google.devtools.build.lib.runtime.TerminalTestResultNotifier.TestSummaryOptions;
import com.google.devtools.build.lib.runtime.TestResultNotifier;
import com.google.devtools.build.lib.runtime.TestSummaryPrinter.TestLogPathFormatter;
import com.google.devtools.build.lib.runtime.UiOptions;
import com.google.devtools.build.lib.server.FailureDetails;
import com.google.devtools.build.lib.server.FailureDetails.FailureDetail;
import com.google.devtools.build.lib.server.FailureDetails.TestCommand.Code;
import com.google.devtools.build.lib.skyframe.AspectKeyCreator.AspectKey;
import com.google.devtools.build.lib.skyframe.ConfiguredTargetKey;
import com.google.devtools.build.lib.util.DetailedExitCode;
import com.google.devtools.build.lib.util.io.AnsiTerminalPrinter;
import com.google.devtools.build.lib.vfs.Path;
import com.google.devtools.common.options.OptionPriority.PriorityCategory;
import com.google.devtools.common.options.OptionsParser;
import com.google.devtools.common.options.OptionsParsingException;
import com.google.devtools.common.options.OptionsParsingResult;
import java.util.Collection;
import java.util.List;

/**
 * Handles the 'test' command on the Blaze command line.
 */
@Command(name = ""test"",
         builds = true,
         inherits = { BuildCommand.class },
         options = { TestSummaryOptions.class },
         shortDescription = ""Builds and runs the specified test targets."",
         help = ""resource:test.txt"",
         completion = ""label-test"",
         allowResidue = true)
public class TestCommand implements BlazeCommand {
  /** Returns the name of the command to ask the project file for. */
  // TODO(hdm): move into BlazeRuntime?  It feels odd to duplicate the annotation here.
  protected String commandName() {
    return ""test"";
  }

  @Override
  public void editOptions(OptionsParser optionsParser) {
    TestOutputFormat testOutput = optionsParser.getOptions(ExecutionOptions.class).testOutput;
    try {
      if (testOutput == ExecutionOptions.TestOutputFormat.STREAMED) {
        optionsParser.parse(
            PriorityCategory.SOFTWARE_REQUIREMENT,
            ""streamed output requires locally run tests, without sharding"",
            ImmutableList.of(""--test_sharding_strategy=disabled"", ""--test_strategy=exclusive""));
      }
    } catch (OptionsParsingException e) {
      throw new IllegalStateException(""Known options failed to parse"", e);
    }
  }

  @Override
  public BlazeCommandResult exec(CommandEnvironment env, OptionsParsingResult options) {
    TestOutputFormat testOutput = options.getOptions(ExecutionOptions.class).testOutput;
    if (testOutput == ExecutionOptions.TestOutputFormat.STREAMED) {
      env.getReporter().handle(Event.warn(
          ""Streamed test output requested. All tests will be run locally, without sharding, ""
          + ""one at a time""));
    }

    AnsiTerminalPrinter printer =
        new AnsiTerminalPrinter(
            env.getReporter().getOutErr().getOutputStream(),
            options.getOptions(UiOptions.class).useColor());

    // Initialize test handler.
    AggregatingTestListener testListener =
        new AggregatingTestListener(
            options.getOptions(TestSummaryOptions.class),
            options.getOptions(ExecutionOptions.class),
            env.getEventBus());

    env.getEventBus().register(testListener);
    return doTest(env, options, testListener, printer);
  }

  private BlazeCommandResult doTest(
      CommandEnvironment env,
      OptionsParsingResult options,
      AggregatingTestListener testListener,
      AnsiTerminalPrinter printer) {
    BlazeRuntime runtime = env.getRuntime();
    // Run simultaneous build and test.
    List<String> targets;
    try {
      targets = TargetPatternsHelper.readFrom(env, options);
    } catch (TargetPatternsHelper.TargetPatternsHelperException e) {
      env.getReporter().handle(Event.error(e.getMessage()));
      return BlazeCommandResult.failureDetail(e.getFailureDetail());
    }

    BuildRequest.Builder builder =
        BuildRequest.builder()
            .setCommandName(getClass().getAnnotation(Command.class).name())
            .setId(env.getCommandId())
            .setOptions(options)
            .setStartupOptions(runtime.getStartupOptionsProvider())
            .setOutErr(env.getReporter().getOutErr())
            .setTargets(targets)
            .setStartTimeMillis(env.getCommandStartTime())
            .setRunTests(true);
    if (options.getOptions(CoreOptions.class).collectCodeCoverage
        && !options.containsExplicitOption(
            InstrumentationFilterSupport.INSTRUMENTATION_FILTER_FLAG)) {
      builder.setNeedsInstrumentationFilter(true);
    }
    BuildRequest request = builder.build();

    BuildResult buildResult = new BuildTool(env).processRequest(request, null);

    Collection<ConfiguredTarget> testTargets = buildResult.getTestTargets();
    // TODO(bazel-team): don't handle isEmpty here or fix up a bunch of tests
    if (buildResult.getSuccessfulTargets() == null) {
      // This can happen if there were errors in the target parsing or loading phase
      // (original exitcode=BUILD_FAILURE) or if there weren't but --noanalyze was given
      // (original exitcode=SUCCESS).
      String message = ""Couldn't start the build. Unable to run tests"";
      env.getReporter().handle(Event.error(message));
      DetailedExitCode detailedExitCode =
          buildResult.getSuccess()
              ? DetailedExitCode.of(
                  FailureDetail.newBuilder()
                      .setMessage(message)
                      .setTestCommand(
                          FailureDetails.TestCommand.newBuilder().setCode(Code.TEST_WITH_NOANALYZE))
                      .build())
              : buildResult.getDetailedExitCode();
      env.getEventBus()
          .post(
              new TestingCompleteEvent(detailedExitCode.getExitCode(), buildResult.getStopTime()));
      return BlazeCommandResult.detailedExitCode(detailedExitCode);
    }
    // TODO(bazel-team): the check above shadows NO_TESTS_FOUND, but switching the conditions breaks
    // more tests
    if (testTargets.isEmpty()) {
      String message = ""No test targets were found, yet testing was requested"";
      env.getReporter().handle(Event.error(null, message));

      DetailedExitCode detailedExitCode =
          buildResult.getSuccess()
              ? DetailedExitCode.of(
                  FailureDetail.newBuilder()
                      .setMessage(message)
                      .setTestCommand(
                          FailureDetails.TestCommand.newBuilder().setCode(Code.NO_TEST_TARGETS))
                      .build())
              : buildResult.getDetailedExitCode();
      env.getEventBus()
          .post(new NoTestsFound(detailedExitCode.getExitCode(), buildResult.getStopTime()));
      return BlazeCommandResult.detailedExitCode(detailedExitCode);
    }

    DetailedExitCode testResults =
        analyzeTestResults(request, buildResult, testListener, options, env, printer);

    if (testResults.isSuccess() && !buildResult.getSuccess()) {
      // If all tests run successfully, test summary should include warning if
      // there were build errors not associated with the test targets.
      printer.printLn(AnsiTerminalPrinter.Mode.ERROR
          + ""All tests passed but there were other errors during the build.\n""
          + AnsiTerminalPrinter.Mode.DEFAULT);
    }

    DetailedExitCode detailedExitCode =
        DetailedExitCode.DetailedExitCodeComparator.chooseMoreImportantWithFirstIfTie(
            buildResult.getDetailedExitCode(), testResults);
    env.getEventBus()
        .post(new TestingCompleteEvent(detailedExitCode.getExitCode(), buildResult.getStopTime()));
    return BlazeCommandResult.detailedExitCode(detailedExitCode);
  }

  /**
   * Analyzes test results and prints summary information. Returns a {@link DetailedExitCode}
   * summarizing those test results.
   */
  private static DetailedExitCode analyzeTestResults(
      BuildRequest buildRequest,
      BuildResult buildResult,
      AggregatingTestListener listener,
      OptionsParsingResult options,
      CommandEnvironment env,
      AnsiTerminalPrinter printer) {
    ImmutableSet<ConfiguredTargetKey> validatedTargets;
    if (buildRequest.useValidationAspect()) {
      validatedTargets =
          buildResult.getSuccessfulAspects().stream()
              .filter(key -> BuildRequest.VALIDATION_ASPECT_NAME.equals(key.getAspectName()))
              .map(AspectKey::getBaseConfiguredTargetKey)
              .collect(ImmutableSet.toImmutableSet());
    } else {
      validatedTargets = null;
    }

    TestResultNotifier notifier = new TerminalTestResultNotifier(
        printer,
        makeTestLogPathFormatter(options, env),
        options);
    return listener.differentialAnalyzeAndReport(
        buildResult.getTestTargets(), buildResult.getSkippedTargets(), validatedTargets, notifier);
  }

  private static TestLogPathFormatter makeTestLogPathFormatter(
      OptionsParsingResult options,
      CommandEnvironment env) {
    BlazeRuntime runtime = env.getRuntime();
    TestSummaryOptions summaryOptions = options.getOptions(TestSummaryOptions.class);
    if (!summaryOptions.printRelativeTestLogPaths) {
      return Path::getPathString;
    }
    String  [MASK]  = runtime.getProductName();
    BuildRequestOptions requestOptions = env.getOptions().getOptions(BuildRequestOptions.class);
    // requestOptions.printWorkspaceInOutputPathsIfNeeded is antithetical with
    // summaryOptions.printRelativeTestLogPaths, so we completely ignore it.
    PathPrettyPrinter pathPrettyPrinter =
        OutputDirectoryLinksUtils.getPathPrettyPrinter(
            runtime.getRuleClassProvider().getSymlinkDefinitions(),
            requestOptions.getSymlinkPrefix( [MASK] ),
             [MASK] ,
            env.getWorkspace());
    return path -> pathPrettyPrinter.getPrettyPath(path.asFragment()).getPathString();
  }
}
","productName
",productName,productName,productName,productName,
"package com.github.scribejava.apis.examples;

import com.github.scribejava.core.builder.ServiceBuilder;
import com.github.scribejava.apis.GoogleApi20;
import com.github.scribejava.core.model.DeviceAuthorization;
import com.github.scribejava.core.model.OAuth2AccessToken;
import com.github.scribejava.core.model.OAuthRequest;
import com.github.scribejava.core.model.Response;
import com.github.scribejava.core.model.Verb;
import com.github.scribejava.core.oauth.OAuth20Service;
import java.io.IOException;
import java.util.Scanner;
import java.util.concurrent.ExecutionException;

public class Google20DeviceAuthorizationGrantExample {

    private static final String NETWORK_NAME = ""Google"";
    private static final String PROTECTED_RESOURCE_URL = ""https://www.googleapis.com/oauth2/v3/userinfo"";

    private Google20DeviceAuthorizationGrantExample() {
    }

    @SuppressWarnings(""PMD.SystemPrintln"")
    public static void main(String... args) throws IOException, InterruptedException, ExecutionException {
        // Replace these with your client id and secret
        final String clientId = ""your client id"";
        final String clientSecret = ""your_client_secret"";

        final OAuth20Service service = new ServiceBuilder(clientId)
                .debug()
                .apiSecret(clientSecret)
                .defaultScope(""profile"") // replace with desired scope
                .build(GoogleApi20.instance());
        final Scanner in = new Scanner(System.in, ""UTF-8"");

        System.out.println(""=== "" + NETWORK_NAME + ""'s OAuth Workflow ==="");
        System.out.println();

        System.out.println(""Requesting a set of verification codes..."");

        final DeviceAuthorization deviceAuthorization = service.getDeviceAuthorizationCodes();
        System.out.println(""Got the Device Authorization Codes!"");
        System.out.println(deviceAuthorization);

        System.out.println(""Now go and authorize ScribeJava. Visit: "" + deviceAuthorization.getVerificationUri()
                + "" and enter the code: "" + deviceAuthorization.getUserCode());
        if (deviceAuthorization.getVerificationUriComplete() != null) {
            System.out.println(""Or visit "" + deviceAuthorization.getVerificationUriComplete());
        }

        System.out.println(""Polling for an Access Token..."");
        final OAuth2AccessToken  [MASK]  = service.pollAccessTokenDeviceAuthorizationGrant(deviceAuthorization);

        System.out.println(""Got the Access Token!"");
        System.out.println(""(The raw response looks like this: "" +  [MASK] .getRawResponse() + ""')"");

        // Now let's go and ask for a protected resource!
        System.out.println(""Now we're going to access a protected resource..."");
        while (true) {
            System.out.println(""Paste fieldnames to fetch (leave empty to get profile, 'exit' to stop the example)"");
            System.out.print("">>"");
            final String query = in.nextLine();
            System.out.println();
            final String requestUrl;
            if (""exit"".equals(query)) {
                break;
            } else if (query == null || query.isEmpty()) {
                requestUrl = PROTECTED_RESOURCE_URL;
            } else {
                requestUrl = PROTECTED_RESOURCE_URL + ""?fields="" + query;
            }
            final OAuthRequest request = new OAuthRequest(Verb.GET, requestUrl);
            service.signRequest( [MASK] , request);
            System.out.println();
            try (Response response = service.execute(request)) {
                System.out.println(response.getCode());
                System.out.println(response.getBody());
            }
            System.out.println();
        }
    }
}
","accessToken
",oaTokenToken,accessToken,"accessToken
","accessToken
",
"

package com.google.j2objc.testing;

import com.google.j2objc.annotations.AutoreleasePool;
import com.google.j2objc.annotations.WeakOuter;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.Random;
import java.util.Set;
import junit.framework.Test;
import junit.runner.Version;
import org.junit.internal.TextListener;
import org.junit.runner.Description;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.junit.runner.notification.Failure;
import org.junit.runner.notification.RunListener;
import org.junit.runners.Suite;

/*-[
#include <objc/runtime.h>
]-*/

/**
 * Runs JUnit test classes.
 *
 * Provides a main() function that runs all JUnit tests linked into the executable.
 * The main() function accepts no arguments since Pulse unit tests are not designed to accept
 * arguments. Instead the code expects a file called ""JUnitTestRunner.properties"" to be include
 * as a resource.
 *
 * Any classes derived from {@link Test} (JUnit 3) or {@link Suite} (JUnit 4) are considered
 * JUnit tests. This behavior can be changed by overriding {@link #isJUnitTestClass},
 * {@link #isJUnit3TestClass} or {@link #isJUnit4TestClass}.
 *
 * @author iroth@google.com (Ian Roth)
 */
public class JUnitTestRunner {

  private static final String PROPERTIES_FILE_NAME = ""JUnitTestRunner.properties"";

  /**
   * Specifies the output format for tests.
   */
  public enum OutputFormat {
    JUNIT,            // JUnit style output.
    GTM_UNIT_TESTING  // Google Toolkit for Mac unit test output format.
  }

  /**
   * Specifies the sort order for tests.
   */
  public enum SortOrder {
    ALPHABETICAL,  // Sorted alphabetically
    RANDOM         // Sorted randomly (differs with each run)
  }

  /**
   * Specifies whether a pattern includes or excludes test classes.
   */
  public enum TestInclusion {
    RUN_TEST,  // Includes tests that exactly match the pattern
    INCLUDE,   // Includes test classes matching the pattern
    EXCLUDE    // Excludes test classes matching the pattern
  }

  private final PrintStream out;
  private final Set<String> testsToRun = new HashSet<>();
  private final Set<String> includePatterns = new HashSet<>();
  private final Set<String> excludePatterns = new HashSet<>();
  private final Map<String, String> nameMappings = new HashMap<>();
  private final Map<String, String> randomNames = new HashMap<>();
  private final Random random = new Random(System.currentTimeMillis());
  private OutputFormat outputFormat = OutputFormat.JUNIT;
  private SortOrder sortOrder = SortOrder.ALPHABETICAL;

  public JUnitTestRunner() {
    this(System.err);
  }

  public JUnitTestRunner(PrintStream out) {
    this.out = out;
  }

  public static int main(String[] args) {
    // Create JUnit test runner.
    PrintStream nsLogOut = new PrintStream(new NSLogOutputStream(), true);
    JUnitTestRunner runner = new JUnitTestRunner(nsLogOut);
    runner.loadPropertiesFromResource(PROPERTIES_FILE_NAME);
    return runner.run();
  }

  /**
   * Runs the test classes given in {@param classes}.
   * @returns Zero if all tests pass, non-zero otherwise.
   */
  public static int run(Class<?>[] classes, RunListener listener) {
    JUnitCore junitCore = new JUnitCore();
    junitCore.addListener(listener);
    boolean hasError = false;
    for (@AutoreleasePool Class<?> c : classes) {
      Result result = junitCore.run(c);
      hasError = hasError || !result.wasSuccessful();
    }
    return hasError ? 1 : 0;
  }

  /**
   * Runs the test classes that match settings in {@link #PROPERTIES_FILE_NAME}.
   * @returns Zero if all tests pass, non-zero otherwise.
   */
  public int run() {
    if (outputFormat == OutputFormat.GTM_UNIT_TESTING) {
      Thread.setDefaultUncaughtExceptionHandler(new GtmUncaughtExceptionHandler());
    }
    Set<Class<?>> classesSet = getTestClasses();
    Class<?>[] classes = classesSet.toArray(new Class<?>[classesSet.size()]);
    sortClasses(classes, sortOrder);
    RunListener listener = newRunListener(outputFormat);
    return run(classes, listener);
  }

  /**
   * Returns a new {@link RunListener} instance for the given {@param outputFormat}.
   */
  public RunListener newRunListener(OutputFormat outputFormat) {
    switch (outputFormat) {
      case JUNIT:
        out.println(""JUnit version "" + Version.id());
        return new TextListener(out);
      case GTM_UNIT_TESTING:
        return new GtmUnitTestingTextListener();
      default:
        throw new IllegalArgumentException(""outputFormat"");
    }
  }

  /**
   * Sorts the classes given in {@param classes} according to {@param sortOrder}.
   */
  public void sortClasses(Class<?>[] classes, final SortOrder sortOrder) {
    Arrays.sort(classes, new Comparator<Class<?>>() {
      @Override
      public int compare(Class<?> class1, Class<?> class2) {
        String name1 = getSortKey(class1, sortOrder);
        String name2 = getSortKey(class2, sortOrder);
        return name1.compareTo(name2);
      }
    });
  }

  private String replaceAll(String value) {
    for (Map.Entry<String, String> entry : nameMappings.entrySet()) {
      String pattern = entry.getKey();
      String replacement = entry.getValue();
      value = value.replaceAll(pattern, replacement);
    }
    return value;
  }

  private String getSortKey(Class<?> cls, SortOrder sortOrder) {
    String className = cls.getName();
    switch (sortOrder) {
      case ALPHABETICAL:
        return replaceAll(className);
      case RANDOM:
        String sortKey = randomNames.get(className);
        if (sortKey == null) {
          sortKey = Integer.toString(random.nextInt());
          randomNames.put(className, sortKey);
        }
        return sortKey;
      default:
        throw new IllegalArgumentException(""sortOrder"");
    }
  }

  /*-[
  // Returns true if |cls| conforms to the NSObject protocol.
  BOOL IsNSObjectClass(Class cls) {
    while (cls != nil) {
      if (class_conformsToProtocol(cls, @protocol(NSObject))) {
        return YES;
      }
      // class_conformsToProtocol() does not examine superclasses.
      cls = class_getSuperclass(cls);
    }
    return NO;
  }
  ]-*/

  /**
   * Returns the set of all loaded JUnit test classes.
   */
  private native Set<Class<?>> getAllTestClasses() /*-[
    int classCount = objc_getClassList(NULL, 0);
    Class *classes = (Class *)malloc(classCount * sizeof(Class));
    objc_getClassList(classes, classCount);
    id<JavaUtilSet> result = AUTORELEASE([[JavaUtilHashSet alloc] init]);
    for (int i = 0; i < classCount; i++) {
      @try {
        Class cls = classes[i];
        if (IsNSObjectClass(cls)) {
          IOSClass *javaClass = IOSClass_fromClass(cls);
          if ([self isJUnitTestClassWithIOSClass:javaClass]) {
            [result addWithId:javaClass];
          }
        }
      }
      @catch (NSException *e) {
        // Ignore any exceptions thrown by class initialization.
      }
    }
    free(classes);
    return result;
  ]-*/;

  /**
   * @return true if {@param cls} is either a JUnit 3 or JUnit 4 test.
   */
  protected boolean isJUnitTestClass(Class<?> cls) {
    return !Modifier.isAbstract(cls.getModifiers())
            && (isJUnit3TestClass(cls) || isJUnit4TestClass(cls));
  }

  /**
   * @return true if {@param cls} derives from {@link Test} and is not part of the
   * {@link junit.framework} package.
   */
  protected boolean isJUnit3TestClass(Class<?> cls) {
    if (Test.class.isAssignableFrom(cls)) {
      String packageName = getPackageName(cls);
      return !packageName.startsWith(""junit.framework"")
          && !packageName.startsWith(""junit.extensions"");
    }
    return false;
  }

  /** @return true if {@param cls} is {@link RunWith} annotated. */
  protected boolean isJUnit4TestClass(Class<?> cls) {
    return cls.getAnnotation(RunWith.class) != null;
  }

  /**
   * Returns the name of a class's package or """" for the default package
   * or (for Foundation classes) no package object.
   */
  private String getPackageName(Class<?> cls) {
    Package pkg = cls.getPackage();
    return pkg != null ? pkg.getName() : """";
  }

  /**
   * Returns the set of test classes that match settings in {@link #PROPERTIES_FILE_NAME}.
   */
  private Set<Class<?>> getTestClasses() {
    Set<Class<?>> testClasses = new HashSet<>();

    for (String testName : testsToRun) {
      try {
        testClasses.add(Class.forName(testName));
      } catch (ClassNotFoundException e) {
        throw new AssertionError(e);
      }
    }

    if (!includePatterns.isEmpty()) {
      for (Class<?> testClass : getAllTestClasses()) {
        for (String includePattern : includePatterns) {
          if (matchesPattern(testClass, includePattern)) {
            testClasses.add(testClass);
            break;
          }
        }
      }
    }

    if (testsToRun.isEmpty() && includePatterns.isEmpty()) {
      // Include all tests if no include patterns specified.
      testClasses.addAll(getAllTestClasses());
    }

    // Search included tests for tests to exclude.
    Iterator<Class<?>> testClassesIterator = testClasses.iterator();
    while (testClassesIterator.hasNext()) {
      Class<?> testClass = testClassesIterator.next();
      for (String excludePattern : excludePatterns) {
        if (matchesPattern(testClass, excludePattern)) {
          testClassesIterator.remove();
          break;
        }
      }
    }

    return testClasses;
  }

  private boolean matchesPattern(Class<?> testClass, String pattern) {
    return testClass.getCanonicalName().contains(pattern);
  }

  private void loadProperties(InputStream stream) {
    Properties properties = new Properties();
    try {
      properties.load(stream);
    } catch (IOException e) {
      onError(e);
    }
    Set<String> propertyNames = properties.stringPropertyNames();
    for (String key : propertyNames) {
      String value = properties.getProperty(key);
      try {
        if (key.equals(""outputFormat"")) {
          outputFormat = OutputFormat.valueOf(value);
        } else if (key.equals(""sortOrder"")) {
          sortOrder = SortOrder.valueOf(value);
        } else if (value.equals(TestInclusion.RUN_TEST.name())) {
          testsToRun.add(key);
        } else if (value.equals(TestInclusion.INCLUDE.name())) {
          includePatterns.add(key);
        } else if (value.equals(TestInclusion.EXCLUDE.name())) {
          excludePatterns.add(key);
        } else {
          nameMappings.put(key, value);
        }
      } catch (IllegalArgumentException e) {
        onError(e);
      }
    }
  }

  private void loadPropertiesFromResource(String resourcePath) {
    try {
      InputStream stream = ClassLoader.getSystemClassLoader().getResourceAsStream(resourcePath);
      if (stream != null) {
        loadProperties(stream);
      } else {
        throw new IOException(String.format(""Resource not found: %s"", resourcePath));
      }
    } catch (Exception e) {
      onError(e);
    }
  }

  private void onError(Exception e) {
    e.printStackTrace(out);
  }

  private class GtmUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {

    @Override
    public void uncaughtException(Thread t, Throwable e) {
      out.print(""Exception in thread \"""" + t.getName() + ""\"" "");
      e.printStackTrace(out);
      out.println(""** TEST FAILED **"");
    }
  }

  @WeakOuter
  private class GtmUnitTestingTextListener extends RunListener {

    private int numTests = 0;
    private int numFailures = 0;
    private final int numUnexpected = 0; // Never changes, but required in output.

    private Failure testFailure;
    private double testStartTime;

    @Override
    public void testRunFinished(Result result) throws Exception {
      printf(""Executed %d tests, with %d failures (%d unexpected)\n"", numTests, numFailures,
          numUnexpected);
    }

    @Override
    public void testStarted(Description description) throws Exception {
      numTests++;
      testFailure = null;
      testStartTime = System.currentTimeMillis();
      printf(""Test Case '-[%s]' started.\n"", parseDescription(description));
    }

    @Override
    public void testFinished(Description description) throws Exception {
      double testEndTime = System.currentTimeMillis();
      double  [MASK]  = 0.001 * (testEndTime - testStartTime);
      String statusMessage = ""passed"";
      if (testFailure != null) {
        statusMessage = ""failed"";
        out.print(testFailure.getTrace());
      }
      printf(""Test Case '-[%s]' %s (%.3f seconds).\n\n"", parseDescription(description),
          statusMessage,  [MASK] );
    }

    @Override
    public void testFailure(Failure failure) throws Exception {
      testFailure = failure;
      numFailures++;
    }

    private String parseDescription(Description description) {
      String displayName = description.getDisplayName();
      int p1 = displayName.indexOf(""("");
      int p2 = displayName.indexOf("")"");
      if (p1 < 0 || p2 < 0 || p2 <= p1) {
        return displayName;
      }
      String methodName = displayName.substring(0, p1);
      String className = displayName.substring(p1 + 1, p2);
      return replaceAll(className) + "" "" + methodName;
    }

    private void printf(String format, Object... args) {
      // Avoid using printf() or println() because they will be flushed in pieces and cause
      // interleaving with logger messages.
      out.print(String.format(format, args));
    }
  }

  /**
   * Logs test runner output using NSLog().
   */
  private static class NSLogOutputStream extends OutputStream {
    private final ByteArrayOutputStream buffer = new ByteArrayOutputStream();

    @Override
    public void write(int b) throws IOException {
      buffer.write(b);
    }

    @Override
    public void write(byte[] b, int off, int len) throws IOException {
      buffer.write(b, off, len);
    }

    @Override
    public native void flush() /*-[
      NSString *s = [buffer_ toStringWithNSString:@""UTF-8""];
      if (s.length) {
        NSLog(@""%@"", s);
      }
      [buffer_ reset];
    ]-*/;
  }
}
","elapsedSeconds
",timeTime,time,testDuration,testDuration,
"package com.alibaba.json.bvt.issue_3400;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.annotation.JSONCreator;
import com.alibaba.fastjson.annotation.JSONType;
import junit.framework.TestCase;
import org.springframework.core.io.FileSystemResource;

public class Issue3436 extends TestCase {
    public void test_for_issue() throws Exception {
        JSON.addMixInAnnotations(FileSystemResource.class, FileSystemResourceMixedIn.class);

        FileSystemResource  [MASK]  = new FileSystemResource(""E:\\my-code\\test\\test-fastjson.txt"");

        String json = JSON.toJSONString( [MASK] );
        assertEquals(""{\""path\"":\""E:/my-code/test/test-fastjson.txt\""}"", json);

        FileSystemResource fsr1 = JSON.parseObject(json, FileSystemResource.class);
        assertEquals( [MASK] .getPath(), fsr1.getPath());
        System.out.println(""file size after Serialize"" +  [MASK] .getFile().length());
    }

    @JSONType(asm = false, includes = ""path"")
    public static class FileSystemResourceMixedIn {
        @JSONCreator
        public FileSystemResourceMixedIn(String path) {

        }
    }
}
","fileSystemResource
",source,fsRes,fileSystemResource,resource,
"package jadx.tests.integration.others;

import java.util.Arrays;
import java.util.Collections;

import org.junit.jupiter.api.Test;

import jadx.api.data.ICodeComment;
import jadx.api.data.IJavaCodeRef;
import jadx.api.data.IJavaNodeRef.RefType;
import jadx.api.data.impl.JadxCodeComment;
import jadx.api.data.impl.JadxCodeData;
import jadx.api.data.impl.JadxCodeRef;
import jadx.api.data.impl.JadxNodeRef;
import jadx.core.dex.nodes.ClassNode;
import jadx.tests.api.IntegrationTest;

import static jadx.tests.api.utils.assertj.JadxAssertions.assertThat;

public class TestCodeComments extends IntegrationTest {

	@SuppressWarnings(""FieldCanBeLocal"")
	public static class TestCls {
		private int intField = 5;

		public static class A {
		}

		public int test() {
			System.out.println(""Hello"");
			System.out.println(""comment"");
			return intField;
		}
	}

	@Test
	public void test() {
		String baseClsId = TestCls.class.getName();
		ICodeComment clsComment = new JadxCodeComment(JadxNodeRef.forCls(baseClsId), ""class comment"");
		ICodeComment innerClsComment = new JadxCodeComment(JadxNodeRef.forCls(baseClsId + ""$A""), ""inner class comment"");
		ICodeComment fldComment = new JadxCodeComment(new JadxNodeRef(RefType.FIELD, baseClsId, ""intField:I""), ""field comment"");
		JadxNodeRef mthRef = new JadxNodeRef(RefType.METHOD, baseClsId, ""test()I"");
		ICodeComment mthComment = new JadxCodeComment(mthRef, ""method comment"");
		IJavaCodeRef insnRef = JadxCodeRef.forInsn(isJavaInput() ? 13 : 11);
		ICodeComment insnComment = new JadxCodeComment(mthRef, insnRef, ""insn comment"");

		JadxCodeData  [MASK]  = new JadxCodeData();
		getArgs().setCodeData( [MASK] );
		 [MASK] .setComments(Arrays.asList(clsComment, innerClsComment, fldComment, mthComment, insnComment));

		ClassNode cls = getClassNode(TestCls.class);
		assertThat(cls)
				.decompile()
				.checkCodeOffsets()
				.code()
				.containsOne(""// class comment"")
				.containsOne(""// inner class comment"")
				.containsOne(""// field comment"")
				.containsOne(""// method comment"")
				.containsOne(""System.out.println(\""comment\""); // insn comment"");

		String code = cls.getCode().getCodeStr();
		assertThat(cls)
				.reloadCode(this)
				.isEqualTo(code);

		ICodeComment updInsnComment = new JadxCodeComment(mthRef, insnRef, ""updated insn comment"");
		 [MASK] .setComments(Collections.singletonList(updInsnComment));
		jadxDecompiler.reloadCodeData();
		assertThat(cls)
				.reloadCode(this)
				.containsOne(""System.out.println(\""comment\""); // updated insn comment"")
				.doesNotContain(""class comment"")
				.containsOne("" comment"");
	}
}
","codeData
",codeData,codeData,"codeData
","codeData
",
"
/** 
 * Port From:   JDK 1.4b1 : java.text.Format.IntlTestDecimalFormatAPI
 * Source File: java/text/format/IntlTestDecimalFormatAPI.java
 **/
 
/*
    @test 1.4 98/03/06
    @summary test International Decimal Format API
*/

package android.icu.dev.test.format;

import java.text.FieldPosition;
import java.text.Format;
import java.text.ParseException;
import java.text.ParsePosition;
import java.util.Locale;

import org.junit.Test;

import android.icu.math.BigDecimal;
import android.icu.math.MathContext;
import android.icu.text.DecimalFormat;
import android.icu.text.DecimalFormatSymbols;
import android.icu.text.NumberFormat;

public class IntlTestDecimalFormatAPI extends android.icu.dev.test.TestFmwk
{
    /**
     * Problem 1: simply running 
     * decF4.setRoundingMode(java.math.BigDecimal.ROUND_HALF_UP) does not work 
     * as decF4.setRoundingIncrement(.0001) must also be run.
     * Problem 2: decF4.format(8.88885) does not return 8.8889 as expected. 
     * You must run decF4.format(new BigDecimal(Double.valueOf(8.88885))) in 
     * order for this to work as expected.
     * Problem 3: There seems to be no way to set half up to be the default 
     * rounding mode.
     * We solved the problem with the code at the bottom of this page however 
     * this is not quite general purpose enough to include in icu4j. A static
     * setDefaultRoundingMode function would solve the problem nicely. Also 
     * decimal places past 20 are not handled properly. A small ammount of work 
     * would make bring this up to snuff.
     */
    @Test
    public void testJB1871()
    {
        // problem 2
        double number = 8.88885;
        String expected = ""8.8889"";
        
        String pat = "",##0.0000"";
        DecimalFormat dec = new DecimalFormat(pat);
        dec.setRoundingMode(BigDecimal.ROUND_HALF_UP);
        double  [MASK]  = 0.0001;
        dec.setRoundingIncrement( [MASK] );
        String str = dec.format(number);
        if (!str.equals(expected)) {
            errln(""Fail: "" + number + "" x \"""" + pat + ""\"" = \"""" +
                  str + ""\"", expected \"""" + expected + ""\"""");
        }   

        pat = "",##0.0001"";
        dec = new DecimalFormat(pat);
        dec.setRoundingMode(BigDecimal.ROUND_HALF_UP);
        str = dec.format(number);
        if (!str.equals(expected)) {
            errln(""Fail: "" + number + "" x \"""" + pat + ""\"" = \"""" +
                  str + ""\"", expected \"""" + expected + ""\"""");
        }  
        
        // testing 20 decimal places
        pat = "",##0.00000000000000000001"";
        dec = new DecimalFormat(pat);
        BigDecimal bignumber = new BigDecimal(""8.888888888888888888885"");
        expected = ""8.88888888888888888889"";
        
        dec.setRoundingMode(BigDecimal.ROUND_HALF_UP);
        str = dec.format(bignumber); 
        if (!str.equals(expected)) {
            errln(""Fail: "" + bignumber + "" x \"""" + pat + ""\"" = \"""" +
                  str + ""\"", expected \"""" + expected + ""\"""");
        }   
        
    }

    /** 
     * This test checks various generic API methods in DecimalFormat to achieve 
     * 100% API coverage.
     */
    @Test
    public void TestAPI()
    {
        logln(""DecimalFormat API test---""); logln("""");
        Locale.setDefault(Locale.ENGLISH);

        // ======= Test constructors

        logln(""Testing DecimalFormat constructors"");

        DecimalFormat def = new DecimalFormat();

        final String pattern = new String(""#,##0.# FF"");
        DecimalFormat pat = null;
        try {
            pat = new DecimalFormat(pattern);
        }
        catch (IllegalArgumentException e) {
            errln(""ERROR: Could not create DecimalFormat (pattern)"");
        }

        DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.FRENCH);

        DecimalFormat cust1 = new DecimalFormat(pattern, symbols);

        // ======= Test clone(), assignment, and equality

        logln(""Testing clone() and equality operators"");

        Format clone = (Format) def.clone();
        if( ! def.equals(clone)) {
            errln(""ERROR: Clone() failed"");
        }

        // ======= Test various format() methods

        logln(""Testing various format() methods"");

//        final double d = -10456.0037; // this appears as -10456.003700000001 on NT
//        final double d = -1.04560037e-4; // this appears as -1.0456003700000002E-4 on NT
        final double d = -10456.00370000000000; // this works!
        final long l = 100000000;
        logln("""" + d + "" is the double value"");

        StringBuffer res1 = new StringBuffer();
        StringBuffer res2 = new StringBuffer();
        StringBuffer res3 = new StringBuffer();
        StringBuffer res4 = new StringBuffer();
        FieldPosition pos1 = new FieldPosition(0);
        FieldPosition pos2 = new FieldPosition(0);
        FieldPosition pos3 = new FieldPosition(0);
        FieldPosition pos4 = new FieldPosition(0);

        res1 = def.format(d, res1, pos1);
        logln("""" + d + "" formatted to "" + res1);

        res2 = pat.format(l, res2, pos2);
        logln("""" + l + "" formatted to "" + res2);

        res3 = cust1.format(d, res3, pos3);
        logln("""" + d + "" formatted to "" + res3);

        res4 = cust1.format(l, res4, pos4);
        logln("""" + l + "" formatted to "" + res4);

        // ======= Test parse()

        logln(""Testing parse()"");

        String text = new String(""-10,456.0037"");
        ParsePosition pos = new ParsePosition(0);
        String patt = new String(""#,##0.#"");
        pat.applyPattern(patt);
        double d2 = pat.parse(text, pos).doubleValue();
        if(d2 != d) {
            errln(""ERROR: Roundtrip failed (via parse("" + d2 + "" != "" + d + "")) for "" + text);
        }
        logln(text + "" parsed into "" + (long) d2);

        // ======= Test getters and setters

        logln(""Testing getters and setters"");

        final DecimalFormatSymbols syms = pat.getDecimalFormatSymbols();
        def.setDecimalFormatSymbols(syms);
        if( ! pat.getDecimalFormatSymbols().equals(def.getDecimalFormatSymbols())) {
            errln(""ERROR: set DecimalFormatSymbols() failed"");
        }

        String posPrefix;
        pat.setPositivePrefix(""+"");
        posPrefix = pat.getPositivePrefix();
        logln(""Positive prefix (should be +): "" + posPrefix);
        if(posPrefix != ""+"") {
            errln(""ERROR: setPositivePrefix() failed"");
        }

        String negPrefix;
        pat.setNegativePrefix(""-"");
        negPrefix = pat.getNegativePrefix();
        logln(""Negative prefix (should be -): "" + negPrefix);
        if(negPrefix != ""-"") {
            errln(""ERROR: setNegativePrefix() failed"");
        }

        String posSuffix;
        pat.setPositiveSuffix(""_"");
        posSuffix = pat.getPositiveSuffix();
        logln(""Positive suffix (should be _): "" + posSuffix);
        if(posSuffix != ""_"") {
            errln(""ERROR: setPositiveSuffix() failed"");
        }

        String negSuffix;
        pat.setNegativeSuffix(""~"");
        negSuffix = pat.getNegativeSuffix();
        logln(""Negative suffix (should be ~): "" + negSuffix);
        if(negSuffix != ""~"") {
            errln(""ERROR: setNegativeSuffix() failed"");
        }

        long multiplier = 0;
        pat.setMultiplier(8);
        multiplier = pat.getMultiplier();
        logln(""Multiplier (should be 8): "" + multiplier);
        if(multiplier != 8) {
            errln(""ERROR: setMultiplier() failed"");
        }

        int groupingSize = 0;
        pat.setGroupingSize(2);
        groupingSize = pat.getGroupingSize();
        logln(""Grouping size (should be 2): "" + (long) groupingSize);
        if(groupingSize != 2) {
            errln(""ERROR: setGroupingSize() failed"");
        }

        pat.setDecimalSeparatorAlwaysShown(true);
        boolean tf = pat.isDecimalSeparatorAlwaysShown();
        logln(""DecimalSeparatorIsAlwaysShown (should be true) is "" +  (tf ? ""true"" : ""false""));
        if(tf != true) {
            errln(""ERROR: setDecimalSeparatorAlwaysShown() failed"");
        }

        String funkyPat;
        funkyPat = pat.toPattern();
        logln(""Pattern is "" + funkyPat);

        String locPat;
        locPat = pat.toLocalizedPattern();
        logln(""Localized pattern is "" + locPat);

        // ======= Test applyPattern()

        logln(""Testing applyPattern()"");

        String p1 = new String(""#,##0.0#;(#,##0.0#)"");
        logln(""Applying pattern "" + p1);
        pat.applyPattern(p1);
        String s2;
        s2 = pat.toPattern();
        logln(""Extracted pattern is "" + s2);
        if( ! s2.equals(p1) ) {
            errln(""ERROR: toPattern() result did not match pattern applied"");
        }

        String p2 = new String(""#,##0.0# FF;(#,##0.0# FF)"");
        logln(""Applying pattern "" + p2);
        pat.applyLocalizedPattern(p2);
        String s3;
        s3 = pat.toLocalizedPattern();
        logln(""Extracted pattern is "" + s3);
        if( ! s3.equals(p2) ) {
            errln(""ERROR: toLocalizedPattern() result did not match pattern applied"");
        }
    }

    @Test
    public void testJB6134()
    {
        DecimalFormat decfmt = new DecimalFormat();
        StringBuffer buf = new StringBuffer();

        FieldPosition fposByInt = new FieldPosition(NumberFormat.INTEGER_FIELD);
        decfmt.format(123, buf, fposByInt);

        buf.setLength(0);
        FieldPosition fposByField = new FieldPosition(NumberFormat.Field.INTEGER);
        decfmt.format(123, buf, fposByField);

        if (fposByInt.getEndIndex() != fposByField.getEndIndex())
        {
            errln(""ERROR: End index for integer field - fposByInt:"" + fposByInt.getEndIndex() +
                "" / fposByField: "" + fposByField.getEndIndex());
        }
    }

    @Test
    public void testJB4971()
    {
        DecimalFormat decfmt = new DecimalFormat();
        MathContext resultICU;

        MathContext comp1 = new MathContext(0, MathContext.PLAIN);
        resultICU = decfmt.getMathContextICU();
        if ((comp1.getDigits() != resultICU.getDigits()) ||
            (comp1.getForm() != resultICU.getForm()) ||
            (comp1.getLostDigits() != resultICU.getLostDigits()) ||
            (comp1.getRoundingMode() != resultICU.getRoundingMode()))
        {
            errln(""ERROR: Math context 1 not equal - result: "" + resultICU.toString() +
                "" / expected: "" + comp1.toString());
        }

        MathContext comp2 = new MathContext(5, MathContext.ENGINEERING);
        decfmt.setMathContextICU(comp2);
        resultICU = decfmt.getMathContextICU();
        if ((comp2.getDigits() != resultICU.getDigits()) ||
            (comp2.getForm() != resultICU.getForm()) ||
            (comp2.getLostDigits() != resultICU.getLostDigits()) ||
            (comp2.getRoundingMode() != resultICU.getRoundingMode()))
        {
            errln(""ERROR: Math context 2 not equal - result: "" + resultICU.toString() +
                "" / expected: "" + comp2.toString());
        }

        java.math.MathContext result;

        java.math.MathContext comp3 = new java.math.MathContext(3, java.math.RoundingMode.DOWN);
        decfmt.setMathContext(comp3);
        result = decfmt.getMathContext();
        if ((comp3.getPrecision() != result.getPrecision()) ||
            (comp3.getRoundingMode() != result.getRoundingMode()))
        {
            errln(""ERROR: Math context 3 not equal - result: "" + result.toString() +
                "" / expected: "" + comp3.toString());
        }

    }

    @Test
    public void testJB6354()
    {
        DecimalFormat pat = new DecimalFormat(""#,##0.00"");
        java.math.BigDecimal r1, r2;

        // get default rounding increment
        r1 = pat.getRoundingIncrement();

        // set rounding mode with zero increment.  Rounding 
        // increment should be set by this operation
        pat.setRoundingMode(BigDecimal.ROUND_UP);
        r2 = pat.getRoundingIncrement();

        // check for different values
        if ((r1 != null) && (r2 != null))
        {
            if (r1.compareTo(r2) == 0)
            {
                errln(""ERROR: Rounding increment did not change"");
            }
        }
    }
    
    @Test
    public void testJB6648()
    {
        DecimalFormat df = new DecimalFormat();
        df.setParseStrict(true);
        
        String numstr = new String();
        
        String[] patterns = {
            ""0"",
            ""00"",
            ""000"",
            ""0,000"",
            ""0.0"",
            ""#000.0""          
        };
        
        for(int i=0; i < patterns.length; i++) {
            df.applyPattern(patterns[i]);
            numstr = df.format(5);        
            try {
                Number n = df.parse(numstr);
                logln(""INFO: Parsed "" + numstr + "" -> "" + n);
            } catch (ParseException pe) {
                errln(""ERROR: Failed round trip with strict parsing."");
            }           
        }
        
        df.applyPattern(patterns[1]);
        numstr = ""005"";        
        try {
            Number n = df.parse(numstr);
            logln(""INFO: Successful parse for "" + numstr + "" with strict parse enabled. Number is "" + n);
        } catch (ParseException pe) {
            errln(""ERROR: Parse Exception encountered in strict mode: numstr -> "" + numstr);
        }  
        
    }
}
","roundinginc
",inc,roundingIncrement,roundingIncrement,roundingIncrement,
"

package com.facebook.imagepipeline.memory;

import com.facebook.common.internal.ImmutableMap;
import com.facebook.common.references.CloseableReference;
import com.facebook.imagepipeline.testing.FakeNativeMemoryChunkPool;
import java.util.Arrays;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;

/** Tests for {@link MemoryPooledByteBufferOutputStream} */
@RunWith(RobolectricTestRunner.class)
@Config(manifest = Config.NONE)
public class MemoryPooledByteBufferOutputStreamTest extends TestUsingNativeMemoryChunk {
  private MemoryChunkPool mNativePool;

  private byte[] mData;
  private PoolStats<byte[]> mNativeStats;

  @Before
  public void setup() {
    mNativePool = new FakeNativeMemoryChunkPool();
    mNativeStats = new PoolStats(mNativePool);

    mData = new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};
  }

  @Test
  public void testBasic_1() throws Exception {
    testBasic_1(mNativePool, mNativeStats);
  }

  @Test
  public void testBasic_2() throws Exception {
    testBasic_2(mNativePool, mNativeStats);
  }

  @Test
  public void testBasic_3() throws Exception {
    testBasic_3(mNativePool, mNativeStats);
  }

  @Test
  public void testBasic_4() throws Exception {
    testBasic_4(mNativePool, mNativeStats);
  }

  @Test
  public void testClose() {
    testClose(mNativePool, mNativeStats);
  }

  @Test(expected = MemoryPooledByteBufferOutputStream.InvalidStreamException.class)
  public void testToByteBufExceptionUsingNativePool() {
    testToByteBufException(mNativePool);
  }

  @Test
  public void testWriteAfterToByteBuf() throws Exception {
    testWriteAfterToByteBuf(mNativePool);
  }

  private void testBasic_1(final MemoryChunkPool mPool, final PoolStats<byte[]> mStats)
      throws Exception {
    MemoryPooledByteBufferOutputStream os1 = new MemoryPooledByteBufferOutputStream(mPool);
    MemoryPooledByteBuffer sb1 = doWrite(os1, mData);
    Assert.assertEquals(16, sb1.getCloseableReference().get().getSize());
    assertArrayEquals(mData, getBytes(sb1), mData.length);
    mStats.refresh();
    Assert.assertEquals(
        ImmutableMap.of(
            32, new IntPair(0, 0),
            16, new IntPair(1, 0),
            8, new IntPair(0, 1),
            4, new IntPair(0, 1)),
        mStats.getBucketStats());
  }

  private void testBasic_2(final MemoryChunkPool mPool, final PoolStats<byte[]> mStats)
      throws Exception {
    MemoryPooledByteBufferOutputStream os2 = new MemoryPooledByteBufferOutputStream(mPool, 8);
    MemoryPooledByteBuffer sb2 = doWrite(os2, mData);
    Assert.assertEquals(16, sb2.getCloseableReference().get().getSize());
    assertArrayEquals(mData, getBytes(sb2), mData.length);
    mStats.refresh();
    Assert.assertEquals(
        ImmutableMap.of(
            32, new IntPair(0, 0),
            16, new IntPair(1, 0),
            8, new IntPair(0, 1),
            4, new IntPair(0, 0)),
        mStats.getBucketStats());
  }

  private void testBasic_3(final MemoryChunkPool mPool, final PoolStats<byte[]> mStats)
      throws Exception {
    MemoryPooledByteBufferOutputStream os3 = new MemoryPooledByteBufferOutputStream(mPool, 16);
    MemoryPooledByteBuffer sb3 = doWrite(os3, mData);
    Assert.assertEquals(16, sb3.getCloseableReference().get().getSize());
    assertArrayEquals(mData, getBytes(sb3), mData.length);
    mStats.refresh();
    Assert.assertEquals(
        ImmutableMap.of(
            32, new IntPair(0, 0),
            16, new IntPair(1, 0),
            8, new IntPair(0, 0),
            4, new IntPair(0, 0)),
        mStats.getBucketStats());
  }

  private void testBasic_4(final MemoryChunkPool mPool, final PoolStats<byte[]> mStats)
      throws Exception {
    MemoryPooledByteBufferOutputStream os4 = new MemoryPooledByteBufferOutputStream(mPool, 32);
    MemoryPooledByteBuffer sb4 = doWrite(os4, mData);
    Assert.assertEquals(32, sb4.getCloseableReference().get().getSize());
    assertArrayEquals(mData, getBytes(sb4), mData.length);
    mStats.refresh();
    Assert.assertEquals(
        ImmutableMap.of(
            32, new IntPair(1, 0),
            16, new IntPair(0, 0),
            8, new IntPair(0, 0),
            4, new IntPair(0, 0)),
        mStats.getBucketStats());
  }

  private static void testClose(final MemoryChunkPool mPool, final PoolStats<byte[]> mStats) {
    MemoryPooledByteBufferOutputStream os = new MemoryPooledByteBufferOutputStream(mPool);
    os.close();
    mStats.refresh();
    Assert.assertEquals(
        ImmutableMap.of(
            32, new IntPair(0, 0),
            16, new IntPair(0, 0),
            8, new IntPair(0, 0),
            4, new IntPair(0, 1)),
        mStats.getBucketStats());
  }

  private static void testToByteBufException(final MemoryChunkPool mPool) {
    MemoryPooledByteBufferOutputStream os1 = new MemoryPooledByteBufferOutputStream(mPool);
    os1.close();
    os1.toByteBuffer();
    Assert.fail();
  }

  private void testWriteAfterToByteBuf(final MemoryChunkPool mPool) throws Exception {
    MemoryPooledByteBufferOutputStream os1 = new MemoryPooledByteBufferOutputStream(mPool);
    MemoryPooledByteBuffer buf1 = doWrite(os1, Arrays.copyOf(mData, 9));
    MemoryPooledByteBuffer buf2 = doWrite(os1, Arrays.copyOf(mData, 3));
    Assert.assertEquals(12, buf2.size());

    final CloseableReference<MemoryChunk>  [MASK]  = buf1.getCloseableReference();
    Assert.assertEquals(3,  [MASK] .getUnderlyingReferenceTestOnly().getRefCountTestOnly());
    os1.close();
    buf1.close();
    buf2.close();
    Assert.assertEquals(0,  [MASK] .getUnderlyingReferenceTestOnly().getRefCountTestOnly());
  }

  // write out the contents of data into the output stream
  private static MemoryPooledByteBuffer doWrite(MemoryPooledByteBufferOutputStream os, byte[] data)
      throws Exception {
    for (int i = 0; i < data.length; i++) {
      os.write(data, i, 1);
    }
    return os.toByteBuffer();
  }

  // assert that the first 'length' bytes of expected are the same as those in 'actual'
  private static void assertArrayEquals(byte[] expected, byte[] actual, int length) {
    Assert.assertTrue(expected.length >= length);
    Assert.assertTrue(actual.length >= length);
    for (int i = 0; i < length; i++) {
      Assert.assertEquals(expected[i], actual[i]);
    }
  }

  private static byte[] getBytes(MemoryPooledByteBuffer bb) {
    byte[] bytes = new byte[bb.size()];
    bb.getCloseableReference().get().read(0, bytes, 0, bytes.length);
    return bytes;
  }
}
","chunk
",mChunkReference,mChunkReference,chunkReference,memoryChunkReference,
"
package com.google.android.exoplayer2.extractor.ts;

import static java.lang.Math.min;

import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.extractor.BinarySearchSeeker;
import com.google.android.exoplayer2.extractor.ExtractorInput;
import com.google.android.exoplayer2.util.ParsableByteArray;
import com.google.android.exoplayer2.util.TimestampAdjuster;
import com.google.android.exoplayer2.util.Util;
import java.io.IOException;

/**
 * A seeker that supports seeking within TS stream using binary search.
 *
 * <p>This seeker uses the first and last PCR values within the stream, as well as the stream
 * duration to interpolate the PCR value of the seeking position. Then it performs binary search
 * within the stream to find a packets whose PCR value is within {@link #SEEK_TOLERANCE_US} from the
 * target PCR.
 *
 * @deprecated com.google.android.exoplayer2 is deprecated. Please migrate to androidx.media3 (which
 *     contains the same ExoPlayer code). See <a
 *     href=""https://developer.android.com/guide/topics/media/media3/getting-started/migration-guide"">the
 *     migration guide</a> for more details, including a script to help with the migration.
 */
@Deprecated
/* package */ final class TsBinarySearchSeeker extends BinarySearchSeeker {

  private static final long SEEK_TOLERANCE_US = 100_000;
  private static final int MINIMUM_SEARCH_RANGE_BYTES = 5 * TsExtractor.TS_PACKET_SIZE;

  public TsBinarySearchSeeker(
      TimestampAdjuster pcrTimestampAdjuster,
      long streamDurationUs,
      long inputLength,
      int pcrPid,
      int timestampSearchBytes) {
    super(
        new DefaultSeekTimestampConverter(),
        new TsPcrSeeker(pcrPid, pcrTimestampAdjuster, timestampSearchBytes),
        streamDurationUs,
        /* floorTimePosition= */ 0,
        /* ceilingTimePosition= */ streamDurationUs + 1,
        /* floorBytePosition= */ 0,
        /* ceilingBytePosition= */ inputLength,
        /* approxBytesPerFrame= */ TsExtractor.TS_PACKET_SIZE,
        MINIMUM_SEARCH_RANGE_BYTES);
  }

  /**
   * A {@link TimestampSeeker} implementation that looks for a given PCR timestamp at a given
   * position in a TS stream.
   *
   * <p>Given a PCR timestamp, and a position within a TS stream, this seeker will peek up to {@link
   * #timestampSearchBytes} from that stream position, look for all packets with PID equal to
   * PCR_PID, and then compare the PCR timestamps (if available) of these packets to the target
   * timestamp.
   */
  private static final class TsPcrSeeker implements TimestampSeeker {

    private final TimestampAdjuster pcrTimestampAdjuster;
    private final ParsableByteArray packetBuffer;
    private final int pcrPid;
    private final int timestampSearchBytes;

    public TsPcrSeeker(
        int pcrPid, TimestampAdjuster pcrTimestampAdjuster, int timestampSearchBytes) {
      this.pcrPid = pcrPid;
      this.pcrTimestampAdjuster = pcrTimestampAdjuster;
      this.timestampSearchBytes = timestampSearchBytes;
      packetBuffer = new ParsableByteArray();
    }

    @Override
    public TimestampSearchResult searchForTimestamp(ExtractorInput input, long targetTimestamp)
        throws IOException {
      long inputPosition = input.getPosition();
      int bytesToSearch = (int) min(timestampSearchBytes, input.getLength() - inputPosition);

      packetBuffer.reset(bytesToSearch);
      input.peekFully(packetBuffer.getData(), /* offset= */ 0, bytesToSearch);

      return searchForPcrValueInBuffer(packetBuffer, targetTimestamp, inputPosition);
    }

    private TimestampSearchResult searchForPcrValueInBuffer(
        ParsableByteArray packetBuffer, long targetPcrTimeUs, long bufferStartOffset) {
      int limit = packetBuffer.limit();

      long startOfLastPacketPosition = C.INDEX_UNSET;
      long endOfLastPacketPosition = C.INDEX_UNSET;
      long lastPcrTimeUsInRange = C.TIME_UNSET;

      while (packetBuffer.bytesLeft() >= TsExtractor.TS_PACKET_SIZE) {
        int startOfPacket =
            TsUtil.findSyncBytePosition(packetBuffer.getData(), packetBuffer.getPosition(), limit);
        int  [MASK]  = startOfPacket + TsExtractor.TS_PACKET_SIZE;
        if ( [MASK]  > limit) {
          break;
        }
        long pcrValue = TsUtil.readPcrFromPacket(packetBuffer, startOfPacket, pcrPid);
        if (pcrValue != C.TIME_UNSET) {
          long pcrTimeUs = pcrTimestampAdjuster.adjustTsTimestamp(pcrValue);
          if (pcrTimeUs > targetPcrTimeUs) {
            if (lastPcrTimeUsInRange == C.TIME_UNSET) {
              // First PCR timestamp is already over target.
              return TimestampSearchResult.overestimatedResult(pcrTimeUs, bufferStartOffset);
            } else {
              // Last PCR timestamp < target timestamp < this timestamp.
              return TimestampSearchResult.targetFoundResult(
                  bufferStartOffset + startOfLastPacketPosition);
            }
          } else if (pcrTimeUs + SEEK_TOLERANCE_US > targetPcrTimeUs) {
            long startOfPacketInStream = bufferStartOffset + startOfPacket;
            return TimestampSearchResult.targetFoundResult(startOfPacketInStream);
          }

          lastPcrTimeUsInRange = pcrTimeUs;
          startOfLastPacketPosition = startOfPacket;
        }
        packetBuffer.setPosition( [MASK] );
        endOfLastPacketPosition =  [MASK] ;
      }

      if (lastPcrTimeUsInRange != C.TIME_UNSET) {
        long endOfLastPacketPositionInStream = bufferStartOffset + endOfLastPacketPosition;
        return TimestampSearchResult.underestimatedResult(
            lastPcrTimeUsInRange, endOfLastPacketPositionInStream);
      } else {
        return TimestampSearchResult.NO_TIMESTAMP_IN_RANGE_RESULT;
      }
    }

    @Override
    public void onSeekFinished() {
      packetBuffer.reset(Util.EMPTY_BYTE_ARRAY);
    }
  }
}
","endOfPacket
",endOfPPos,endOfPacketPos,packetStartPosition,endOfPacket,
"package com.google.android.exoplayer2.ext.ima;

import static com.google.android.exoplayer2.ext.ima.ImaUtil.BITRATE_UNSET;
import static com.google.android.exoplayer2.ext.ima.ImaUtil.TIMEOUT_UNSET;
import static com.google.android.exoplayer2.ext.ima.ImaUtil.getImaLooper;
import static com.google.android.exoplayer2.util.Assertions.checkArgument;
import static com.google.android.exoplayer2.util.Assertions.checkNotNull;
import static com.google.android.exoplayer2.util.Assertions.checkState;

import android.content.Context;
import android.os.Looper;
import android.view.View;
import android.view.ViewGroup;
import androidx.annotation.IntRange;
import androidx.annotation.Nullable;
import androidx.annotation.VisibleForTesting;
import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
import com.google.ads.interactivemedia.v3.api.AdErrorEvent.AdErrorListener;
import com.google.ads.interactivemedia.v3.api.AdEvent.AdEventListener;
import com.google.ads.interactivemedia.v3.api.AdsManager;
import com.google.ads.interactivemedia.v3.api.AdsRenderingSettings;
import com.google.ads.interactivemedia.v3.api.AdsRequest;
import com.google.ads.interactivemedia.v3.api.CompanionAdSlot;
import com.google.ads.interactivemedia.v3.api.FriendlyObstruction;
import com.google.ads.interactivemedia.v3.api.FriendlyObstructionPurpose;
import com.google.ads.interactivemedia.v3.api.ImaSdkFactory;
import com.google.ads.interactivemedia.v3.api.ImaSdkSettings;
import com.google.ads.interactivemedia.v3.api.UiElement;
import com.google.ads.interactivemedia.v3.api.player.VideoAdPlayer;
import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
import com.google.android.exoplayer2.Player;
import com.google.android.exoplayer2.Timeline;
import com.google.android.exoplayer2.source.MediaSource;
import com.google.android.exoplayer2.source.ads.AdsLoader;
import com.google.android.exoplayer2.source.ads.AdsMediaSource;
import com.google.android.exoplayer2.ui.AdViewProvider;
import com.google.android.exoplayer2.upstream.DataSpec;
import com.google.android.exoplayer2.util.MimeTypes;
import com.google.android.exoplayer2.util.Util;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

/**
 * {@link AdsLoader} using the IMA SDK. All methods must be called on the main thread.
 *
 * <p>The player instance that will play the loaded ads must be set before playback using {@link
 * #setPlayer(Player)}. If the ads loader is no longer required, it must be released by calling
 * {@link #release()}.
 *
 * <p>See <a
 * href=""https://developers.google.com/interactive-media-ads/docs/sdks/android/compatibility"">IMA's
 * Support and compatibility page</a> for information on compatible ad tag formats. Pass the ad tag
 * URI when setting media item playback properties (if using the media item API) or as a {@link
 * DataSpec} when constructing the {@link AdsMediaSource} (if using media sources directly). For the
 * latter case, please note that this implementation delegates loading of the data spec to the IMA
 * SDK, so range and headers specifications will be ignored in ad tag URIs. Literal ads responses
 * can be encoded as data scheme data specs, for example, by constructing the data spec using a URI
 * generated via {@link Util#getDataUriForString(String, String)}.
 *
 * <p>The IMA SDK can report obstructions to the ad view for accurate viewability measurement. This
 * means that any overlay views that obstruct the ad overlay but are essential for playback need to
 * be registered via the {@link AdViewProvider} passed to the {@link AdsMediaSource}. See the <a
 * href=""https://developers.google.com/interactive-media-ads/docs/sdks/android/client-side/omsdk"">IMA
 * SDK Open Measurement documentation</a> for more information.
 *
 * @deprecated com.google.android.exoplayer2 is deprecated. Please migrate to androidx.media3 (which
 *     contains the same ExoPlayer code). See <a
 *     href=""https://developer.android.com/guide/topics/media/media3/getting-started/migration-guide"">the
 *     migration guide</a> for more details, including a script to help with the migration.
 */
@Deprecated
public final class ImaAdsLoader implements AdsLoader {

  static {
    ExoPlayerLibraryInfo.registerModule(""goog.exo.ima"");
  }

  /** Builder for {@link ImaAdsLoader}. */
  public static final class Builder {

    /**
     * The default duration in milliseconds for which the player must buffer while preloading an ad
     * group before that ad group is skipped and marked as having failed to load.
     *
     * <p>This value should be large enough not to trigger discarding the ad when it actually might
     * load soon, but small enough so that user is not waiting for too long.
     *
     * @see #setAdPreloadTimeoutMs(long)
     */
    public static final long DEFAULT_AD_PRELOAD_TIMEOUT_MS = 10 * C.MILLIS_PER_SECOND;

    private final Context context;

    @Nullable private ImaSdkSettings imaSdkSettings;
    @Nullable private AdErrorListener adErrorListener;
    @Nullable private AdEventListener adEventListener;
    @Nullable private VideoAdPlayer.VideoAdPlayerCallback videoAdPlayerCallback;
    @Nullable private List<String> adMediaMimeTypes;
    @Nullable private Set<UiElement> adUiElements;
    @Nullable private Collection<CompanionAdSlot> companionAdSlots;
    @Nullable private Boolean enableContinuousPlayback;
    private long adPreloadTimeoutMs;
    private int vastLoadTimeoutMs;
    private int mediaLoadTimeoutMs;
    private int mediaBitrate;
    private boolean focusSkipButtonWhenAvailable;
    private boolean playAdBeforeStartPosition;
    private boolean debugModeEnabled;
    private ImaUtil.ImaFactory imaFactory;

    /**
     * Creates a new builder for {@link ImaAdsLoader}.
     *
     * @param context The context;
     */
    public Builder(Context context) {
      this.context = checkNotNull(context).getApplicationContext();
      adPreloadTimeoutMs = DEFAULT_AD_PRELOAD_TIMEOUT_MS;
      vastLoadTimeoutMs = TIMEOUT_UNSET;
      mediaLoadTimeoutMs = TIMEOUT_UNSET;
      mediaBitrate = BITRATE_UNSET;
      focusSkipButtonWhenAvailable = true;
      playAdBeforeStartPosition = true;
      imaFactory = new DefaultImaFactory();
    }

    /**
     * Sets the IMA SDK settings. The provided settings instance's player type and version fields
     * may be overwritten.
     *
     * <p>If this method is not called the default settings will be used.
     *
     * @param imaSdkSettings The {@link ImaSdkSettings}.
     * @return This builder, for convenience.
     */
    @CanIgnoreReturnValue
    public Builder setImaSdkSettings(ImaSdkSettings imaSdkSettings) {
      this.imaSdkSettings = checkNotNull(imaSdkSettings);
      return this;
    }

    /**
     * Sets a listener for ad errors that will be passed to {@link
     * com.google.ads.interactivemedia.v3.api.AdsLoader#addAdErrorListener(AdErrorListener)} and
     * {@link AdsManager#addAdErrorListener(AdErrorListener)}.
     *
     * @param adErrorListener The ad error listener.
     * @return This builder, for convenience.
     */
    @CanIgnoreReturnValue
    public Builder setAdErrorListener(AdErrorListener adErrorListener) {
      this.adErrorListener = checkNotNull(adErrorListener);
      return this;
    }

    /**
     * Sets a listener for ad events that will be passed to {@link
     * AdsManager#addAdEventListener(AdEventListener)}.
     *
     * @param adEventListener The ad event listener.
     * @return This builder, for convenience.
     */
    @CanIgnoreReturnValue
    public Builder setAdEventListener(AdEventListener adEventListener) {
      this.adEventListener = checkNotNull(adEventListener);
      return this;
    }

    /**
     * Sets a callback to receive video ad player events. Note that these events are handled
     * internally by the IMA SDK and this ads loader. For analytics and diagnostics, new
     * implementations should generally use events from the top-level {@link Player} listeners
     * instead of setting a callback via this method.
     *
     * @param videoAdPlayerCallback The callback to receive video ad player events.
     * @return This builder, for convenience.
     * @see com.google.ads.interactivemedia.v3.api.player.VideoAdPlayer.VideoAdPlayerCallback
     */
    @CanIgnoreReturnValue
    public Builder setVideoAdPlayerCallback(
        VideoAdPlayer.VideoAdPlayerCallback videoAdPlayerCallback) {
      this.videoAdPlayerCallback = checkNotNull(videoAdPlayerCallback);
      return this;
    }

    /**
     * Sets the ad UI elements to be rendered by the IMA SDK.
     *
     * @param adUiElements The ad UI elements to be rendered by the IMA SDK.
     * @return This builder, for convenience.
     * @see AdsRenderingSettings#setUiElements(Set)
     */
    @CanIgnoreReturnValue
    public Builder setAdUiElements(Set<UiElement> adUiElements) {
      this.adUiElements = ImmutableSet.copyOf(checkNotNull(adUiElements));
      return this;
    }

    /**
     * Sets the slots to use for companion ads, if they are present in the loaded ad.
     *
     * @param companionAdSlots The slots to use for companion ads.
     * @return This builder, for convenience.
     * @see AdDisplayContainer#setCompanionSlots(Collection)
     */
    @CanIgnoreReturnValue
    public Builder setCompanionAdSlots(Collection<CompanionAdSlot> companionAdSlots) {
      this.companionAdSlots = ImmutableList.copyOf(checkNotNull(companionAdSlots));
      return this;
    }

    /**
     * Sets the MIME types to prioritize for linear ad media. If not specified, MIME types supported
     * by the {@link MediaSource.Factory adMediaSourceFactory} used to construct the {@link
     * AdsMediaSource} will be used.
     *
     * @param adMediaMimeTypes The MIME types to prioritize for linear ad media. May contain {@link
     *     MimeTypes#APPLICATION_MPD}, {@link MimeTypes#APPLICATION_M3U8}, {@link
     *     MimeTypes#VIDEO_MP4}, {@link MimeTypes#VIDEO_WEBM}, {@link MimeTypes#VIDEO_H263}, {@link
     *     MimeTypes#AUDIO_MP4} and {@link MimeTypes#AUDIO_MPEG}.
     * @return This builder, for convenience.
     * @see AdsRenderingSettings#setMimeTypes(List)
     */
    @CanIgnoreReturnValue
    public Builder setAdMediaMimeTypes(List<String> adMediaMimeTypes) {
      this.adMediaMimeTypes = ImmutableList.copyOf(checkNotNull(adMediaMimeTypes));
      return this;
    }

    /**
     * Sets whether to enable continuous playback. Pass {@code true} if content videos will be
     * played continuously, similar to a TV broadcast. This setting may modify the ads request but
     * does not affect ad playback behavior. The requested value is unknown by default.
     *
     * @param enableContinuousPlayback Whether to enable continuous playback.
     * @return This builder, for convenience.
     * @see AdsRequest#setContinuousPlayback(boolean)
     */
    @CanIgnoreReturnValue
    public Builder setEnableContinuousPlayback(boolean enableContinuousPlayback) {
      this.enableContinuousPlayback = enableContinuousPlayback;
      return this;
    }

    /**
     * Sets the duration in milliseconds for which the player must buffer while preloading an ad
     * group before that ad group is skipped and marked as having failed to load. Pass {@link
     * C#TIME_UNSET} if there should be no such timeout. The default value is {@link
     * #DEFAULT_AD_PRELOAD_TIMEOUT_MS} ms.
     *
     * <p>The purpose of this timeout is to avoid playback getting stuck in the unexpected case that
     * the IMA SDK does not load an ad break based on the player's reported content position.
     *
     * @param adPreloadTimeoutMs The timeout buffering duration in milliseconds, or {@link
     *     C#TIME_UNSET} for no timeout.
     * @return This builder, for convenience.
     */
    @CanIgnoreReturnValue
    public Builder setAdPreloadTimeoutMs(long adPreloadTimeoutMs) {
      checkArgument(adPreloadTimeoutMs == C.TIME_UNSET || adPreloadTimeoutMs > 0);
      this.adPreloadTimeoutMs = adPreloadTimeoutMs;
      return this;
    }

    /**
     * Sets the VAST load timeout, in milliseconds.
     *
     * @param vastLoadTimeoutMs The VAST load timeout, in milliseconds.
     * @return This builder, for convenience.
     * @see AdsRequest#setVastLoadTimeout(float)
     */
    @CanIgnoreReturnValue
    public Builder setVastLoadTimeoutMs(@IntRange(from = 1) int vastLoadTimeoutMs) {
      checkArgument(vastLoadTimeoutMs > 0);
      this.vastLoadTimeoutMs = vastLoadTimeoutMs;
      return this;
    }

    /**
     * Sets the ad media load timeout, in milliseconds.
     *
     * @param mediaLoadTimeoutMs The ad media load timeout, in milliseconds.
     * @return This builder, for convenience.
     * @see AdsRenderingSettings#setLoadVideoTimeout(int)
     */
    @CanIgnoreReturnValue
    public Builder setMediaLoadTimeoutMs(@IntRange(from = 1) int mediaLoadTimeoutMs) {
      checkArgument(mediaLoadTimeoutMs > 0);
      this.mediaLoadTimeoutMs = mediaLoadTimeoutMs;
      return this;
    }

    /**
     * Sets the media maximum recommended bitrate for ads, in bps.
     *
     * @param bitrate The media maximum recommended bitrate for ads, in bps.
     * @return This builder, for convenience.
     * @see AdsRenderingSettings#setBitrateKbps(int)
     */
    @CanIgnoreReturnValue
    public Builder setMaxMediaBitrate(@IntRange(from = 1) int bitrate) {
      checkArgument(bitrate > 0);
      this.mediaBitrate = bitrate;
      return this;
    }

    /**
     * Sets whether to focus the skip button (when available) on Android TV devices. The default
     * setting is {@code true}.
     *
     * @param focusSkipButtonWhenAvailable Whether to focus the skip button (when available) on
     *     Android TV devices.
     * @return This builder, for convenience.
     * @see AdsRenderingSettings#setFocusSkipButtonWhenAvailable(boolean)
     */
    @CanIgnoreReturnValue
    public Builder setFocusSkipButtonWhenAvailable(boolean focusSkipButtonWhenAvailable) {
      this.focusSkipButtonWhenAvailable = focusSkipButtonWhenAvailable;
      return this;
    }

    /**
     * Sets whether to play an ad before the start position when beginning playback. If {@code
     * true}, an ad will be played if there is one at or before the start position. If {@code
     * false}, an ad will be played only if there is one exactly at the start position. The default
     * setting is {@code true}.
     *
     * @param playAdBeforeStartPosition Whether to play an ad before the start position when
     *     beginning playback.
     * @return This builder, for convenience.
     */
    @CanIgnoreReturnValue
    public Builder setPlayAdBeforeStartPosition(boolean playAdBeforeStartPosition) {
      this.playAdBeforeStartPosition = playAdBeforeStartPosition;
      return this;
    }

    /**
     * Sets whether to enable outputting verbose logs for the IMA extension and IMA SDK. The default
     * value is {@code false}. This setting is intended for debugging only, and should not be
     * enabled in production applications.
     *
     * @param debugModeEnabled Whether to enable outputting verbose logs for the IMA extension and
     *     IMA SDK.
     * @return This builder, for convenience.
     * @see ImaSdkSettings#setDebugMode(boolean)
     */
    @CanIgnoreReturnValue
    public Builder setDebugModeEnabled(boolean debugModeEnabled) {
      this.debugModeEnabled = debugModeEnabled;
      return this;
    }

    @CanIgnoreReturnValue
    @VisibleForTesting
    /* package */ Builder setImaFactory(ImaUtil.ImaFactory imaFactory) {
      this.imaFactory = checkNotNull(imaFactory);
      return this;
    }

    /** Returns a new {@link ImaAdsLoader}. */
    public ImaAdsLoader build() {
      return new ImaAdsLoader(
          context,
          new ImaUtil.Configuration(
              adPreloadTimeoutMs,
              vastLoadTimeoutMs,
              mediaLoadTimeoutMs,
              focusSkipButtonWhenAvailable,
              playAdBeforeStartPosition,
              mediaBitrate,
              enableContinuousPlayback,
              adMediaMimeTypes,
              adUiElements,
              companionAdSlots,
              adErrorListener,
              adEventListener,
              videoAdPlayerCallback,
              imaSdkSettings,
              debugModeEnabled),
          imaFactory);
    }
  }

  private final ImaUtil.Configuration configuration;
  private final Context context;
  private final ImaUtil.ImaFactory imaFactory;
  private final PlayerListenerImpl playerListener;
  private final HashMap<Object, AdTagLoader> adTagLoaderByAdsId;
  private final HashMap<AdsMediaSource, AdTagLoader> adTagLoaderByAdsMediaSource;
  private final Timeline.Period period;
  private final Timeline.Window window;

  private boolean wasSetPlayerCalled;
  @Nullable private Player nextPlayer;
  private List<String> supportedMimeTypes;
  @Nullable private Player player;
  @Nullable private AdTagLoader currentAdTagLoader;

  private ImaAdsLoader(
      Context context, ImaUtil.Configuration configuration, ImaUtil.ImaFactory imaFactory) {
    this.context = context.getApplicationContext();
    this.configuration = configuration;
    this.imaFactory = imaFactory;
    playerListener = new PlayerListenerImpl();
    supportedMimeTypes = ImmutableList.of();
    adTagLoaderByAdsId = new HashMap<>();
    adTagLoaderByAdsMediaSource = new HashMap<>();
    period = new Timeline.Period();
    window = new Timeline.Window();
  }

  /**
   * Returns the underlying {@link com.google.ads.interactivemedia.v3.api.AdsLoader} wrapped by this
   * instance, or {@code null} if ads have not been requested yet.
   */
  @Nullable
  public com.google.ads.interactivemedia.v3.api.AdsLoader getAdsLoader() {
    return currentAdTagLoader != null ? currentAdTagLoader.getAdsLoader() : null;
  }

  /**
   * Returns the {@link AdDisplayContainer} used by this loader, or {@code null} if ads have not
   * been requested yet.
   *
   * <p>Note: any video controls overlays registered via {@link
   * AdDisplayContainer#registerFriendlyObstruction(FriendlyObstruction)} will be unregistered
   * automatically when the media source detaches from this instance. It is therefore necessary to
   * re-register views each time the ads loader is reused. Alternatively, provide overlay views via
   * the {@link AdViewProvider} when creating the media source to benefit from automatic
   * registration.
   */
  @Nullable
  public AdDisplayContainer getAdDisplayContainer() {
    return currentAdTagLoader != null ? currentAdTagLoader.getAdDisplayContainer() : null;
  }

  /**
   * Requests ads, if they have not already been requested. Must be called on the main thread.
   *
   * <p>Ads will be requested automatically when the player is prepared if this method has not been
   * called, so it is only necessary to call this method if you want to request ads before preparing
   * the player.
   *
   * @param adTagDataSpec The data specification of the ad tag to load. See class javadoc for
   *     information about compatible ad tag formats.
   * @param adsId A opaque identifier for the ad playback state across start/stop calls.
   * @param adViewGroup A {@link ViewGroup} on top of the player that will show any ad UI, or {@code
   *     null} if playing audio-only ads.
   */
  public void requestAds(DataSpec adTagDataSpec, Object adsId, @Nullable ViewGroup adViewGroup) {
    if (!adTagLoaderByAdsId.containsKey(adsId)) {
      AdTagLoader adTagLoader =
          new AdTagLoader(
              context,
              configuration,
              imaFactory,
              supportedMimeTypes,
              adTagDataSpec,
              adsId,
              adViewGroup);
      adTagLoaderByAdsId.put(adsId, adTagLoader);
    }
  }

  /**
   * Skips the current ad.
   *
   * <p>This method is intended for apps that play audio-only ads and so need to provide their own
   * UI for users to skip skippable ads. Apps showing video ads should not call this method, as the
   * IMA SDK provides the UI to skip ads in the ad view group passed via {@link AdViewProvider}.
   */
  public void skipAd() {
    if (currentAdTagLoader != null) {
      currentAdTagLoader.skipAd();
    }
  }

  /**
   * Moves UI focus to the skip button (or other interactive elements), if currently shown. See
   * {@link AdsManager#focus()}.
   */
  public void focusSkipButton() {
    if (currentAdTagLoader != null) {
      currentAdTagLoader.focusSkipButton();
    }
  }

  // AdsLoader implementation.

  @Override
  public void setPlayer(@Nullable Player player) {
    checkState(Looper.myLooper() == getImaLooper());
    checkState(player == null || player.getApplicationLooper() == getImaLooper());
    nextPlayer = player;
    wasSetPlayerCalled = true;
  }

  @Override
  public void setSupportedContentTypes(@C.ContentType int... contentTypes) {
    List<String> supportedMimeTypes = new ArrayList<>();
    for (@C.ContentType int contentType : contentTypes) {
      // IMA does not support Smooth Streaming ad media.
      if (contentType == C.CONTENT_TYPE_DASH) {
        supportedMimeTypes.add(MimeTypes.APPLICATION_MPD);
      } else if (contentType == C.CONTENT_TYPE_HLS) {
        supportedMimeTypes.add(MimeTypes.APPLICATION_M3U8);
      } else if (contentType == C.CONTENT_TYPE_OTHER) {
        supportedMimeTypes.addAll(
            Arrays.asList(
                MimeTypes.VIDEO_MP4,
                MimeTypes.VIDEO_WEBM,
                MimeTypes.VIDEO_H263,
                MimeTypes.AUDIO_MP4,
                MimeTypes.AUDIO_MPEG));
      }
    }
    this.supportedMimeTypes = Collections.unmodifiableList(supportedMimeTypes);
  }

  @Override
  public void start(
      AdsMediaSource adsMediaSource,
      DataSpec adTagDataSpec,
      Object adsId,
      AdViewProvider adViewProvider,
      EventListener eventListener) {
    checkState(
        wasSetPlayerCalled, ""Set player using adsLoader.setPlayer before preparing the player."");
    if (adTagLoaderByAdsMediaSource.isEmpty()) {
      player = nextPlayer;
      @Nullable Player player = this.player;
      if (player == null) {
        return;
      }
      player.addListener(playerListener);
    }

    @Nullable AdTagLoader adTagLoader = adTagLoaderByAdsId.get(adsId);
    if (adTagLoader == null) {
      requestAds(adTagDataSpec, adsId, adViewProvider.getAdViewGroup());
      adTagLoader = adTagLoaderByAdsId.get(adsId);
    }
    adTagLoaderByAdsMediaSource.put(adsMediaSource, checkNotNull(adTagLoader));
    adTagLoader.addListenerWithAdView(eventListener, adViewProvider);
    maybeUpdateCurrentAdTagLoader();
  }

  @Override
  public void stop(AdsMediaSource adsMediaSource, EventListener eventListener) {
    @Nullable AdTagLoader removedAdTagLoader = adTagLoaderByAdsMediaSource.remove(adsMediaSource);
    maybeUpdateCurrentAdTagLoader();
    if (removedAdTagLoader != null) {
      removedAdTagLoader.removeListener(eventListener);
    }

    if (player != null && adTagLoaderByAdsMediaSource.isEmpty()) {
      player.removeListener(playerListener);
      player = null;
    }
  }

  @Override
  public void release() {
    if (player != null) {
      player.removeListener(playerListener);
      player = null;
      maybeUpdateCurrentAdTagLoader();
    }
    nextPlayer = null;

    for (AdTagLoader adTagLoader : adTagLoaderByAdsMediaSource.values()) {
      adTagLoader.release();
    }
    adTagLoaderByAdsMediaSource.clear();

    for (AdTagLoader adTagLoader : adTagLoaderByAdsId.values()) {
      adTagLoader.release();
    }
    adTagLoaderByAdsId.clear();
  }

  @Override
  public void handlePrepareComplete(
      AdsMediaSource adsMediaSource, int adGroupIndex, int adIndexInAdGroup) {
    if (player == null) {
      return;
    }
    checkNotNull(adTagLoaderByAdsMediaSource.get(adsMediaSource))
        .handlePrepareComplete(adGroupIndex, adIndexInAdGroup);
  }

  @Override
  public void handlePrepareError(
      AdsMediaSource adsMediaSource,
      int adGroupIndex,
      int adIndexInAdGroup,
      IOException exception) {
    if (player == null) {
      return;
    }
    checkNotNull(adTagLoaderByAdsMediaSource.get(adsMediaSource))
        .handlePrepareError(adGroupIndex, adIndexInAdGroup, exception);
  }

  // Internal methods.

  private void maybeUpdateCurrentAdTagLoader() {
    @Nullable AdTagLoader  [MASK]  = currentAdTagLoader;
    @Nullable AdTagLoader newAdTagLoader = getCurrentAdTagLoader();
    if (!Util.areEqual( [MASK] , newAdTagLoader)) {
      if ( [MASK]  != null) {
         [MASK] .deactivate();
      }
      currentAdTagLoader = newAdTagLoader;
      if (newAdTagLoader != null) {
        newAdTagLoader.activate(checkNotNull(player));
      }
    }
  }

  @Nullable
  private AdTagLoader getCurrentAdTagLoader() {
    @Nullable Player player = this.player;
    if (player == null) {
      return null;
    }
    Timeline timeline = player.getCurrentTimeline();
    if (timeline.isEmpty()) {
      return null;
    }
    int periodIndex = player.getCurrentPeriodIndex();
    @Nullable Object adsId = timeline.getPeriod(periodIndex, period).getAdsId();
    if (adsId == null) {
      return null;
    }
    @Nullable AdTagLoader adTagLoader = adTagLoaderByAdsId.get(adsId);
    if (adTagLoader == null || !adTagLoaderByAdsMediaSource.containsValue(adTagLoader)) {
      return null;
    }
    return adTagLoader;
  }

  private void maybePreloadNextPeriodAds() {
    @Nullable Player player = ImaAdsLoader.this.player;
    if (player == null) {
      return;
    }
    Timeline timeline = player.getCurrentTimeline();
    if (timeline.isEmpty()) {
      return;
    }
    int nextPeriodIndex =
        timeline.getNextPeriodIndex(
            player.getCurrentPeriodIndex(),
            period,
            window,
            player.getRepeatMode(),
            player.getShuffleModeEnabled());
    if (nextPeriodIndex == C.INDEX_UNSET) {
      return;
    }
    timeline.getPeriod(nextPeriodIndex, period);
    @Nullable Object nextAdsId = period.getAdsId();
    if (nextAdsId == null) {
      return;
    }
    @Nullable AdTagLoader nextAdTagLoader = adTagLoaderByAdsId.get(nextAdsId);
    if (nextAdTagLoader == null || nextAdTagLoader == currentAdTagLoader) {
      return;
    }
    long periodPositionUs =
        timeline.getPeriodPositionUs(
                window, period, period.windowIndex, /* windowPositionUs= */ C.TIME_UNSET)
            .second;
    nextAdTagLoader.maybePreloadAds(Util.usToMs(periodPositionUs), Util.usToMs(period.durationUs));
  }

  private final class PlayerListenerImpl implements Player.Listener {

    @Override
    public void onTimelineChanged(Timeline timeline, @Player.TimelineChangeReason int reason) {
      if (timeline.isEmpty()) {
        // The player is being reset or contains no media.
        return;
      }
      maybeUpdateCurrentAdTagLoader();
      maybePreloadNextPeriodAds();
    }

    @Override
    public void onPositionDiscontinuity(
        Player.PositionInfo oldPosition,
        Player.PositionInfo newPosition,
        @Player.DiscontinuityReason int reason) {
      maybeUpdateCurrentAdTagLoader();
      maybePreloadNextPeriodAds();
    }

    @Override
    public void onShuffleModeEnabledChanged(boolean shuffleModeEnabled) {
      maybePreloadNextPeriodAds();
    }

    @Override
    public void onRepeatModeChanged(@Player.RepeatMode int repeatMode) {
      maybePreloadNextPeriodAds();
    }
  }

  /**
   * Default {@link ImaUtil.ImaFactory} for non-test usage, which delegates to {@link
   * ImaSdkFactory}.
   */
  private static final class DefaultImaFactory implements ImaUtil.ImaFactory {
    @Override
    public ImaSdkSettings createImaSdkSettings() {
      ImaSdkSettings settings = ImaSdkFactory.getInstance().createImaSdkSettings();
      settings.setLanguage(Util.getSystemLanguageCodes()[0]);
      return settings;
    }

    @Override
    public AdsRenderingSettings createAdsRenderingSettings() {
      return ImaSdkFactory.getInstance().createAdsRenderingSettings();
    }

    @Override
    public AdDisplayContainer createAdDisplayContainer(ViewGroup container, VideoAdPlayer player) {
      return ImaSdkFactory.createAdDisplayContainer(container, player);
    }

    @Override
    public AdDisplayContainer createAudioAdDisplayContainer(Context context, VideoAdPlayer player) {
      return ImaSdkFactory.createAudioAdDisplayContainer(context, player);
    }

    // The reasonDetail parameter to createFriendlyObstruction is annotated @Nullable but the
    // annotation is not kept in the obfuscated dependency.
    @SuppressWarnings(""nullness:argument"")
    @Override
    public FriendlyObstruction createFriendlyObstruction(
        View view,
        FriendlyObstructionPurpose friendlyObstructionPurpose,
        @Nullable String reasonDetail) {
      return ImaSdkFactory.getInstance()
          .createFriendlyObstruction(view, friendlyObstructionPurpose, reasonDetail);
    }

    @Override
    public AdsRequest createAdsRequest() {
      return ImaSdkFactory.getInstance().createAdsRequest();
    }

    @Override
    public com.google.ads.interactivemedia.v3.api.AdsLoader createAdsLoader(
        Context context, ImaSdkSettings imaSdkSettings, AdDisplayContainer adDisplayContainer) {
      return ImaSdkFactory.getInstance()
          .createAdsLoader(context, imaSdkSettings, adDisplayContainer);
    }
  }
}
","oldAdTagLoader
",oldCurrentAdTagLoader,oldAdTagLoader,adTagLoader,adTagLoader,
"package dalvik.system;

import dalvik.system.CloseGuard.Reporter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.ref.WeakReference;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

/**
 * Provides support for detecting issues found by {@link CloseGuard} from within tests.
 *
 * <p>This is a best effort as it relies on both {@link CloseGuard} being enabled and being able to
 * force a GC and finalization, none of which are directly controllable by this.
 *
 * <p>This is loaded using reflection by the AbstractResourceLeakageDetectorTestCase class as that
 * class needs to run on the reference implementation which does not have this class. It implements
 * {@link Runnable} because that is simpler than trying to manage a specialized interface.
 *
 * @hide
 */
public class CloseGuardMonitor implements Runnable {
  /**
   * The {@link Reporter} instance used to receive warnings from {@link CloseGuard}.
   */
  private final Reporter closeGuardReporter;

  /**
   * The list of allocation sites that {@link CloseGuard} has reported as not being released.
   *
   * <p>Is thread safe as this will be called during finalization and so there are no guarantees
   * as to whether it will be called concurrently or not.
   */
  private final List<Throwable> closeGuardAllocationSites = new CopyOnWriteArrayList<>();

  /**
   * Default constructor required for reflection.
   */
  public CloseGuardMonitor() {
    System.logI(""Creating CloseGuard monitor"");

    // Save current reporter.
    closeGuardReporter = CloseGuard.getReporter();

    // Override the reporter with our own which collates the allocation sites.
    CloseGuard.setReporter(new Reporter() {
      @Override
      public void report(String message, Throwable allocationSite) {
        // Ignore message as it's always the same.
        closeGuardAllocationSites.add(allocationSite);
      }
    });
  }

  /**
   * Check to see whether any resources monitored by {@link CloseGuard} were not released before
   * they were garbage collected.
   */
  @Override
  public void run() {
    // Create a weak reference to an object so that we can detect when it is garbage collected.
    WeakReference<Object> reference = new WeakReference<>(new Object());

    try {
      // 'Force' a GC and finalize to cause CloseGuards to report warnings. Doesn't loop
      // forever as there are no guarantees that the following code does anything at all so
      // don't want a potential infinite loop.
      Runtime runtime = Runtime.getRuntime();
      for (int i = 0; i < 20; ++i) {
        runtime.gc();
        System.runFinalization();
        try {
          Thread.sleep(1);
        } catch (InterruptedException e) {
          throw new AssertionError(e);
        }

        // Check to see if the weak reference has been garbage collected.
        if (reference.get() == null) {
          System.logI(""Sentry object has been freed so assuming CloseGuards have reported""
              + "" any resource leakages"");
          break;
        }
      }
    } finally {
      // Restore the reporter.
      CloseGuard.setReporter(closeGuardReporter);
    }

    if (!closeGuardAllocationSites.isEmpty()) {
      StringWriter  [MASK]  = new StringWriter();
      PrintWriter printWriter = new PrintWriter( [MASK] );
      int i = 0;
      for (Throwable allocationSite : closeGuardAllocationSites) {
        printWriter.print(++i);
        printWriter.print("") "");
        allocationSite.printStackTrace(printWriter);
        printWriter.println(""    --------------------------------"");
      }
      throw new AssertionError(""Potential resource leakage detected:\n"" +  [MASK] );
    }
  }
}
","writer
",sStringE,stringWriter,leakageDetails,stringWriter,
"
package android.icu.impl;

import java.lang.reflect.Constructor;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import android.icu.util.Freezable;

/**
 * A Relation is a set of mappings from keys to values.
 * Unlike Map, there is not guaranteed to be a single value per key.
 * The Map-like APIs return collections for values.
 * @author medavis
 * @hide Only a subset of ICU is exposed in Android

 */
public class Relation<K, V> implements Freezable<Relation<K,V>> { // TODO: add , Map<K, Collection<V>>, but requires API changes
    private Map<K, Set<V>> data;

    Constructor<? extends Set<V>> setCreator;
    Object[] setComparatorParam;

    public static <K, V> Relation<K, V> of(Map<K, Set<V>> map, Class<?> setCreator) {
        return new Relation<K, V>(map, setCreator);
    }

    public static <K,V> Relation<K, V> of(Map<K, Set<V>> map, Class<?> setCreator, Comparator<V> setComparator) {
        return new Relation<K, V>(map, setCreator, setComparator);
    }

    public Relation(Map<K, Set<V>> map, Class<?> setCreator) {
        this(map, setCreator, null);
    }

    @SuppressWarnings(""unchecked"")
    public Relation(Map<K, Set<V>> map, Class<?> setCreator, Comparator<V> setComparator) {
        try {
            setComparatorParam = setComparator == null ? null : new Object[]{setComparator};
            if (setComparator == null) {
                this.setCreator = ((Class<? extends Set<V>>)setCreator).getConstructor();
                this.setCreator.newInstance(setComparatorParam); // check to make sure compiles
            } else {
                this.setCreator = ((Class<? extends Set<V>>)setCreator).getConstructor(Comparator.class);
                this.setCreator.newInstance(setComparatorParam); // check to make sure compiles
            }
            data = map == null ? new HashMap<K, Set<V>>() : map;
        } catch (Exception e) {
            throw (RuntimeException) new IllegalArgumentException(""Can't create new set"").initCause(e);
        }
    }

    public void clear() {
        data.clear();
    }

    public boolean containsKey(Object key) {
        return data.containsKey(key);
    }

    public boolean containsValue(Object value) {
        for (Set<V> values : data.values()) {
            if (values.contains(value)) {
                return true;
            }
        }
        return false;
    }

    public final Set<Entry<K, V>> entrySet() {
        return keyValueSet();
    }

    public Set<Entry<K, Set<V>>> keyValuesSet() {
        return data.entrySet();
    }

    public Set<Entry<K, V>> keyValueSet() {
        Set<Entry<K, V>> result = new LinkedHashSet<Entry<K, V>>();
        for (K key : data.keySet()) {
            for (V value : data.get(key)) {
                result.add(new SimpleEntry<K, V>(key, value));
            }
        }
        return result;
    }

    @Override
    public boolean equals(Object o) {
        if (o == null)
            return false;
        if (o.getClass() != this.getClass())
            return false;
        return data.equals(((Relation<?, ?>) o).data);
    }

    //  public V get(Object key) {
    //      Set<V> set = data.get(key);
    //      if (set == null || set.size() == 0)
    //        return null;
    //      return set.iterator().next();
    //  }

    public Set<V> getAll(Object key) {
        return data.get(key);
    }

    public Set<V> get(Object key) {
        return data.get(key);
    }

    @Override
    public int hashCode() {
        return data.hashCode();
    }

    public boolean isEmpty() {
        return data.isEmpty();
    }

    public Set<K> keySet() {
        return data.keySet();
    }

    public V put(K key, V value) {
        Set<V> set = data.get(key);
        if (set == null) {
            data.put(key, set = newSet());
        }
        set.add(value);
        return value;
    }

    public V putAll(K key, Collection<? extends V> values) {
        Set<V> set = data.get(key);
        if (set == null) {
            data.put(key, set = newSet());
        }
        set.addAll(values);
        return values.size() == 0 ? null : values.iterator().next();
    }

    public V putAll(Collection<K> keys, V value) {
        V result = null;
        for (K key : keys) {
            result = put(key, value);
        }
        return result;
    }

    private Set<V> newSet() {
        try {
            return setCreator.newInstance(setComparatorParam);
        } catch (Exception e) {
            throw (RuntimeException) new IllegalArgumentException(""Can't create new set"").initCause(e);
        }
    }

    public void putAll(Map<? extends K, ? extends V> t) {
        for (Map.Entry<? extends K, ? extends V> entry : t.entrySet()) {
            put(entry.getKey(), entry.getValue());
        }
    }

    public void putAll(Relation<? extends K, ? extends V> t) {
        for (K key : t.keySet()) {
            for (V value : t.getAll(key)) {
                put(key, value);
            }
        }
    }

    public Set<V> removeAll(K key) {
        try {
            return data.remove(key);
        } catch (NullPointerException e) {
            return null; // data doesn't allow null, eg ConcurrentHashMap
        }
    }

    public boolean remove(K key, V value) {
        try {
            Set<V> set = data.get(key);
            if (set == null) {
                return false;
            }
            boolean result = set.remove(value);
            if (set.size() == 0) {
                data.remove(key);
            }
            return result;
        } catch (NullPointerException e) {
            return false; // data doesn't allow null, eg ConcurrentHashMap
        }
    }

    public int size() {
        return data.size();
    }

    public Set<V> values() {
        return values(new LinkedHashSet<V>());
    }

    public <C extends Collection<V>> C values(C result) {
        for (Entry<K, Set<V>> keyValue : data.entrySet()) {
            result.addAll(keyValue.getValue());
        }
        return result;
    }

    @Override
    public String toString() {
        return data.toString();
    }

    static class SimpleEntry<K, V> implements Entry<K, V> {
        K key;

        V value;

        public SimpleEntry(K key, V value) {
            this.key = key;
            this.value = value;
        }

        public SimpleEntry(Entry<K, V> e) {
            this.key = e.getKey();
            this.value = e.getValue();
        }

        @Override
        public K getKey() {
            return key;
        }

        @Override
        public V getValue() {
            return value;
        }

        @Override
        public V setValue(V value) {
            V oldValue = this.value;
            this.value = value;
            return oldValue;
        }
    }

    public Relation<K,V> addAllInverted(Relation<V,K> source) {
        for (V value : source.data.keySet()) {
            for (K key : source.data.get(value)) {
                put(key, value);
            }
        }
        return this;
    }

    public Relation<K,V> addAllInverted(Map<V,K> source) {
        for (Map.Entry<V,K> entry : source.entrySet()) {
            put(entry.getValue(), entry.getKey());
        }
        return this;
    }

    volatile boolean frozen = false;

    @Override
    public boolean isFrozen() {
        return frozen;
    }

    @Override
    public Relation<K, V> freeze() {
        if (!frozen) {
            // does not handle one level down, so we do that on a case-by-case basis
            for (K key : data.keySet()) {
                data.put(key, Collections.unmodifiableSet(data.get(key)));
            }
            // now do top level
            data = Collections.unmodifiableMap(data);
            frozen = true;
        }
        return this;
    }

    @Override
    public Relation<K, V> cloneAsThawed() {
        // TODO do later
        throw new UnsupportedOperationException();
    }

    public boolean removeAll(Relation<K, V> toBeRemoved) {
        boolean result = false;
        for (K key : toBeRemoved.keySet()) {
            try {
                Set<V> values = toBeRemoved.getAll(key);
                if (values != null) {
                    result |= removeAll(key, values);
                }
            } catch (NullPointerException e) {
                // data doesn't allow null, eg ConcurrentHashMap
            }
        }
        return result;
    }

    public Set<V> removeAll(K... keys) {
        return removeAll(Arrays.asList(keys));
    }

    public boolean removeAll(K key, Iterable<V> toBeRemoved) {
        boolean result = false;
        for (V value : toBeRemoved) {
            result |= remove(key, value);
        }
        return result;
    }

    public Set<V> removeAll(Collection<K> toBeRemoved) {
        Set<V> result = new LinkedHashSet<V>();
        for (K key : toBeRemoved) {
            try {
                final Set<V>  [MASK]  = data.remove(key);
                if ( [MASK]  != null) {
                    result.addAll( [MASK] );
                }
            } catch (NullPointerException e) {
                // data doesn't allow null, eg ConcurrentHashMap
            }
        }
        return result;
    }
}
","removals
",toSet,cachedKeyRemoveSet,removedValues,values,
"
package com.google.devtools.build.lib.skyframe;

import static com.google.common.collect.ImmutableList.toImmutableList;
import static com.google.devtools.build.lib.analysis.AspectResolutionHelpers.aspectMatchesConfiguredTarget;
import static com.google.devtools.build.lib.skyframe.DependencyResolver.createDefaultToolchainContextKey;
import static com.google.devtools.build.lib.skyframe.DependencyResolver.getPrioritizedDetailedExitCode;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.devtools.build.lib.actions.ActionLookupKey;
import com.google.devtools.build.lib.actions.MutableActionGraph.ActionConflictException;
import com.google.devtools.build.lib.analysis.AliasProvider;
import com.google.devtools.build.lib.analysis.AspectValue;
import com.google.devtools.build.lib.analysis.CachingAnalysisEnvironment;
import com.google.devtools.build.lib.analysis.CachingAnalysisEnvironment.MissingDepException;
import com.google.devtools.build.lib.analysis.ConfiguredAspect;
import com.google.devtools.build.lib.analysis.ConfiguredAspectFactory;
import com.google.devtools.build.lib.analysis.ConfiguredTarget;
import com.google.devtools.build.lib.analysis.ConfiguredTargetValue;
import com.google.devtools.build.lib.analysis.DependencyKind;
import com.google.devtools.build.lib.analysis.DuplicateException;
import com.google.devtools.build.lib.analysis.ExecGroupCollection;
import com.google.devtools.build.lib.analysis.ExecGroupCollection.InvalidExecGroupException;
import com.google.devtools.build.lib.analysis.IncompatiblePlatformProvider;
import com.google.devtools.build.lib.analysis.InconsistentAspectOrderException;
import com.google.devtools.build.lib.analysis.ResolvedToolchainContext;
import com.google.devtools.build.lib.analysis.TargetAndConfiguration;
import com.google.devtools.build.lib.analysis.ToolchainCollection;
import com.google.devtools.build.lib.analysis.TransitiveDependencyState;
import com.google.devtools.build.lib.analysis.TransitiveDependencyState.PrerequisitePackageFunction;
import com.google.devtools.build.lib.analysis.config.BuildConfigurationValue;
import com.google.devtools.build.lib.analysis.config.ConfigConditions;
import com.google.devtools.build.lib.analysis.config.DependencyEvaluationException;
import com.google.devtools.build.lib.analysis.configuredtargets.MergedConfiguredTarget;
import com.google.devtools.build.lib.analysis.producers.DependencyContext;
import com.google.devtools.build.lib.analysis.producers.DependencyContextProducer;
import com.google.devtools.build.lib.analysis.producers.UnloadedToolchainContextsInputs;
import com.google.devtools.build.lib.analysis.starlark.StarlarkAttributeTransitionProvider;
import com.google.devtools.build.lib.bugreport.BugReport;
import com.google.devtools.build.lib.causes.Cause;
import com.google.devtools.build.lib.causes.LabelCause;
import com.google.devtools.build.lib.cmdline.Label;
import com.google.devtools.build.lib.cmdline.PackageIdentifier;
import com.google.devtools.build.lib.collect.nestedset.NestedSet;
import com.google.devtools.build.lib.collect.nestedset.NestedSetBuilder;
import com.google.devtools.build.lib.events.Event;
import com.google.devtools.build.lib.events.StoredEventHandler;
import com.google.devtools.build.lib.packages.Aspect;
import com.google.devtools.build.lib.packages.AspectDefinition;
import com.google.devtools.build.lib.packages.Attribute;
import com.google.devtools.build.lib.packages.BuildFileContainsErrorsException;
import com.google.devtools.build.lib.packages.NativeAspectClass;
import com.google.devtools.build.lib.packages.NoSuchTargetException;
import com.google.devtools.build.lib.packages.NoSuchThingException;
import com.google.devtools.build.lib.packages.OutputFile;
import com.google.devtools.build.lib.packages.Package;
import com.google.devtools.build.lib.packages.Rule;
import com.google.devtools.build.lib.packages.StarlarkAspectClass;
import com.google.devtools.build.lib.packages.StarlarkDefinedAspect;
import com.google.devtools.build.lib.packages.Target;
import com.google.devtools.build.lib.packages.semantics.BuildLanguageOptions;
import com.google.devtools.build.lib.profiler.memory.CurrentRuleTracker;
import com.google.devtools.build.lib.skyframe.AspectKeyCreator.AspectKey;
import com.google.devtools.build.lib.skyframe.BzlLoadFunction.BzlLoadFailedException;
import com.google.devtools.build.lib.skyframe.ConfiguredTargetEvaluationExceptions.UnreportedException;
import com.google.devtools.build.lib.skyframe.SkyframeExecutor.BuildViewProvider;
import com.google.devtools.build.lib.skyframe.toolchains.ToolchainException;
import com.google.devtools.build.lib.skyframe.toolchains.UnloadedToolchainContext;
import com.google.devtools.build.lib.util.OrderedSetMultimap;
import com.google.devtools.build.skyframe.SkyFunction;
import com.google.devtools.build.skyframe.SkyFunction.Environment.SkyKeyComputeState;
import com.google.devtools.build.skyframe.SkyFunctionException;
import com.google.devtools.build.skyframe.SkyKey;
import com.google.devtools.build.skyframe.SkyValue;
import com.google.devtools.build.skyframe.SkyframeLookupResult;
import com.google.devtools.build.skyframe.state.Driver;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;
import net.starlark.java.eval.StarlarkSemantics;

/**
 * The Skyframe function that generates aspects.
 *
 * <p>This class, together with {@link ConfiguredTargetFunction} drives the analysis phase. For more
 * information, see {@link com.google.devtools.build.lib.analysis.RuleConfiguredTargetFactory}.
 *
 * <p>{@link AspectFunction} takes a SkyKey containing an {@link AspectKey} [a tuple of (target
 * label, configurations, aspect class and aspect parameters)], loads an {@link Aspect} from aspect
 * class and aspect parameters, gets a {@link ConfiguredTarget} for label and configurations, and
 * then creates a {@link ConfiguredAspect} for a given {@link AspectKey}.
 *
 * <p>See {@link com.google.devtools.build.lib.packages.AspectClass} documentation for an overview
 * of aspect-related classes
 *
 * @see com.google.devtools.build.lib.analysis.RuleConfiguredTargetFactory
 * @see com.google.devtools.build.lib.packages.AspectClass
 */
final class AspectFunction implements SkyFunction {
  private final BuildViewProvider buildViewProvider;
  /**
   * Indicates whether the set of packages transitively loaded for a given {@link AspectValue} will
   * be needed later (see {@link
   * com.google.devtools.build.lib.analysis.ConfiguredObjectValue#getTransitivePackages}). If not,
   * they are not collected and stored.
   */
  private final boolean storeTransitivePackages;

  /**
   * Packages of prerequistes.
   *
   * <p>See {@link ConfiguredTargetFunction#prerequisitePackages} for more details.
   */
  private final PrerequisitePackageFunction prerequisitePackages;

  AspectFunction(
      BuildViewProvider buildViewProvider,
      boolean storeTransitivePackages,
      PrerequisitePackageFunction prerequisitePackages) {
    this.buildViewProvider = buildViewProvider;
    this.storeTransitivePackages = storeTransitivePackages;
    this.prerequisitePackages = prerequisitePackages;
  }

  static class State implements SkyKeyComputeState {
    @Nullable InitialValues initialValues;

    final DependencyResolver.State computeDependenciesState;

    private State(
        boolean storeTransitivePackages, PrerequisitePackageFunction prerequisitePackages) {
      this.computeDependenciesState =
          new DependencyResolver.State(storeTransitivePackages, prerequisitePackages);
    }
  }

  private static class InitialValues {
    @Nullable private final Aspect aspect;
    @Nullable private final ConfiguredAspectFactory aspectFactory;
    private final ConfiguredTarget baseConfiguredTarget;

    private InitialValues(
        @Nullable Aspect aspect,
        @Nullable ConfiguredAspectFactory aspectFactory,
        ConfiguredTarget baseConfiguredTarget) {
      this.aspect = aspect;
      this.aspectFactory = aspectFactory;
      this.baseConfiguredTarget = baseConfiguredTarget;
    }
  }

  @Nullable
  @Override
  public SkyValue compute(SkyKey skyKey, Environment env)
      throws AspectFunctionException, InterruptedException {
    AspectKey key = (AspectKey) skyKey.argument();
    State state = env.getState(() -> new State(storeTransitivePackages, prerequisitePackages));

    DependencyResolver.State computeDependenciesState = state.computeDependenciesState;
    if (state.initialValues == null) {
      InitialValues initialValues = getInitialValues(computeDependenciesState, key, env);
      if (initialValues == null) {
        return null;
      }
      state.initialValues = initialValues;
    }
    Aspect aspect = state.initialValues.aspect;
    ConfiguredAspectFactory aspectFactory = state.initialValues.aspectFactory;
    ConfiguredTarget associatedTarget = state.initialValues.baseConfiguredTarget;
    TargetAndConfiguration targetAndConfiguration = computeDependenciesState.targetAndConfiguration;
    Target target = targetAndConfiguration.getTarget();
    BuildConfigurationValue configuration = targetAndConfiguration.getConfiguration();

    // If the target is incompatible, then there's not much to do. The intent here is to create an
    // AspectValue that doesn't trigger any of the associated target's dependencies to be evaluated
    // against this aspect.
    if (associatedTarget.get(IncompatiblePlatformProvider.PROVIDER) != null
        ||
        // Similarly, aspects that propagate into post-NoConfigTransition targets can't access
        // most flags or dependencies and are likely to be unsound. So make aspects propagating to
        // these configurations no-ops.
        (configuration != null && configuration.getOptions().hasNoConfig())) {
      return AspectValue.create(
          key,
          aspect,
          ConfiguredAspect.forNonapplicableTarget(),
          computeDependenciesState.transitivePackages());
    }

    if (AliasProvider.isAlias(associatedTarget)) {
      return createAliasAspect(
          env,
          targetAndConfiguration,
          aspect,
          key,
          associatedTarget,
          computeDependenciesState.transitiveState);
    }
    // If we get here, label should match original label, and therefore the target we looked up
    // above indeed corresponds to associatedTarget.getLabel().
    Preconditions.checkState(
        associatedTarget.getOriginalLabel().equals(associatedTarget.getLabel()),
        ""Non-alias %s should have matching label but found %s"",
        associatedTarget.getOriginalLabel(),
        associatedTarget.getLabel());

    // If the incompatible flag is set, the top-level aspect should not be applied on top-level
    // targets whose rules do not advertise the aspect's required providers. The aspect should not
    // also propagate to these targets dependencies.
    StarlarkSemantics starlarkSemantics = PrecomputedValue.STARLARK_SEMANTICS.get(env);
    if (starlarkSemantics == null) {
      return null;
    }
    boolean checkRuleAdvertisedProviders =
        starlarkSemantics.getBool(
            BuildLanguageOptions.INCOMPATIBLE_TOP_LEVEL_ASPECTS_REQUIRE_PROVIDERS);
    if (checkRuleAdvertisedProviders) {
      if (target instanceof Rule) {
        if (!aspect
            .getDefinition()
            .getRequiredProviders()
            .isSatisfiedBy(((Rule) target).getRuleClassObject().getAdvertisedProviders())) {
          return AspectValue.create(
              key,
              aspect,
              ConfiguredAspect.forNonapplicableTarget(),
              computeDependenciesState.transitivePackages());
        }
      }
    }

    ImmutableList<Aspect> topologicalAspectPath;
    if (key.getBaseKeys().isEmpty()) {
      topologicalAspectPath = ImmutableList.of(aspect);
    } else {
      LinkedHashSet<AspectKey> orderedKeys = new LinkedHashSet<>();
      collectAspectKeysInTopologicalOrder(key.getBaseKeys(), orderedKeys);
      SkyframeLookupResult aspectValues = env.getValuesAndExceptions(orderedKeys);
      if (env.valuesMissing()) {
        return null;
      }
      ImmutableList.Builder<Aspect>  [MASK]  =
          ImmutableList.builderWithExpectedSize(orderedKeys.size() + 1);
      for (AspectKey aspectKey : orderedKeys) {
        AspectValue aspectValue = (AspectValue) aspectValues.get(aspectKey);
        if (aspectValue == null) {
          BugReport.logUnexpected(
              ""aspectValue for: '%s' was missing, this should never happen"", aspectKey);
          return null;
        }
         [MASK] .add(aspectValue.getAspect());
      }
      topologicalAspectPath =  [MASK] .add(aspect).build();

      List<ConfiguredAspect> directlyRequiredAspects =
          Lists.transform(key.getBaseKeys(), k -> ((AspectValue) aspectValues.get(k)));
      try {
        associatedTarget = MergedConfiguredTarget.of(associatedTarget, directlyRequiredAspects);
      } catch (DuplicateException e) {
        env.getListener().handle(Event.error(target.getLocation(), e.getMessage()));
        throw new AspectFunctionException(
            new AspectCreationException(e.getMessage(), target.getLabel(), configuration));
      }
    }

    try {
      var dependencyContext = getDependencyContext(computeDependenciesState, key, aspect, env);
      if (dependencyContext == null) {
        return null;
      }

      Optional<StarlarkAttributeTransitionProvider> starlarkExecTransition;
      try {
        starlarkExecTransition =
            DependencyResolver.loadStarlarkExecTransition(targetAndConfiguration, env);
        if (starlarkExecTransition == null) {
          return null; // Need Skyframe deps.
        }
      } catch (UnreportedException e) {
        throw new AspectCreationException(e.getMessage(), key.getLabel(), configuration);
      }

      OrderedSetMultimap<DependencyKind, ConfiguredTargetAndData> depValueMap =
          DependencyResolver.computeDependencies(
              computeDependenciesState,
              ConfiguredTargetKey.fromConfiguredTarget(associatedTarget),
              topologicalAspectPath,
              buildViewProvider.getSkyframeBuildView().getStarlarkTransitionCache(),
              starlarkExecTransition.orElse(null),
              env,
              env.getListener());
      if (!computeDependenciesState.transitiveRootCauses().isEmpty()) {
        NestedSet<Cause> causes = computeDependenciesState.transitiveRootCauses().build();
        throw new AspectFunctionException(
            new AspectCreationException(
                ""Loading failed"", causes, getPrioritizedDetailedExitCode(causes)));
      }
      if (depValueMap == null) {
        return null;
      }

      // Load the requested toolchains into the ToolchainContext, now that we have dependencies.
      ToolchainCollection<UnloadedToolchainContext> unloadedToolchainContexts =
          dependencyContext.unloadedToolchainContexts();
      ToolchainCollection<ResolvedToolchainContext> toolchainContexts = null;
      if (unloadedToolchainContexts != null) {
        String targetDescription =
            ""aspect "" + aspect.getDescriptor().getDescription() + "" applied to "" + target;
        ToolchainCollection.Builder<ResolvedToolchainContext> contextsBuilder =
            ToolchainCollection.builder();
        for (Map.Entry<String, UnloadedToolchainContext> unloadedContext :
            unloadedToolchainContexts.getContextMap().entrySet()) {
          ImmutableSet<ConfiguredTargetAndData> toolchainDependencies =
              ImmutableSet.copyOf(
                  depValueMap.get(DependencyKind.forExecGroup(unloadedContext.getKey())));
          contextsBuilder.addContext(
              unloadedContext.getKey(),
              ResolvedToolchainContext.load(
                  unloadedContext.getValue(), targetDescription, toolchainDependencies));
        }
        toolchainContexts = contextsBuilder.build();
      }

      return createAspect(
          env,
          key,
          topologicalAspectPath,
          aspect,
          aspectFactory,
          target,
          associatedTarget,
          configuration,
          dependencyContext.configConditions(),
          toolchainContexts,
          computeDependenciesState.execGroupCollectionBuilder,
          depValueMap,
          computeDependenciesState.transitiveState);
    } catch (DependencyEvaluationException e) {
      // TODO(bazel-team): consolidate all env.getListener().handle() calls in this method, like in
      // ConfiguredTargetFunction. This encourages clear, consistent user messages (ideally without
      // the programmer having to think about it).
      if (!e.depReportedOwnError()) {
        env.getListener().handle(Event.error(e.getLocation(), e.getMessage()));
      }
      if (e.getCause() instanceof ConfiguredValueCreationException) {
        ConfiguredValueCreationException cause = (ConfiguredValueCreationException) e.getCause();
        throw new AspectFunctionException(
            new AspectCreationException(
                cause.getMessage(), cause.getRootCauses(), cause.getDetailedExitCode()));
      }
      // Cast to InconsistentAspectOrderException as a consistency check. If you add any
      // DependencyEvaluationException constructors, you may need to change this code, too.
      InconsistentAspectOrderException cause = (InconsistentAspectOrderException) e.getCause();
      env.getListener().handle(Event.error(cause.getLocation(), cause.getMessage()));
      throw new AspectFunctionException(
          new AspectCreationException(cause.getMessage(), key.getLabel(), configuration));
    } catch (AspectCreationException e) {
      throw new AspectFunctionException(e);
    } catch (ConfiguredValueCreationException e) {
      throw new AspectFunctionException(e);
    } catch (ToolchainException e) {
      throw new AspectFunctionException(
          new AspectCreationException(
              e.getMessage(), new LabelCause(key.getLabel(), e.getDetailedExitCode())));
    }
  }

  /** Populates {@code state.execGroupCollection} as a side effect. */
  @Nullable // Null if a Skyframe restart is needed.
  private DependencyContext getDependencyContext(
      DependencyResolver.State state, AspectKey key, Aspect aspect, Environment env)
      throws InterruptedException, ConfiguredValueCreationException, ToolchainException {
    if (state.dependencyContext != null) {
      return state.dependencyContext;
    }
    if (state.dependencyContextProducer == null) {
      TargetAndConfiguration targetAndConfiguration = state.targetAndConfiguration;
      UnloadedToolchainContextsInputs unloadedToolchainContextsInputs =
          getUnloadedToolchainContextsInputs(
              aspect.getDefinition(),
              key.getConfigurationKey(),
              targetAndConfiguration.getConfiguration());
      state.execGroupCollectionBuilder = unloadedToolchainContextsInputs;
      state.dependencyContextProducer =
          new Driver(
              new DependencyContextProducer(
                  unloadedToolchainContextsInputs,
                  targetAndConfiguration,
                  key.getConfigurationKey(),
                  state.transitiveState,
                  (DependencyContextProducer.ResultSink) state));
    }
    if (state.dependencyContextProducer.drive(env)) {
      state.dependencyContextProducer = null;
    }

    // During error bubbling, the state machine might not be done, but still emit an error.
    var error = state.dependencyContextError;
    if (error != null) {
      switch (error.kind()) {
        case TOOLCHAIN:
          throw error.toolchain();
        case CONFIGURED_VALUE_CREATION:
          throw error.configuredValueCreation();
        case INCOMPATIBLE_TARGET:
          throw new IllegalStateException(""Unexpected error: "" + error.incompatibleTarget());
        case VALIDATION:
          throw new IllegalStateException(""Unexpected error: "" + error.validation());
      }
      throw new IllegalStateException(""unreachable"");
    }

    return state.dependencyContext; // Null if not yet done.
  }

  static BzlLoadValue.Key bzlLoadKeyForStarlarkAspect(StarlarkAspectClass starlarkAspectClass) {
    Label extensionLabel = starlarkAspectClass.getExtensionLabel();
    return StarlarkBuiltinsValue.isBuiltinsRepo(extensionLabel.getRepository())
        ? BzlLoadValue.keyForBuiltins(extensionLabel)
        : BzlLoadValue.keyForBuild(extensionLabel);
  }

  @Nullable
  private static InitialValues getInitialValues(
      DependencyResolver.State state, AspectKey key, Environment env)
      throws AspectFunctionException, InterruptedException {
    ActionLookupKey configuredTargetLookupKey = key.getBaseConfiguredTargetKey();
    PackageIdentifier basePackageKey =
        key.getBaseConfiguredTargetKey().getLabel().getPackageIdentifier();
    var initialKeys =
        ImmutableSet.<SkyKey>builder().add(configuredTargetLookupKey).add(basePackageKey);

    BuildConfigurationKey configurationKey = key.getConfigurationKey();
    if (configurationKey != null) {
      initialKeys.add(configurationKey);
    }

    StarlarkAspectClass starlarkAspectClass;
    BzlLoadValue.Key bzlLoadKey;
    if (key.getAspectClass() instanceof NativeAspectClass) {
      starlarkAspectClass = null;
      bzlLoadKey = null;
    } else {
      Preconditions.checkState(
          key.getAspectClass() instanceof StarlarkAspectClass, ""Unknown aspect class: %s"", key);
      starlarkAspectClass = (StarlarkAspectClass) key.getAspectClass();
      initialKeys.add(bzlLoadKey = bzlLoadKeyForStarlarkAspect(starlarkAspectClass));
    }

    SkyframeLookupResult initialValues = env.getValuesAndExceptions(initialKeys.build());
    if (env.valuesMissing()) {
      return null;
    }

    ConfiguredTarget baseConfiguredTarget;
    try {
      var baseConfiguredTargetValue =
          (ConfiguredTargetValue)
              initialValues.getOrThrow(
                  configuredTargetLookupKey, ConfiguredValueCreationException.class);
      if (baseConfiguredTargetValue == null) {
        BugReport.logUnexpected(
            ""Unexpected exception with %s and AspectKey %s"", key.getBaseConfiguredTargetKey(), key);
        return null;
      }
      baseConfiguredTarget = baseConfiguredTargetValue.getConfiguredTarget();
    } catch (ConfiguredValueCreationException e) {
      throw new AspectFunctionException(
          new AspectCreationException(e.getMessage(), e.getRootCauses(), e.getDetailedExitCode()));
    }
    Preconditions.checkState(
        Objects.equals(key.getConfigurationKey(), baseConfiguredTarget.getConfigurationKey()),
        ""Aspect not in same configuration as base configured target: %s, %s"",
        key,
        baseConfiguredTarget);

    // Keep this in sync with the same code in ConfiguredTargetFunction.
    Package basePackage = ((PackageValue) initialValues.get(basePackageKey)).getPackage();
    if (basePackage.containsErrors()) {
      throw new AspectFunctionException(
          new BuildFileContainsErrorsException(key.getLabel().getPackageIdentifier()));
    }
    Target target;
    try {
      target = basePackage.getTarget(baseConfiguredTarget.getOriginalLabel().getName());
    } catch (NoSuchTargetException e) {
      throw new IllegalStateException(""Name already verified"", e);
    }

    BuildConfigurationValue configuration =
        configurationKey == null
            ? null
            : (BuildConfigurationValue) initialValues.get(configurationKey);

    state.targetAndConfiguration = new TargetAndConfiguration(target, configuration);

    ConfiguredAspectFactory aspectFactory;
    Aspect aspect;
    if (bzlLoadKey == null) {
      NativeAspectClass nativeAspectClass = (NativeAspectClass) key.getAspectClass();
      aspectFactory = (ConfiguredAspectFactory) nativeAspectClass;
      aspect = Aspect.forNative(nativeAspectClass, key.getParameters());
    } else {
      StarlarkDefinedAspect starlarkAspect;
      try {
        BzlLoadValue bzlLoadvalue;
        try {
          bzlLoadvalue =
              (BzlLoadValue) initialValues.getOrThrow(bzlLoadKey, BzlLoadFailedException.class);
          if (bzlLoadvalue == null) {
            BugReport.logUnexpected(
                ""Unexpected exception with %s and AspectKey %s"", bzlLoadKey, key);
            return null;
          }
        } catch (BzlLoadFailedException e) {
          throw new AspectCreationException(
              e.getMessage(), starlarkAspectClass.getExtensionLabel(), e.getDetailedExitCode());
        }
        starlarkAspect = loadAspectFromBzl(starlarkAspectClass, bzlLoadvalue);
      } catch (AspectCreationException e) {
        env.getListener().handle(Event.error(e.getMessage()));
        throw new AspectFunctionException(e);
      }
      aspectFactory = new StarlarkAspectFactory(starlarkAspect);
      aspect =
          Aspect.forStarlark(
              starlarkAspect.getAspectClass(),
              starlarkAspect.getDefinition(key.getParameters()),
              key.getParameters());
    }

    return new InitialValues(aspect, aspectFactory, baseConfiguredTarget);
  }

  /**
   * Loads a Starlark-defined aspect from an extension file.
   *
   * @throws AspectCreationException if the value loaded is not a {@link StarlarkDefinedAspect}
   */
  static StarlarkDefinedAspect loadAspectFromBzl(
      StarlarkAspectClass starlarkAspectClass, BzlLoadValue bzlLoadValue)
      throws AspectCreationException {
    Label extensionLabel = starlarkAspectClass.getExtensionLabel();
    String starlarkValueName = starlarkAspectClass.getExportedName();
    Object starlarkValue = bzlLoadValue.getModule().getGlobal(starlarkValueName);
    if (!(starlarkValue instanceof StarlarkDefinedAspect)) {
      throw new AspectCreationException(
          String.format(
              starlarkValue == null ? ""%s is not exported from %s"" : ""%s from %s is not an aspect"",
              starlarkValueName,
              extensionLabel),
          extensionLabel);
    }
    return (StarlarkDefinedAspect) starlarkValue;
  }

  @Nullable
  private static UnloadedToolchainContextsInputs getUnloadedToolchainContextsInputs(
      AspectDefinition aspectDefinition,
      @Nullable BuildConfigurationKey configurationKey,
      @Nullable BuildConfigurationValue configuration) {
    if (configuration == null) {
      // Configuration can be null in the case of aspects applied to input files. In this case,
      // there are no toolchains being used.
      return UnloadedToolchainContextsInputs.empty();
    }

    boolean useAutoExecGroups = shouldUseAutoExecGroups(aspectDefinition, configuration);
    var processedExecGroups =
        ExecGroupCollection.process(
            aspectDefinition.execGroups(),
            aspectDefinition.execCompatibleWith(),
            aspectDefinition.getToolchainTypes(),
            useAutoExecGroups);
    // Note: `configuration.getOptions().hasNoConfig()` is handled early in #compute.
    return UnloadedToolchainContextsInputs.create(
        processedExecGroups,
        createDefaultToolchainContextKey(
            configurationKey,
            aspectDefinition.execCompatibleWith(),
            /* debugTarget= */ false,
            /* useAutoExecGroups= */ useAutoExecGroups,
            aspectDefinition.getToolchainTypes(),
            /* parentExecutionPlatformLabel= */ null));
  }

  private static boolean shouldUseAutoExecGroups(
      AspectDefinition aspectDefinition, BuildConfigurationValue configuration) {
    ImmutableMap<String, Attribute> aspectAttributes = aspectDefinition.getAttributes();
    if (aspectAttributes.containsKey(""$use_auto_exec_groups"")) {
      return (boolean) aspectAttributes.get(""$use_auto_exec_groups"").getDefaultValueUnchecked();
    }
    return configuration.useAutoExecGroups();
  }

  /**
   * Collects {@link AspectKey} dependencies by performing a postorder traversal over {@link
   * AspectKey#getBaseKeys}.
   *
   * <p>The resulting set of {@code orderedKeys} is topologically ordered: each aspect key appears
   * after all of its dependencies.
   */
  private static void collectAspectKeysInTopologicalOrder(
      List<AspectKey> baseKeys, LinkedHashSet<AspectKey> orderedKeys) {
    for (AspectKey key : baseKeys) {
      if (!orderedKeys.contains(key)) {
        collectAspectKeysInTopologicalOrder(key.getBaseKeys(), orderedKeys);
        orderedKeys.add(key);
      }
    }
  }

  /**
   * Computes the given aspectKey of an alias-like target, by depending on the corresponding key of
   * the next target in the alias chain (if there are more), or the ""real"" configured target.
   */
  @Nullable
  private AspectValue createAliasAspect(
      Environment env,
      TargetAndConfiguration targetAndConfiguration,
      Aspect aspect,
      AspectKey originalKey,
      ConfiguredTarget baseConfiguredTarget,
      TransitiveDependencyState transitiveState)
      throws InterruptedException {
    ImmutableList<Label> aliasChain =
        baseConfiguredTarget.getProvider(AliasProvider.class).getAliasChain();

    AspectKey actualKey;
    if (aliasChain.size() > 1) {
      // If there is another alias in the chain, follows it, creating the next alias aspect.
      actualKey =
          buildAliasAspectKey(
              originalKey, aliasChain.get(1), baseConfiguredTarget.getConfigurationKey());
    } else {
      // Otherwise, creates an aspect of the real configured target using its real configuration key
      // which includes any transitions.
      actualKey =
          buildAliasAspectKey(
              originalKey,
              baseConfiguredTarget.getLabel(),
              baseConfiguredTarget.getActual().getConfigurationKey());
    }

    return createAliasAspect(
        env, targetAndConfiguration.getTarget(), originalKey, aspect, actualKey, transitiveState);
  }

  @Nullable
  private AspectValue createAliasAspect(
      Environment env,
      Target originalTarget,
      AspectKey originalKey,
      Aspect aspect,
      AspectKey depKey,
      TransitiveDependencyState transitiveState)
      throws InterruptedException {
    // Compute the AspectValue of the target the alias refers to (which can itself be either an
    // alias or a real target)
    AspectValue real = (AspectValue) env.getValue(depKey);
    if (env.valuesMissing()) {
      return null;
    }

    NestedSet<Package> transitivePackages =
        storeTransitivePackages
            ? NestedSetBuilder.<Package>stableOrder()
                .add(originalTarget.getPackage())
                .addTransitive(transitiveState.transitivePackages())
                .addTransitive(real.getTransitivePackages())
                .build()
            : null;
    return AspectValue.create(
        originalKey,
        aspect,
        ConfiguredAspect.forAlias(real),
        transitivePackages);
  }

  private static AspectKey buildAliasAspectKey(
      AspectKey originalKey, Label aliasLabel, BuildConfigurationKey configurationKey) {
    ImmutableList<AspectKey> aliasedBaseKeys =
        originalKey.getBaseKeys().stream()
            .map(baseKey -> buildAliasAspectKey(baseKey, aliasLabel, configurationKey))
            .collect(toImmutableList());
    return AspectKeyCreator.createAspectKey(
        originalKey.getAspectDescriptor(),
        aliasedBaseKeys,
        ConfiguredTargetKey.builder()
            .setLabel(aliasLabel)
            .setConfigurationKey(configurationKey)
            .build());
  }

  @Nullable
  private AspectValue createAspect(
      Environment env,
      AspectKey key,
      ImmutableList<Aspect> topologicalAspectPath,
      Aspect aspect,
      ConfiguredAspectFactory aspectFactory,
      Target associatedTarget,
      ConfiguredTarget associatedConfiguredTarget,
      BuildConfigurationValue configuration,
      ConfigConditions configConditions,
      @Nullable ToolchainCollection<ResolvedToolchainContext> toolchainContexts,
      @Nullable ExecGroupCollection.Builder execGroupCollectionBuilder,
      OrderedSetMultimap<DependencyKind, ConfiguredTargetAndData> directDeps,
      TransitiveDependencyState transitiveState)
      throws AspectFunctionException, InterruptedException {
    // Should be successfully evaluated and cached from the loading phase.
    StarlarkBuiltinsValue starlarkBuiltinsValue =
        (StarlarkBuiltinsValue) env.getValue(StarlarkBuiltinsValue.key());
    if (env.valuesMissing()) {
      return null;
    }

    SkyframeBuildView view = buildViewProvider.getSkyframeBuildView();

    StoredEventHandler events = new StoredEventHandler();
    CachingAnalysisEnvironment analysisEnvironment =
        view.createAnalysisEnvironment(key, events, env, configuration, starlarkBuiltinsValue);

    ConfiguredAspect configuredAspect;
    if (aspect.getDefinition().applyToGeneratingRules() && associatedTarget instanceof OutputFile) {
      OutputFile outputFile = (OutputFile) associatedTarget;
      Label label = outputFile.getGeneratingRule().getLabel();
      return createAliasAspect(
          env, associatedTarget, key, aspect, key.withLabel(label), transitiveState);
    } else if (aspectMatchesConfiguredTarget(
        associatedConfiguredTarget, associatedTarget instanceof Rule, aspect)) {
      try {
        CurrentRuleTracker.beginConfiguredAspect(aspect.getAspectClass());
        configuredAspect =
            view.getConfiguredTargetFactory()
                .createAspect(
                    analysisEnvironment,
                    associatedTarget,
                    associatedConfiguredTarget,
                    topologicalAspectPath,
                    aspectFactory,
                    aspect,
                    directDeps,
                    configConditions,
                    toolchainContexts,
                    execGroupCollectionBuilder,
                    configuration,
                    transitiveState.transitivePackages(),
                    key);
      } catch (MissingDepException e) {
        Preconditions.checkState(env.valuesMissing());
        return null;
      } catch (ActionConflictException e) {
        throw new AspectFunctionException(e);
      } catch (InvalidExecGroupException e) {
        throw new AspectFunctionException(e);
      } finally {
        CurrentRuleTracker.endConfiguredAspect();
      }
    } else {
      configuredAspect = ConfiguredAspect.forNonapplicableTarget();
    }

    events.replayOn(env.getListener());
    if (events.hasErrors()) {
      analysisEnvironment.disable(associatedTarget);
      String msg = ""Analysis of target '"" + associatedTarget.getLabel() + ""' failed"";
      throw new AspectFunctionException(
          new AspectCreationException(msg, key.getLabel(), configuration));
    }
    Preconditions.checkState(!analysisEnvironment.hasErrors(),
        ""Analysis environment hasError() but no errors reported"");

    if (env.valuesMissing()) {
      return null;
    }

    analysisEnvironment.disable(associatedTarget);
    Preconditions.checkNotNull(configuredAspect);

    return AspectValue.create(
        key,
        aspect,
        configuredAspect,
        transitiveState.transitivePackages());
  }

  @Override
  public String extractTag(SkyKey skyKey) {
    AspectKey aspectKey = (AspectKey) skyKey.argument();
    return Label.print(aspectKey.getLabel());
  }

  /** Used to indicate errors during the computation of an {@link AspectValue}. */
  public static final class AspectFunctionException extends SkyFunctionException {
    public AspectFunctionException(NoSuchThingException e) {
      super(e, Transience.PERSISTENT);
    }

    public AspectFunctionException(AspectCreationException e) {
      super(e, Transience.PERSISTENT);
    }

    public AspectFunctionException(ConfiguredValueCreationException e) {
      super(e, Transience.PERSISTENT);
    }

    public AspectFunctionException(InvalidExecGroupException e) {
      super(e, Transience.PERSISTENT);
    }

    public AspectFunctionException(ActionConflictException cause) {
      super(cause, Transience.PERSISTENT);
    }
  }
}
","topologicalAspectPathBuilder
",asPath,topologicalAspectPath,NA,dependencyContext,
"
package org.apache.dubbo.registry.nacos;

import java.util.LinkedHashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

import org.apache.dubbo.common.URL;
import org.apache.dubbo.common.config.ConfigurationUtils;
import org.apache.dubbo.common.function.ThrowableFunction;
import org.apache.dubbo.common.logger.ErrorTypeAwareLogger;
import org.apache.dubbo.common.logger.LoggerFactory;
import org.apache.dubbo.common.utils.ConcurrentHashSet;
import org.apache.dubbo.registry.client.AbstractServiceDiscovery;
import org.apache.dubbo.registry.client.ServiceDiscovery;
import org.apache.dubbo.registry.client.ServiceInstance;
import org.apache.dubbo.registry.client.event.ServiceInstancesChangedEvent;
import org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;
import org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils;
import org.apache.dubbo.rpc.RpcException;
import org.apache.dubbo.rpc.model.ApplicationModel;

import com.alibaba.nacos.api.exception.NacosException;
import com.alibaba.nacos.api.naming.listener.Event;
import com.alibaba.nacos.api.naming.listener.EventListener;
import com.alibaba.nacos.api.naming.listener.NamingEvent;
import com.alibaba.nacos.api.naming.pojo.Instance;
import com.alibaba.nacos.api.naming.pojo.ListView;

import static com.alibaba.nacos.api.common.Constants.DEFAULT_GROUP;
import static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_NACOS_EXCEPTION;
import static org.apache.dubbo.common.function.ThrowableConsumer.execute;
import static org.apache.dubbo.metadata.RevisionResolver.EMPTY_REVISION;
import static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.EXPORTED_SERVICES_REVISION_PROPERTY_NAME;
import static org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils.getExportedServicesRevision;
import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.createNamingService;
import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.getGroup;
import static org.apache.dubbo.registry.nacos.util.NacosNamingServiceUtils.toInstance;
import static org.apache.dubbo.rpc.RpcException.REGISTRY_EXCEPTION;

/**
 * Nacos {@link ServiceDiscovery} implementation
 *
 * @see ServiceDiscovery
 * @since 2.7.5
 */
public class NacosServiceDiscovery extends AbstractServiceDiscovery {

    private final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(getClass());

    private final String group;

    private final NacosNamingServiceWrapper namingService;

    private static final String NACOS_SD_USE_DEFAULT_GROUP_KEY = ""dubbo.nacos-service-discovery.use-default-group"";

    private final ConcurrentHashMap<String, NacosEventListener> eventListeners = new ConcurrentHashMap<>();

    public NacosServiceDiscovery(ApplicationModel applicationModel, URL registryURL) {
        super(applicationModel, registryURL);
        this.namingService = createNamingService(registryURL);
        // backward compatibility for 3.0.x
        this.group = Boolean.parseBoolean(ConfigurationUtils.getProperty(applicationModel, NACOS_SD_USE_DEFAULT_GROUP_KEY, ""false"")) ?
                DEFAULT_GROUP : getGroup(registryURL);
    }

    @Override
    public void doDestroy() throws Exception {
        this.namingService.shutdown();
        this.eventListeners.clear();
    }

    @Override
    public void doRegister(ServiceInstance serviceInstance) {
        execute(namingService, service -> {
            Instance instance = toInstance(serviceInstance);
            service.registerInstance(instance.getServiceName(), group, instance);
        });
    }

    @Override
    public void doUnregister(ServiceInstance serviceInstance) throws RuntimeException {
        execute(namingService, service -> {
            Instance instance = toInstance(serviceInstance);
            service.deregisterInstance(instance.getServiceName(), group, instance);
        });
    }

    @Override
    protected void doUpdate(ServiceInstance oldServiceInstance, ServiceInstance newServiceInstance) throws RuntimeException {
        if (EMPTY_REVISION.equals(getExportedServicesRevision(newServiceInstance))
                || EMPTY_REVISION.equals(oldServiceInstance.getMetadata().get(EXPORTED_SERVICES_REVISION_PROPERTY_NAME))) {
            super.doUpdate(oldServiceInstance, newServiceInstance);
            return;
        }

        if (!Objects.equals(newServiceInstance.getHost(), oldServiceInstance.getHost()) ||
                !Objects.equals(newServiceInstance.getPort(), oldServiceInstance.getPort())) {
            // Ignore if id changed. Should unregister first.
            super.doUpdate(oldServiceInstance, newServiceInstance);
            return;
        }

        Instance oldInstance = toInstance(oldServiceInstance);
        Instance newInstance = toInstance(newServiceInstance);

        try {
            this.serviceInstance = newServiceInstance;
            reportMetadata(newServiceInstance.getServiceMetadata());
            execute(namingService, service -> {
                Instance instance = toInstance(serviceInstance);
                service.updateInstance(instance.getServiceName(), group, oldInstance, newInstance);
            });
        } catch (Exception e) {
            throw new RpcException(REGISTRY_EXCEPTION, ""Failed register instance "" + newServiceInstance.toString(), e);
        }
    }

    @Override
    public Set<String> getServices() {
        return ThrowableFunction.execute(namingService, service -> {
            ListView<String> view = service.getServicesOfServer(0, Integer.MAX_VALUE, group);
            return new LinkedHashSet<>(view.getData());
        });
    }

    @Override
    public List<ServiceInstance> getInstances(String  [MASK] ) throws NullPointerException {
        return ThrowableFunction.execute(namingService, service ->
                service.selectInstances( [MASK] , group, true)
                        .stream().map((i) -> NacosNamingServiceUtils.toServiceInstance(registryURL, i))
                        .collect(Collectors.toList())
        );
    }

    @Override
    public void addServiceInstancesChangedListener(ServiceInstancesChangedListener listener)
            throws NullPointerException, IllegalArgumentException {
        // check if listener has already been added through another interface/service
        if (!instanceListeners.add(listener)) {
            return;
        }
        for (String  [MASK]  : listener.getServiceNames()) {
            NacosEventListener nacosEventListener = eventListeners.get( [MASK] );
            if (nacosEventListener != null) {
                nacosEventListener.addListener(listener);
            } else {
                try {
                    nacosEventListener = new NacosEventListener();
                    nacosEventListener.addListener(listener);
                    namingService.subscribe( [MASK] , group, nacosEventListener);
                    eventListeners.put( [MASK] , nacosEventListener);
                } catch (NacosException e) {
                    logger.error(REGISTRY_NACOS_EXCEPTION, """", """", ""add nacos service instances changed listener fail "", e);
                }
            }
        }
    }

    @Override
    public void removeServiceInstancesChangedListener(ServiceInstancesChangedListener listener) throws IllegalArgumentException {
        if (!instanceListeners.remove(listener)) {
            return;
        }
        for (String  [MASK]  : listener.getServiceNames()) {
            NacosEventListener nacosEventListener = eventListeners.get( [MASK] );
            if (nacosEventListener != null) {
                nacosEventListener.removeListener(listener);
                if (nacosEventListener.isEmpty()) {
                    eventListeners.remove( [MASK] );
                    try {
                        namingService.unsubscribe( [MASK] , group, nacosEventListener);
                    } catch (NacosException e) {
                        logger.error(REGISTRY_NACOS_EXCEPTION, """", """", ""remove nacos service instances changed listener fail "", e);
                    }
                }
            }
        }
    }

    public class NacosEventListener implements EventListener {
        private final Set<ServiceInstancesChangedListener> listeners = new ConcurrentHashSet<>();

        @Override
        public void onEvent(Event e) {
            if (e instanceof NamingEvent) {
                for (ServiceInstancesChangedListener listener : listeners) {
                    NamingEvent event = (NamingEvent) e;
                    handleEvent(event, listener);
                }
            }
        }

        public void addListener(ServiceInstancesChangedListener listener) {
            listeners.add(listener);
        }

        public void removeListener(ServiceInstancesChangedListener listener) {
            listeners.remove(listener);
        }

        public boolean isEmpty() {
            return listeners.isEmpty();
        }
    }

    @Override
    public URL getUrl() {
        return registryURL;
    }

    private void handleEvent(NamingEvent event, ServiceInstancesChangedListener listener) {
        String  [MASK]  = event.getServiceName();
        List<ServiceInstance> serviceInstances = event.getInstances()
                .stream()
                .map((i) -> NacosNamingServiceUtils.toServiceInstance(registryURL, i))
                .collect(Collectors.toList());
        listener.onEvent(new ServiceInstancesChangedEvent( [MASK] , serviceInstances));
    }
}
","serviceName
",name,"serviceName
","serviceName
","serviceName
",
"

package org.apache.dubbo.configcenter.support.nacos;

import com.alibaba.nacos.api.NacosFactory;
import com.alibaba.nacos.api.config.ConfigService;
import com.alibaba.nacos.api.exception.NacosException;
import org.apache.dubbo.common.URL;
import org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;
import org.apache.dubbo.common.config.configcenter.ConfigurationListener;
import org.apache.dubbo.common.config.configcenter.DynamicConfiguration;
import org.apache.dubbo.rpc.model.ApplicationModel;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CountDownLatch;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;


/**
 * Unit test for nacos config center support
 */
//FIXME: waiting for embedded Nacos suport, then we can open the switch.
@Disabled(""https://github.com/alibaba/nacos/issues/1188"")
class NacosDynamicConfigurationTest {
    private static final String SESSION_TIMEOUT_KEY = ""session"";

    private static NacosDynamicConfiguration config;

    /**
     * A test client to put data to Nacos server for testing purpose
     */
    private static ConfigService nacosClient;

    @Test
    void testGetConfig() throws Exception {
        put(""org.apache.dubbo.nacos.testService.configurators"", ""hello"");
        Thread.sleep(200);
        put(""dubbo.properties"", ""test"", ""aaa=bbb"");
        Thread.sleep(200);
        put(""org.apache.dubbo.demo.DemoService:1.0.0.test:xxxx.configurators"", ""helloworld"");
        Thread.sleep(200);
        Assertions.assertEquals(""hello"", config.getConfig(""org.apache.dubbo.nacos.testService.configurators"", DynamicConfiguration.DEFAULT_GROUP));
        Assertions.assertEquals(""aaa=bbb"", config.getConfig(""dubbo.properties"", ""test""));
        Assertions.assertEquals(""helloworld"", config.getConfig(""org.apache.dubbo.demo.DemoService:1.0.0.test:xxxx.configurators"", DynamicConfiguration.DEFAULT_GROUP));
    }

    @Test
    void testAddListener() throws Exception {
        CountDownLatch latch = new CountDownLatch(4);
        TestListener listener1 = new TestListener(latch);
        TestListener listener2 = new TestListener(latch);
        TestListener listener3 = new TestListener(latch);
        TestListener listener4 = new TestListener(latch);


        config.addListener(""AService.configurators"", listener1);
        config.addListener(""AService.configurators"", listener2);
        config.addListener(""testapp.tag-router"", listener3);
        config.addListener(""testapp.tag-router"", listener4);

        put(""AService.configurators"", ""new value1"");
        Thread.sleep(200);
        put(""testapp.tag-router"", ""new value2"");
        Thread.sleep(200);
        put(""testapp"", ""new value3"");
        Thread.sleep(5000);

        latch.await();

        Assertions.assertEquals(1, listener1.getCount(""AService.configurators""));
        Assertions.assertEquals(1, listener2.getCount(""AService.configurators""));
        Assertions.assertEquals(1, listener3.getCount(""testapp.tag-router""));
        Assertions.assertEquals(1, listener4.getCount(""testapp.tag-router""));

        Assertions.assertEquals(""new value1"", listener1.getValue());
        Assertions.assertEquals(""new value1"", listener2.getValue());
        Assertions.assertEquals(""new value2"", listener3.getValue());
        Assertions.assertEquals(""new value2"", listener4.getValue());

    }
//
//    @Test
//    public void testGetConfigKeys() {
//
//        put(""key1"", ""a"");
//        put(""key2"", ""b"");
//
//        SortedSet<String> keys = config.getConfigKeys(DynamicConfiguration.DEFAULT_GROUP);
//
//        Assertions.assertFalse(keys.isEmpty());
//
//    }

    private void put(String key, String value) {
        put(key, DynamicConfiguration.DEFAULT_GROUP, value);
    }

    private void put(String key, String group, String value) {
        try {
            nacosClient.publishConfig(key, group, value);
        } catch (Exception e) {
            System.out.println(""Error put value to nacos."");
        }
    }

    @BeforeAll
    public static void setUp() {
        String urlForDubbo = ""nacos://"" + ""127.0.0.1:8848"" + ""/org.apache.dubbo.nacos.testService"";
        // timeout in 15 seconds.
        URL url = URL.valueOf(urlForDubbo)
                .addParameter(SESSION_TIMEOUT_KEY, 15000);
        config = new NacosDynamicConfiguration(url, ApplicationModel.defaultModel());


        try {
            nacosClient = NacosFactory.createConfigService(""127.0.0.1:8848"");
        } catch (NacosException e) {
            e.printStackTrace();
        }
    }

    @Test
    void testPublishConfig() {
        String key = ""user-service"";
        String group = ""org.apache.dubbo.service.UserService"";
        String content = ""test"";

        assertTrue(config.publishConfig(key, group, content));
        assertEquals(""test"", config.getProperties(key, group));
    }

    @AfterAll
    public static void tearDown() {

    }

    private class TestListener implements ConfigurationListener {
        private CountDownLatch latch;
        private String value;
        private Map<String, Integer> countMap = new HashMap<>();

        public TestListener(CountDownLatch latch) {
            this.latch = latch;
        }

        @Override
        public void process(ConfigChangedEvent  [MASK] ) {
            System.out.println(this + "": "" +  [MASK] );
            Integer count = countMap.computeIfAbsent( [MASK] .getKey(), k -> 0);
            countMap.put( [MASK] .getKey(), ++count);
            value =  [MASK] .getContent();
            latch.countDown();
        }

        public int getCount(String key) {
            return countMap.get(key);
        }

        public String getValue() {
            return value;
        }
    }

}
","event
",changedEvent,configChangedEvent,configChangedEvent,"event
",
"
package com.google.devtools.build.lib.packages;

import static com.google.common.truth.Truth.assertThat;

import com.google.common.base.Predicate;
import com.google.common.collect.Lists;
import com.google.devtools.build.lib.packages.util.PackageLoadingTestCase;
import java.util.Map;
import net.starlark.java.eval.Dict;
import net.starlark.java.eval.Starlark;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * Test for {@link TargetUtils}
 */
@RunWith(JUnit4.class)
public class TargetUtilsTest extends PackageLoadingTestCase {

  @Test
  public void getRuleLanguage() {
    assertThat(TargetUtils.getRuleLanguage(""java_binary"")).isEqualTo(""java"");
    assertThat(TargetUtils.getRuleLanguage(""foobar"")).isEqualTo(""foobar"");
    assertThat(TargetUtils.getRuleLanguage("""")).isEmpty();
  }

  @Test
  public void testFilterByTag() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'tag1', srcs=['sh.sh'], tags=['tag1'])"",
        ""sh_binary(name = 'tag2', srcs=['sh.sh'], tags=['tag2'])"",
        ""sh_binary(name = 'tag1b', srcs=['sh.sh'], tags=['tag1'])"");

    Target tag1 = getTarget(""//tests:tag1"");
    Target tag2 = getTarget(""//tests:tag2"");
    Target  tag1b = getTarget(""//tests:tag1b"");

    Predicate<Target> tagFilter = TargetUtils.tagFilter(Lists.<String>newArrayList());
    assertThat(tagFilter.apply(tag1)).isTrue();
    assertThat(tagFilter.apply(tag2)).isTrue();
    assertThat(tagFilter.apply(tag1b)).isTrue();
    tagFilter = TargetUtils.tagFilter(Lists.newArrayList(""tag1"", ""tag2""));
    assertThat(tagFilter.apply(tag1)).isTrue();
    assertThat(tagFilter.apply(tag2)).isTrue();
    assertThat(tagFilter.apply(tag1b)).isTrue();
    tagFilter = TargetUtils.tagFilter(Lists.newArrayList(""tag1""));
    assertThat(tagFilter.apply(tag1)).isTrue();
    assertThat(tagFilter.apply(tag2)).isFalse();
    assertThat(tagFilter.apply(tag1b)).isTrue();
    tagFilter = TargetUtils.tagFilter(Lists.newArrayList(""-tag2""));
    assertThat(tagFilter.apply(tag1)).isTrue();
    assertThat(tagFilter.apply(tag2)).isFalse();
    assertThat(tagFilter.apply(tag1b)).isTrue();
    // Applying same tag as positive and negative filter produces an empty
    // result because the negative filter is applied first and positive filter will
    // not match anything.
    tagFilter = TargetUtils.tagFilter(Lists.newArrayList(""tag2"", ""-tag2""));
    assertThat(tagFilter.apply(tag1)).isFalse();
    assertThat(tagFilter.apply(tag2)).isFalse();
    assertThat(tagFilter.apply(tag1b)).isFalse();
    tagFilter = TargetUtils.tagFilter(Lists.newArrayList(""tag2"", ""-tag1""));
    assertThat(tagFilter.apply(tag1)).isFalse();
    assertThat(tagFilter.apply(tag2)).isTrue();
    assertThat(tagFilter.apply(tag1b)).isFalse();
  }

  @Test
  public void testExecutionInfo() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'tag1', srcs=['sh.sh'], tags=['supports-workers', 'no-cache'])"",
        ""sh_binary(name = 'tag2', srcs=['sh.sh'], tags=['disable-local-prefetch'])"",
        ""sh_binary(name = 'tag1b', srcs=['sh.sh'], tags=['local', 'cpu:4'])"");

    Rule tag1 = (Rule) getTarget(""//tests:tag1"");
    Rule tag2 = (Rule) getTarget(""//tests:tag2"");
    Rule tag1b = (Rule) getTarget(""//tests:tag1b"");

    Map<String, String> execInfo = TargetUtils.getExecutionInfo(tag1);
    assertThat(execInfo).containsExactly(""supports-workers"", """", ""no-cache"", """");
    execInfo = TargetUtils.getExecutionInfo(tag2);
    assertThat(execInfo).containsExactly(""disable-local-prefetch"", """");
    execInfo = TargetUtils.getExecutionInfo(tag1b);
    assertThat(execInfo).containsExactly(""local"", """", ""cpu:4"", """");
  }

  @Test
  public void testExecutionInfo_withPrefixSupports() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'with-prefix-supports', srcs=['sh.sh'], tags=['supports-workers',""
            + "" 'supports-whatever', 'my-tag'])"");

    Rule withSupportsPrefix = (Rule) getTarget(""//tests:with-prefix-supports"");

    Map<String, String> execInfo = TargetUtils.getExecutionInfo(withSupportsPrefix);
    assertThat(execInfo).containsExactly(""supports-whatever"", """", ""supports-workers"", """");
  }

  @Test
  public void testExecutionInfo_withPrefixDisable() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'with-prefix-disable', srcs=['sh.sh'], tags=['disable-local-prefetch',""
            + "" 'disable-something-else', 'another-tag'])"");

    Rule  [MASK]  = (Rule) getTarget(""//tests:with-prefix-disable"");

    Map<String, String> execInfo = TargetUtils.getExecutionInfo( [MASK] );
    assertThat(execInfo)
        .containsExactly(""disable-local-prefetch"", """", ""disable-something-else"", """");
  }

  @Test
  public void testExecutionInfo_withPrefixNo() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'with-prefix-no', srcs=['sh.sh'], tags=['no-remote-imaginary-flag',""
            + "" 'no-sandbox', 'unknown'])"");

    Rule withNoPrefix = (Rule) getTarget(""//tests:with-prefix-no"");

    Map<String, String> execInfo = TargetUtils.getExecutionInfo(withNoPrefix);
    assertThat(execInfo).containsExactly(""no-remote-imaginary-flag"", """", ""no-sandbox"", """");
  }

  @Test
  public void testExecutionInfo_withPrefixRequires() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'with-prefix-requires', srcs=['sh.sh'], tags=['requires-network',""
            + "" 'requires-sunlight', 'test-only'])"");

    Rule withRequiresPrefix = (Rule) getTarget(""//tests:with-prefix-requires"");

    Map<String, String> execInfo = TargetUtils.getExecutionInfo(withRequiresPrefix);
    assertThat(execInfo).containsExactly(""requires-network"", """", ""requires-sunlight"", """");
  }

  @Test
  public void testExecutionInfo_withPrefixBlock() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'with-prefix-block', srcs=['sh.sh'], tags=['block-some-feature',""
            + "" 'block-network', 'wrong-tag'])"");

    Rule withBlockPrefix = (Rule) getTarget(""//tests:with-prefix-block"");

    Map<String, String> execInfo = TargetUtils.getExecutionInfo(withBlockPrefix);
    assertThat(execInfo).containsExactly(""block-network"", """", ""block-some-feature"", """");
  }

  @Test
  public void testExecutionInfo_withPrefixCpu() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'with-prefix-cpu', srcs=['sh.sh'], tags=['cpu:123', 'wrong-tag'])"");

    Rule withCpuPrefix = (Rule) getTarget(""//tests:with-prefix-cpu"");

    Map<String, String> execInfo = TargetUtils.getExecutionInfo(withCpuPrefix);
    assertThat(execInfo).containsExactly(""cpu:123"", """");
  }

  @Test
  public void testExecutionInfo_withLocalTag() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'with-local-tag', srcs=['sh.sh'], tags=['local', 'some-tag'])"");

    Rule withLocal = (Rule) getTarget(""//tests:with-local-tag"");

    Map<String, String> execInfo = TargetUtils.getExecutionInfo(withLocal);
    assertThat(execInfo).containsExactly(""local"", """");
  }

  @Test
  public void testFilteredExecutionInfo_fromUncheckedExecRequirements() throws Exception {
    scratch.file(""tests/BUILD"", ""sh_binary(name = 'no-tag', srcs=['sh.sh'])"");

    Rule noTag = (Rule) getTarget(""//tests:no-tag"");

    Map<String, String> execInfo =
        TargetUtils.getFilteredExecutionInfo(
            Dict.<String, String>builder().put(""supports-worker"", ""1"").buildImmutable(),
            noTag, /* allowTagsPropagation */
            true);
    assertThat(execInfo).containsExactly(""supports-worker"", ""1"");

    execInfo =
        TargetUtils.getFilteredExecutionInfo(
            Dict.<String, String>builder()
                .put(""some-custom-tag"", ""1"")
                .put(""no-cache"", ""1"")
                .buildImmutable(),
            noTag,
            /* allowTagsPropagation */ true);
    assertThat(execInfo).containsExactly(""no-cache"", ""1"");
  }

  @Test
  public void testFilteredExecutionInfo_fromUncheckedExecRequirements_withWorkerKeyMnemonic()
      throws Exception {
    scratch.file(""tests/BUILD"", ""sh_binary(name = 'no-tag', srcs=['sh.sh'])"");

    Rule noTag = (Rule) getTarget(""//tests:no-tag"");

    Map<String, String> execInfo =
        TargetUtils.getFilteredExecutionInfo(
            Dict.<String, String>builder()
                .put(""supports-workers"", ""1"")
                .put(""worker-key-mnemonic"", ""MyMnemonic"")
                .buildImmutable(),
            noTag, /* allowTagsPropagation */
            true);
    assertThat(execInfo)
        .containsExactly(""supports-workers"", ""1"", ""worker-key-mnemonic"", ""MyMnemonic"");
  }

  @Test
  public void testFilteredExecutionInfo() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'tag1', srcs=['sh.sh'], tags=['supports-workers', 'no-cache'])"");
    Rule tag1 = (Rule) getTarget(""//tests:tag1"");
    Dict<String, String> executionRequirementsUnchecked =
        Dict.<String, String>builder().put(""no-remote"", ""1"").buildImmutable();

    Map<String, String> execInfo =
        TargetUtils.getFilteredExecutionInfo(
            executionRequirementsUnchecked, tag1, /* allowTagsPropagation */ true);

    assertThat(execInfo).containsExactly(""no-cache"", """", ""supports-workers"", """", ""no-remote"", ""1"");
  }

  @Test
  public void testFilteredExecutionInfo_withDuplicateTags() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'tag1', srcs=['sh.sh'], tags=['supports-workers', 'no-cache'])"");
    Rule tag1 = (Rule) getTarget(""//tests:tag1"");
    Dict<String, String> executionRequirementsUnchecked =
        Dict.<String, String>builder().put(""no-cache"", ""1"").buildImmutable();

    Map<String, String> execInfo =
        TargetUtils.getFilteredExecutionInfo(
            executionRequirementsUnchecked, tag1, /* allowTagsPropagation */ true);

    assertThat(execInfo).containsExactly(""no-cache"", ""1"", ""supports-workers"", """");
  }

  @Test
  public void testFilteredExecutionInfo_withNullUncheckedExecRequirements() throws Exception {
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'tag1', srcs=['sh.sh'], tags=['supports-workers', 'no-cache'])"");
    Rule tag1 = (Rule) getTarget(""//tests:tag1"");

    Map<String, String> execInfo =
        TargetUtils.getFilteredExecutionInfo(null, tag1, /* allowTagsPropagation */ true);
    assertThat(execInfo).containsExactly(""no-cache"", """", ""supports-workers"", """");

    execInfo =
        TargetUtils.getFilteredExecutionInfo(Starlark.NONE, tag1, /* allowTagsPropagation */ true);
    assertThat(execInfo).containsExactly(""no-cache"", """", ""supports-workers"", """");
  }

  @Test
  public void testFilteredExecutionInfo_whenIncompatibleFlagDisabled() throws Exception {
    // when --incompatible_allow_tags_propagation=false
    scratch.file(
        ""tests/BUILD"",
        ""sh_binary(name = 'tag1', srcs=['sh.sh'], tags=['supports-workers', 'no-cache'])"");
    Rule tag1 = (Rule) getTarget(""//tests:tag1"");
    Dict<String, String> executionRequirementsUnchecked =
        Dict.<String, String>builder().put(""no-remote"", ""1"").buildImmutable();

    Map<String, String> execInfo =
        TargetUtils.getFilteredExecutionInfo(
            executionRequirementsUnchecked, tag1, /* allowTagsPropagation */ false);

    assertThat(execInfo).containsExactly(""no-remote"", ""1"");
  }

  @Test
  public void testExecutionInfoMisc() throws Exception {
    // Migrated from a removed test class that was focused on top-level build configuration.
    // TODO(anyone): remove tests here that are redundant w.r.t. the other tests in this file.
    scratch.file(
        ""x/BUILD"",
        ""cc_test(name = 'y',"",
        ""          srcs = ['a'],"",
        ""          size = 'small',"",
        ""          tags = ['manual','local','exclusive'])"",
        ""cc_test(name = 'z',"",
        ""          srcs = ['a'],"",
        ""          size = 'small',"",
        ""          tags = ['othertag', 'requires-feature2'])"",
        ""cc_test(name = 'k',"",
        ""          srcs = ['a'],"",
        ""          size = 'small',"",
        ""          tags = ['requires-feature1'])"",
        ""cc_test(name = 'exclusive_if_local',"",
        ""          srcs = ['a'],"",
        ""          size = 'small',"",
        ""          tags = ['exclusive-if-local'])"",
        ""cc_test(name = 'exclusive_only',"",
        ""          srcs = ['a'],"",
        ""          size = 'small',"",
        ""          tags = ['exclusive'])"",
        ""test_suite(name = 'ts',"",
        ""          tests = ['z'])"",
        ""cc_binary(name = 'x',"",
        ""          srcs = ['a', 'b', 'c'],"",
        ""          defines = ['-Da', '-Db'])"",
        ""cc_binary(name = 'lib1',"",
        ""          srcs = ['a', 'b', 'c'],"",
        ""          linkshared = 1)"",
        ""genrule(name = 'gen1',"",
        ""          srcs = [],"",
        ""          outs = ['t1', 't2'],"",
        ""          cmd = 'my cmd')"",
        ""genrule(name = 'gen2',"",
        ""          srcs = ['liba.so'],"",
        ""          outs = ['libnewa.so'],"",
        ""          cmd = 'my cmd')"");
    Rule x = (Rule) getTarget(""//x:x"");
    assertThat(TargetUtils.isTestRule(x)).isFalse();
    Rule ts = (Rule) getTarget(""//x:ts"");
    assertThat(TargetUtils.isTestRule(ts)).isFalse();
    assertThat(TargetUtils.isTestOrTestSuiteRule(ts)).isTrue();
    Rule z = (Rule) getTarget(""//x:z"");
    assertThat(TargetUtils.isTestRule(z)).isTrue();
    assertThat(TargetUtils.isTestOrTestSuiteRule(z)).isTrue();
    assertThat(TargetUtils.isExclusiveTestRule(z)).isFalse();
    assertThat(TargetUtils.isExclusiveIfLocalTestRule(z)).isFalse();
    assertThat(TargetUtils.isLocalTestRule(z)).isFalse();
    assertThat(TargetUtils.hasManualTag(z)).isFalse();
    assertThat(TargetUtils.getExecutionInfo(z)).doesNotContainKey(""requires-feature1"");
    assertThat(TargetUtils.getExecutionInfo(z)).containsKey(""requires-feature2"");
    Rule k = (Rule) getTarget(""//x:k"");
    assertThat(TargetUtils.isTestRule(k)).isTrue();
    assertThat(TargetUtils.isTestOrTestSuiteRule(k)).isTrue();
    assertThat(TargetUtils.isExclusiveTestRule(k)).isFalse();
    assertThat(TargetUtils.isExclusiveIfLocalTestRule(k)).isFalse();
    assertThat(TargetUtils.isLocalTestRule(k)).isFalse();
    assertThat(TargetUtils.hasManualTag(k)).isFalse();
    assertThat(TargetUtils.getExecutionInfo(k)).containsKey(""requires-feature1"");
    assertThat(TargetUtils.getExecutionInfo(k)).doesNotContainKey(""requires-feature2"");
    Rule y = (Rule) getTarget(""//x:y"");
    assertThat(TargetUtils.isTestRule(y)).isTrue();
    assertThat(TargetUtils.isTestOrTestSuiteRule(y)).isTrue();
    assertThat(TargetUtils.isExclusiveTestRule(y)).isTrue();
    assertThat(TargetUtils.isExclusiveIfLocalTestRule(y)).isFalse();
    assertThat(TargetUtils.isLocalTestRule(y)).isTrue();
    assertThat(TargetUtils.hasManualTag(y)).isTrue();
    assertThat(TargetUtils.getExecutionInfo(y)).doesNotContainKey(""requires-feature1"");
    assertThat(TargetUtils.getExecutionInfo(y)).doesNotContainKey(""requires-feature2"");
    Rule exclusiveIfRunLocally = (Rule) getTarget(""//x:exclusive_if_local"");
    assertThat(TargetUtils.isExclusiveIfLocalTestRule(exclusiveIfRunLocally)).isTrue();
    assertThat(TargetUtils.isLocalTestRule(exclusiveIfRunLocally)).isFalse();
    assertThat(TargetUtils.isExclusiveTestRule(exclusiveIfRunLocally)).isFalse();
    Rule exclusive = (Rule) getTarget(""//x:exclusive_only"");
    assertThat(TargetUtils.isExclusiveTestRule(exclusive)).isTrue();
    assertThat(TargetUtils.isLocalTestRule(exclusive)).isFalse(); // LOCAL tag gets added later.
    assertThat(TargetUtils.isExclusiveIfLocalTestRule(exclusive)).isFalse();
  }
}
","withDisablePrefix
",withDisable,withDisable,withBlockPrefix,executionInfo,
"

package com.badlogic.gdx.tests;

import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.tests.utils.GdxTest;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.GdxRuntimeException;
import com.badlogic.gdx.utils.PerformanceCounter;

import java.util.Comparator;

/** For testing and benchmarking of gdx.utils.Select and its associated algorithms/classes
 * @author Jon Renner */
public class SelectTest extends GdxTest {
        static PerformanceCounter perf = new PerformanceCounter(""bench"");
        static boolean verify; // verify and report the results of each selection
        private static boolean quiet;

        @Override
        public void create () {
                int n = 100;
                player = createDummies(n);
                enemy = createDummies(n);

                int runs = 100;
                // run correctness first to warm up the JIT and other black magic
                quiet = true;
                allRandom();
                print(""VERIFY CORRECTNESS FIND LOWEST RANKED"");
                correctnessTest(runs, 1);
                print(""VERIFY CORRECTNESS FIND MIDDLE RANKED"");
                correctnessTest(runs, enemy.size / 2);
                print(""VERIFY CORRECTNESS FIND HIGHEST RANKED"");
                correctnessTest(runs, enemy.size);

                runs = 1000;
                quiet = true;
                print(""BENCHMARK FIND LOWEST RANKED"");
                performanceTest(runs, 1);
                print(""BENCHMARK FIND MIDDLE RANKED"");
                performanceTest(runs, enemy.size / 2);
                print(""BENCHMARK FIND HIGHEST RANKED"");
                performanceTest(runs, enemy.size);

                print(""TEST CONSISTENCY FOR LOWEST RANKED"");
                consistencyTest(runs, 1);
                print(""TEST CONSISTENCY FOR MIDDLE RANKED"");
                consistencyTest(runs, enemy.size / 2);
                print(""TEST CONSISTENCY FOR HIGHEST RANKED"");
                consistencyTest(runs, enemy.size);

                // test that selectRanked and selectRankedIndex return the same
                print(""TEST selectRanked AND selectRankedIndex RETURN MATCHING RESULTS - LOWEST RANKED"");
                testValueMatchesIndex(runs, 1);
                print(""TEST selectRanked AND selectRankedIndex RETURN MATCHING RESULTS - MIDDLE RANKED"");
                testValueMatchesIndex(runs, enemy.size / 2);
                print(""TEST selectRanked AND selectRankedIndex RETURN MATCHING RESULTS - HIGHEST RANKED"");
                testValueMatchesIndex(runs, enemy.size);

                print(""ALL TESTS PASSED"");
        }

        public static void correctnessTest (int runs, int k) {
                String msg = String.format(""[%d runs with %dx%d dummy game units] - "", runs, player.size, enemy.size);
                verify = true;
                test(runs, k);
                print(msg + ""VERIFIED"");
        }

        public static void performanceTest (int runs, int k) {
                verify = false;
                test(runs, k);
                String msg = String.format(""[%d runs with %dx%d dummy game units] - "", runs, player.size, enemy.size);
                print(msg + String.format(""avg: %.5f, min/max: %.4f/%.4f, total time: %.3f (ms), made %d comparisons"", allPerf.time.min,
                        allPerf.time.max, allPerf.time.average * 1000, allPerf.time.total * 1000, comparisonsMade));
        }

        public static void consistencyTest (int runs, int k) {
                verify = false;
                Dummy test = player.get(0);
                Dummy lastFound = null;
                allRandom();
                for (int i = 0; i < runs; i++) {
                        Dummy found = test.getKthNearestEnemy(k);
                        if (lastFound == null) {
                                lastFound = found;
                        } else {
                                if (!(lastFound.equals(found))) {
                                        print(""CONSISTENCY TEST FAILED"");
                                        print(""lastFound: "" + lastFound);
                                        print(""justFound: "" + found);
                                        throw new GdxRuntimeException(""test failed"");
                                }
                        }
                }
        }

        public static void testValueMatchesIndex (int runs, int k) {
                verify = false;
                for (int i = 0; i < runs; i++) {
                        allRandom();
                        player.shuffle();
                        enemy.shuffle();
                        originDummy = player.random();
                        int idx = enemy.selectRankedIndex(distComp, k);
                        Dummy indexDummy = enemy.get(idx);
                        Dummy valueDummy = enemy.selectRanked(distComp, k);
                        if (!(indexDummy.equals(valueDummy))) {
                                throw new GdxRuntimeException(""results of selectRankedIndex and selectRanked do not return the same object\n""
                                        + ""selectRankedIndex -> "" + indexDummy + ""\n"" + ""selectRanked      -> "" + valueDummy);
                        }

                }
        }

        public static void test (int runs, int k) {
                // k = kth order statistic
                comparisonsMade = 0;
                perf.reset();
                allPerf.reset();
                allRandom();
                enemy.shuffle();
                player.shuffle();
                for (int i = 0; i < runs; i++) {
                        getKthNearestEnemy(quiet, k);
                }
        }

        public static void allRandom () {
                for (Dummy d : player) {
                        d.setRandomPos();
                }
                for (Dummy d : enemy) {
                        d.setRandomPos();
                }
        }

        private static PerformanceCounter allPerf = new PerformanceCounter(""all"");

        public static void getKthNearestEnemy (boolean silent, int k) {
                Dummy kthDummy = null;
                perf.reset();
                allPerf.start();
                for (Dummy d : player) {
                        Dummy found = d.getKthNearestEnemy(k);
                }
                allPerf.stop();
                allPerf.tick();
                if (silent) return;
                print(String.format(""found nearest. min: %.4f, max: %.4f, avg: %.4f, total: %.3f ms"", perf.time.min * 1000,
                        perf.time.max * 1000, perf.time.average * 1000, perf.time.total * 1000));
        }

        public static void verifyCorrectness (Dummy d, int k) {
                enemy.sort(distComp);
                int idx = enemy.indexOf(d, true);
                // remember that k = min value = 0 position in the array, therefore k - 1
                if (enemy.get(idx) != enemy.get(k - 1)) {
                        System.out.println(""origin dummy: "" + originDummy);
                        System.out.println(""TEST FAILURE: "" + ""idx: "" + idx + "" does not equal (k - 1): "" + (k - 1));
                        throw new GdxRuntimeException(""test failed"");
                }
        }

        static class Dummy {
                public Vector2 pos;
                public int id;

                public Dummy () {
                        // set the position manually
                }

                @Override
                public boolean equals (Object obj) {
                        if (!(obj instanceof Dummy)) {
                                throw new GdxRuntimeException(""do not compare to anything but other Dummy objects"");
                        }
                        Dummy d = (Dummy)obj;
                        // we only care about position/distance
                        float epsilon = 0.0001f;
                        float diff = Math.abs(d.pos.x - this.pos.x) + Math.abs(d.pos.y - this.pos.y);
                        if (diff > epsilon) return false;
                        return true;

                }

                public Dummy getKthNearestEnemy (int k) {
                        perf.start();
                        originDummy = this;
                        Dummy found = enemy.selectRanked(distComp, k);
                        // print(this + "" found enemy: "" + found);
                        perf.stop();
                        perf.tick();
                        if (verify) {
                                verifyCorrectness(found, k);
                        }
                        return found;
                }

                public void setRandomPos () {
                        float max = 100;
                        this.pos.x = -max + MathUtils.random(max * 2);
                        this.pos.y = -max + MathUtils.random(max * 2);
                        float xShift = 100;
                        if (player.contains(this, true)) {
                                this.pos.x -= xShift;
                        } else if (enemy.contains(this, true)) {
                                this.pos.x += xShift;
                        } else {
                                throw new RuntimeException(""unhandled"");
                        }
                }

                @Override
                public String toString () {
                        return String.format(""Dummy at: %.2f, %.2f"", pos.x, pos.y);
                }
        }

        public static int nextID = 1;
        public static Array<Dummy> player;
        public static Array<Dummy> enemy;

        public static Array<Dummy> createDummies (int n) {
                float variance = 20;
                Array<Dummy>  [MASK]  = new Array<Dummy>();
                for (int i = 0; i < n; i++) {
                        Dummy d = new Dummy();
                         [MASK] .add(d);
                        d.pos = new Vector2();
                        d.id = nextID++;
                }
                return  [MASK] ;
        }

        static Dummy originDummy;
        static long comparisonsMade = 0;
        static Comparator<Dummy> distComp = new Comparator<Dummy>() {
                @Override
                public int compare (Dummy o1, Dummy o2) {
                        comparisonsMade++;
                        float d1 = originDummy.pos.dst2(o1.pos);
                        float d2 = originDummy.pos.dst2(o2.pos);
                        float diff = d1 - d2;
                        if (diff < 0) return -1;
                        if (diff > 0) return 1;
                        return 0;
                }
        };

        public static void print (Object... objs) {
                for (Object o : objs) {
                        System.out.print(o);
                }
                System.out.println();
        }
}
","dummies
",dDList,dummies,"dummies
","dummies
",
"

package com.google.devtools.common.options.testing;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assert.assertThrows;

import com.google.common.collect.ImmutableList;
import com.google.devtools.common.options.Converters;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/** Tests for the ConverterTesterMap map builder. */
@RunWith(JUnit4.class)
public final class ConverterTesterMapTest {

  @Test
  public void add_mapsTestedConverterClassToTester() throws Exception {
    ConverterTester stringTester =
        new ConverterTester(Converters.StringConverter.class, /*conversionContext=*/ null);
    ConverterTester intTester =
        new ConverterTester(Converters.IntegerConverter.class, /*conversionContext=*/ null);
    ConverterTester doubleTester =
        new ConverterTester(Converters.DoubleConverter.class, /*conversionContext=*/ null);
    ConverterTester booleanTester =
        new ConverterTester(Converters.BooleanConverter.class, /*conversionContext=*/ null);
    ConverterTesterMap map =
        new ConverterTesterMap.Builder()
            .add(stringTester)
            .add(intTester)
            .add(doubleTester)
            .add(booleanTester)
            .build();
    assertThat(map)
        .containsExactly(
            Converters.StringConverter.class,
            stringTester,
            Converters.IntegerConverter.class,
            intTester,
            Converters.DoubleConverter.class,
            doubleTester,
            Converters.BooleanConverter.class,
            booleanTester);
  }

  @Test
  public void addAll_mapsTestedConverterClassesToTester() throws Exception {
    ConverterTester stringTester =
        new ConverterTester(Converters.StringConverter.class, /*conversionContext=*/ null);
    ConverterTester intTester =
        new ConverterTester(Converters.IntegerConverter.class, /*conversionContext=*/ null);
    ConverterTester doubleTester =
        new ConverterTester(Converters.DoubleConverter.class, /*conversionContext=*/ null);
    ConverterTester booleanTester =
        new ConverterTester(Converters.BooleanConverter.class, /*conversionContext=*/ null);
    ConverterTesterMap map =
        new ConverterTesterMap.Builder()
            .addAll(ImmutableList.of(stringTester, intTester, doubleTester, booleanTester))
            .build();
    assertThat(map)
        .containsExactly(
            Converters.StringConverter.class,
            stringTester,
            Converters.IntegerConverter.class,
            intTester,
            Converters.DoubleConverter.class,
            doubleTester,
            Converters.BooleanConverter.class,
            booleanTester);
  }

  @Test
  public void addAll_dumpsConverterTesterMapIntoNewMap() throws Exception {
    ConverterTester stringTester =
        new ConverterTester(Converters.StringConverter.class, /*conversionContext=*/ null);
    ConverterTester intTester =
        new ConverterTester(Converters.IntegerConverter.class, /*conversionContext=*/ null);
    ConverterTester doubleTester =
        new ConverterTester(Converters.DoubleConverter.class, /*conversionContext=*/ null);
    ConverterTester booleanTester =
        new ConverterTester(Converters.BooleanConverter.class, /*conversionContext=*/ null);
    ConverterTesterMap  [MASK]  =
        new ConverterTesterMap.Builder()
            .addAll(ImmutableList.of(stringTester, intTester, doubleTester))
            .build();
    ConverterTesterMap map =
        new ConverterTesterMap.Builder().addAll( [MASK] ).add(booleanTester).build();
    assertThat(map)
        .containsExactly(
            Converters.StringConverter.class,
            stringTester,
            Converters.IntegerConverter.class,
            intTester,
            Converters.DoubleConverter.class,
            doubleTester,
            Converters.BooleanConverter.class,
            booleanTester);
  }

  @Test
  public void build_forbidsDuplicates() throws Exception {
    ConverterTesterMap.Builder builder =
        new ConverterTesterMap.Builder()
            .add(new ConverterTester(Converters.StringConverter.class, /*conversionContext=*/ null))
            .add(
                new ConverterTester(Converters.IntegerConverter.class, /*conversionContext=*/ null))
            .add(new ConverterTester(Converters.DoubleConverter.class, /*conversionContext=*/ null))
            .add(
                new ConverterTester(Converters.BooleanConverter.class, /*conversionContext=*/ null))
            .add(
                new ConverterTester(
                    Converters.BooleanConverter.class, /*conversionContext=*/ null));

    IllegalArgumentException expected =
        assertThrows(IllegalArgumentException.class, () -> builder.build());
    assertThat(expected)
        .hasMessageThat()
        .contains(Converters.BooleanConverter.class.getSimpleName());
  }
}
","baseMap
",testers,testers,converterTesterMap,converterTesterMap,
"

package com.google.zxing.qrcode.encoder;

/**
 * @author Satoru Takabayashi
 * @author Daniel Switkin
 * @author Sean Owen
 */
final class MaskUtil {

  // Penalty weights from section 6.8.2.1
  private static final int N1 = 3;
  private static final int N2 = 3;
  private static final int N3 = 40;
  private static final int N4 = 10;

  private MaskUtil() {
    // do nothing
  }

  /**
   * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and
   * give penalty to them. Example: 00000 or 11111.
   */
  static int applyMaskPenaltyRule1(ByteMatrix matrix) {
    return applyMaskPenaltyRule1Internal(matrix, true) + applyMaskPenaltyRule1Internal(matrix, false);
  }

  /**
   * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give
   * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a
   * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.
   */
  static int applyMaskPenaltyRule2(ByteMatrix matrix) {
    int penalty = 0;
    byte[][] array = matrix.getArray();
    int width = matrix.getWidth();
    int height = matrix.getHeight();
    for (int y = 0; y < height - 1; y++) {
      byte[] arrayY = array[y];
      for (int x = 0; x < width - 1; x++) {
        int value = arrayY[x];
        if (value == arrayY[x + 1] && value == array[y + 1][x] && value == array[y + 1][x + 1]) {
          penalty++;
        }
      }
    }
    return N2 * penalty;
  }

  /**
   * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4
   * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we
   * find patterns like 000010111010000, we give penalty once.
   */
  static int applyMaskPenaltyRule3(ByteMatrix matrix) {
    int numPenalties = 0;
    byte[][] array = matrix.getArray();
    int width = matrix.getWidth();
    int height = matrix.getHeight();
    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        byte[] arrayY = array[y];  // We can at least optimize this access
        if (x + 6 < width &&
            arrayY[x] == 1 &&
            arrayY[x + 1] == 0 &&
            arrayY[x + 2] == 1 &&
            arrayY[x + 3] == 1 &&
            arrayY[x + 4] == 1 &&
            arrayY[x + 5] == 0 &&
            arrayY[x + 6] == 1 &&
            (isWhiteHorizontal(arrayY, x - 4, x) || isWhiteHorizontal(arrayY, x + 7, x + 11))) {
          numPenalties++;
        }
        if (y + 6 < height &&
            array[y][x] == 1 &&
            array[y + 1][x] == 0 &&
            array[y + 2][x] == 1 &&
            array[y + 3][x] == 1 &&
            array[y + 4][x] == 1 &&
            array[y + 5][x] == 0 &&
            array[y + 6][x] == 1 &&
            (isWhiteVertical(array, x, y - 4, y) || isWhiteVertical(array, x, y + 7, y + 11))) {
          numPenalties++;
        }
      }
    }
    return numPenalties * N3;
  }

  private static boolean isWhiteHorizontal(byte[] rowArray, int from, int to) {
    if (from < 0 || rowArray.length < to) {
      return false;
    }
    for (int i = from; i < to; i++) {
      if (rowArray[i] == 1) {
        return false;
      }
    }
    return true;
  }

  private static boolean isWhiteVertical(byte[][] array, int col, int from, int to) {
    if (from < 0 || array.length < to) {
      return false;
    }
    for (int i = from; i < to; i++) {
      if (array[i][col] == 1) {
        return false;
      }
    }
    return true;
  }

  /**
   * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give
   * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.
   */
  static int applyMaskPenaltyRule4(ByteMatrix matrix) {
    int numDarkCells = 0;
    byte[][] array = matrix.getArray();
    int width = matrix.getWidth();
    int height = matrix.getHeight();
    for (int y = 0; y < height; y++) {
      byte[] arrayY = array[y];
      for (int x = 0; x < width; x++) {
        if (arrayY[x] == 1) {
          numDarkCells++;
        }
      }
    }
    int numTotalCells = matrix.getHeight() * matrix.getWidth();
    int fivePercentVariances = Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells;
    return fivePercentVariances * N4;
  }

  /**
   * Return the mask bit for ""getMaskPattern"" at ""x"" and ""y"". See 8.8 of JISX0510:2004 for mask
   * pattern conditions.
   */
  static boolean getDataMaskBit(int maskPattern, int x, int y) {
    int intermediate;
    int temp;
    switch (maskPattern) {
      case 0:
        intermediate = (y + x) & 0x1;
        break;
      case 1:
        intermediate = y & 0x1;
        break;
      case 2:
        intermediate = x % 3;
        break;
      case 3:
        intermediate = (y + x) % 3;
        break;
      case 4:
        intermediate = ((y / 2) + (x / 3)) & 0x1;
        break;
      case 5:
        temp = y * x;
        intermediate = (temp & 0x1) + (temp % 3);
        break;
      case 6:
        temp = y * x;
        intermediate = ((temp & 0x1) + (temp % 3)) & 0x1;
        break;
      case 7:
        temp = y * x;
        intermediate = ((temp % 3) + ((y + x) & 0x1)) & 0x1;
        break;
      default:
        throw new IllegalArgumentException(""Invalid mask pattern: "" + maskPattern);
    }
    return intermediate == 0;
  }

  /**
   * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both
   * vertical and horizontal orders respectively.
   */
  private static int applyMaskPenaltyRule1Internal(ByteMatrix matrix, boolean isHorizontal) {
    int penalty = 0;
    int iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
    int  [MASK]  = isHorizontal ? matrix.getWidth() : matrix.getHeight();
    byte[][] array = matrix.getArray();
    for (int i = 0; i < iLimit; i++) {
      int numSameBitCells = 0;
      int prevBit = -1;
      for (int j = 0; j <  [MASK] ; j++) {
        int bit = isHorizontal ? array[i][j] : array[j][i];
        if (bit == prevBit) {
          numSameBitCells++;
        } else {
          if (numSameBitCells >= 5) {
            penalty += N1 + (numSameBitCells - 5);
          }
          numSameBitCells = 1;  // Include the cell itself.
          prevBit = bit;
        }
      }
      if (numSameBitCells >= 5) {
        penalty += N1 + (numSameBitCells - 5);
      }
    }
    return penalty;
  }

}
","jLimit
",numSameBitInCells,jLimit,dimension,maskPattern,
"

package com.google.devtools.cyclefinder;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.io.Files;
import com.google.common.io.Resources;
import com.google.devtools.j2objc.util.ErrorUtil;
import com.google.devtools.j2objc.util.ExternalAnnotations;
import com.google.devtools.j2objc.util.SourceVersion;
import com.google.devtools.j2objc.util.Version;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Properties;

class Options {

  private static final String XBOOTCLASSPATH = ""-Xbootclasspath:"";
  private static String usageMessage;
  private static String helpMessage;

  static {
    // Load string resources.
    URL propertiesUrl = Resources.getResource(CycleFinder.class, ""CycleFinder.properties"");
    Properties properties = new Properties();
    try {
      properties.load(propertiesUrl.openStream());
    } catch (IOException e) {
      System.err.println(""unable to access tool properties: "" + e);
      System.exit(1);
    }
    usageMessage = properties.getProperty(""usage-message"");
    Preconditions.checkNotNull(usageMessage);
    helpMessage = properties.getProperty(""help-message"");
    Preconditions.checkNotNull(helpMessage);
  }

  private String sourcepath;
  private String classpath;
  private String bootclasspath;
  private final List<String> suppressListFiles = Lists.newArrayList();
  private final List<String> restrictToListFiles = Lists.newArrayList();
  private List<String> sourceFiles = Lists.newArrayList();
  private String fileEncoding = System.getProperty(""file.encoding"", ""UTF-8"");
  private boolean printReferenceGraph = false;
  private SourceVersion sourceVersion = null;
  private final ExternalAnnotations externalAnnotations = new ExternalAnnotations();

  // Flags that are directly forwarded to the javac parser.
  private static final ImmutableSet<String> PLATFORM_MODULE_SYSTEM_OPTIONS =
      ImmutableSet.of(""--patch-module"", ""--system"", ""--add-reads"");
  private final List<String> platformModuleSystemOptions = new ArrayList<>();

  public List<String> getSourceFiles() {
    return sourceFiles;
  }

  public void setSourceFiles(List<String> files) {
    this.sourceFiles = files;
  }

  public String getSourcepath() {
    return sourcepath;
  }

  public String getClasspath() {
    return classpath;
  }

  public void setClasspath(String classpath) {
    this.classpath = classpath;
  }

  public String getBootclasspath() {
    return bootclasspath != null ? bootclasspath : System.getProperty(""sun.boot.class.path"");
  }

  public List<String> getSuppressListFiles() {
    return suppressListFiles;
  }

  public void addSuppressListFile(String fileName) {
    suppressListFiles.add(fileName);
  }

  public List<String> getRestrictToFiles() {
    return restrictToListFiles;
  }

  public void addRestrictToFile(String fileName) {
    restrictToListFiles.add(fileName);
  }

  private void addManifest(String manifestFile) throws IOException {
    try (BufferedReader in =
        Files.newReader(new File(manifestFile), Charset.forName(fileEncoding))) {
      for (String line = in.readLine(); line != null; line = in.readLine()) {
        if (!Strings.isNullOrEmpty(line)) {
          sourceFiles.add(line.trim());
        }
      }
    }
  }

  public String fileEncoding() {
    return fileEncoding;
  }

  public SourceVersion sourceVersion() {
    if (sourceVersion == null) {
      sourceVersion = SourceVersion.defaultVersion();
    }
    return sourceVersion;
  }

  @VisibleForTesting
  void setSourceVersion(SourceVersion sv) {
      sourceVersion = sv;
  }

  public boolean printReferenceGraph() {
    return printReferenceGraph;
  }

  @VisibleForTesting
  public void setPrintReferenceGraph() {
     printReferenceGraph = true;
  }

  public ExternalAnnotations externalAnnotations() {
    return externalAnnotations;
  }

  @VisibleForTesting
  public void addExternalAnnotationFile(String file) throws IOException {
    externalAnnotations.addExternalAnnotationFile(file);
  }

  public void addPlatformModuleSystemOptions(String... flags) {
    Collections.addAll(platformModuleSystemOptions, flags);
  }

  public List<String> getPlatformModuleSystemOptions() {
    return platformModuleSystemOptions;
  }

  public static void usage(String invalidUseMsg) {
    System.err.println(""cycle_finder: "" + invalidUseMsg);
    System.err.println(usageMessage);
    System.exit(1);
  }

  public static void help(boolean errorExit) {
    System.err.println(helpMessage);
    // javac exits with 2, but any non-zero value works.
    System.exit(errorExit ? 2 : 0);
  }

  public static void version() {
    System.err.println(""cycle_finder "" + Version.jarVersion(Options.class));
    System.exit(0);
  }

  public static Options parse(String[] args) throws IOException {
    Options options = new Options();

    int nArg = 0;
    while (nArg < args.length) {
      String arg = args[nArg];
      if (arg.equals(""-sourcepath"")) {
        if (++nArg == args.length) {
          usage(""-sourcepath requires an argument"");
        }
        options.sourcepath = args[nArg];
      } else if (arg.equals(""-classpath"")) {
        if (++nArg == args.length) {
          usage(""-classpath requires an argument"");
        }
        options.classpath = args[nArg];
      } else if (arg.equals(""--suppress-list"")
          // Deprecated flag names.
          || arg.equals(""--whitelist"")
          || arg.equals(""-w"")) {
        if (++nArg == args.length) {
          usage(""--suppress-list requires an argument"");
        }
        options.suppressListFiles.add(args[nArg]);
      } else if (arg.equals(""--restrict-to"")
          // Deprecated flag name.
          || arg.equals(""--blacklist"")) {
        if (++nArg == args.length) {
          usage(""--restrict-to requires an argument"");
        }
        options.restrictToListFiles.add(args[nArg]);
      } else if (arg.equals(""--sourcefilelist"") || arg.equals(""-s"")) {
        if (++nArg == args.length) {
          usage(""--sourcefilelist requires an argument"");
        }
        options.addManifest(args[nArg]);
      } else if (arg.startsWith(XBOOTCLASSPATH)) {
        options.bootclasspath = arg.substring(XBOOTCLASSPATH.length());
      } else if (arg.equals(""-encoding"")) {
        if (++nArg == args.length) {
          usage(""-encoding requires an argument"");
        }
        options.fileEncoding = args[nArg];
      }  else if (arg.equals(""-source"")) {
        if (++nArg == args.length) {
          usage(""-source requires an argument"");
        }
        try {
          options.sourceVersion = SourceVersion.parse(args[nArg]);
          SourceVersion  [MASK]  = SourceVersion.getMaxSupportedVersion();
          if (options.sourceVersion.version() >  [MASK] .version()) {
            ErrorUtil.warning(""Java "" + options.sourceVersion.version() + "" source version is not ""
                + ""supported, using Java "" +  [MASK] .version() + ""."");
            options.sourceVersion =  [MASK] ;
          }
        } catch (IllegalArgumentException e) {
          usage(""invalid source release: "" + args[nArg]);
        }
      } else if (arg.equals(""--print-reference-graph"")) {
        options.printReferenceGraph = true;
      } else if (arg.equals(""-external-annotation-file"")) {
        if (++nArg == args.length) {
          usage(arg + "" requires an argument"");
        }
        options.addExternalAnnotationFile(args[nArg]);
      } else if (PLATFORM_MODULE_SYSTEM_OPTIONS.contains(arg)) {
        String option = arg;
        if (++nArg == args.length) {
          usage(option + "" requires an argument"");
        }
        options.addPlatformModuleSystemOptions(option, args[nArg]);
      } else if (arg.equals(""-version"")) {
        version();
      } else if (arg.startsWith(""-h"") || arg.equals(""--help"")) {
        help(false);
      } else if (arg.startsWith(""-"")) {
        usage(""invalid flag: "" + arg);
      } else {
        break;
      }
      ++nArg;
    }

    while (nArg < args.length) {
      options.sourceFiles.add(args[nArg++]);
    }
    if (options.sourceFiles.isEmpty()) {
      usage(""no source files"");
    }

    return options;
  }
}
","maxVersion
",sourceVersion,sourceVersion,maxSupportedVersion,maxSupportedVersion,
"package com.alibaba.json.bvt.parser;

import java.io.Reader;
import java.io.StringReader;

import org.junit.Assert;
import junit.framework.TestCase;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.parser.DefaultJSONParser;
import com.alibaba.fastjson.parser.JSONReaderScanner;

public class JSONReaderScannerTest_int extends TestCase {

    public void test_scanInt() throws Exception {
        StringBuffer buf = new StringBuffer();
        buf.append('[');
        for (int i = 0; i < 1024; ++i) {
            if (i != 0) {
                buf.append(',');
            }
            buf.append(i);
        }
        buf.append(']');

        Reader reader = new StringReader(buf.toString());

        JSONReaderScanner  [MASK]  = new JSONReaderScanner(reader);

        DefaultJSONParser parser = new DefaultJSONParser( [MASK] );
        JSONArray array = (JSONArray) parser.parse();
        for (int i = 0; i < array.size(); ++i) {
            Assert.assertEquals(i, ((Integer) array.get(i)).intValue()); 
        }
    }
}
","scanner
",jsonReaderScan,jsonReaderScan,jsonReaderScanner,lexer,
"package com.google.android.exoplayer2.muxer;

import static com.google.android.exoplayer2.util.Assertions.checkNotNull;

import android.content.Context;
import android.media.MediaCodec;
import android.media.MediaExtractor;
import androidx.test.core.app.ApplicationProvider;
import com.google.android.exoplayer2.extractor.mp4.Mp4Extractor;
import com.google.android.exoplayer2.testutil.DumpFileAsserts;
import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
import com.google.android.exoplayer2.testutil.TestUtil;
import com.google.android.exoplayer2.util.MediaFormatUtil;
import com.google.common.collect.ImmutableList;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;

/** End to end instrumentation tests for {@link Mp4Muxer}. */
@RunWith(Parameterized.class)
public class Mp4MuxerEndToEndTest {
  private static final String H264_MP4 = ""sample.mp4"";
  private static final String H265_HDR10_MP4 = ""hdr10-720p.mp4"";
  private static final String H265_WITH_METADATA_TRACK_MP4 = ""h265_with_metadata_track.mp4"";
  private static final String AV1_MP4 = ""sample_av1.mp4"";

  @Parameters(name = ""{0}"")
  public static ImmutableList<String> mediaSamples() {
    return ImmutableList.of(H264_MP4, H265_HDR10_MP4, H265_WITH_METADATA_TRACK_MP4, AV1_MP4);
  }

  @Parameter public @MonotonicNonNull String inputFile;
  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();

  private static final String MP4_FILE_ASSET_DIRECTORY = ""media/mp4/"";
  private final Context context = ApplicationProvider.getApplicationContext();
  private @MonotonicNonNull String outputPath;
  private @MonotonicNonNull FileOutputStream outputStream;

  @Before
  public void setUp() throws Exception {
    outputPath = temporaryFolder.newFile(""muxeroutput.mp4"").getPath();
    outputStream = new FileOutputStream(outputPath);
  }

  @After
  public void tearDown() throws IOException {
    checkNotNull(outputStream).close();
  }

  @Test
  public void createMp4File_fromInputFileSampleData_matchesExpected() throws IOException {
    Mp4Muxer mp4Muxer = null;

    try {
      mp4Muxer = new Mp4Muxer.Builder(checkNotNull(outputStream)).build();
      mp4Muxer.setModificationTime(/* timestampMs= */ 500_000_000L);
      feedInputDataToMuxer(mp4Muxer, checkNotNull(inputFile));
    } finally {
      if (mp4Muxer != null) {
        mp4Muxer.close();
      }
    }

    FakeExtractorOutput fakeExtractorOutput =
        TestUtil.extractAllSamplesFromFilePath(new Mp4Extractor(), checkNotNull(outputPath));
    DumpFileAsserts.assertOutput(
        context, fakeExtractorOutput, AndroidMuxerTestUtil.getExpectedDumpFilePath(inputFile));
  }

  @Test
  public void createMp4File_muxerNotClosed_createsPartiallyWrittenValidFile() throws IOException {
    Mp4Muxer mp4Muxer = new Mp4Muxer.Builder(checkNotNull(outputStream)).build();
    mp4Muxer.setModificationTime(/* timestampMs= */ 500_000_000L);
    feedInputDataToMuxer(mp4Muxer, H265_HDR10_MP4);

    // Muxer not closed.

    // Audio sample written = 192 out of 195.
    // Video sample written = 94 out of 127.
    // Output is still a valid MP4 file.
    FakeExtractorOutput fakeExtractorOutput =
        TestUtil.extractAllSamplesFromFilePath(new Mp4Extractor(), checkNotNull(outputPath));
    DumpFileAsserts.assertOutput(
        context,
        fakeExtractorOutput,
        AndroidMuxerTestUtil.getExpectedDumpFilePath(""partial_"" + H265_HDR10_MP4));
  }

  private void feedInputDataToMuxer(Mp4Muxer mp4Muxer, String inputFileName) throws IOException {
    MediaExtractor extractor = new MediaExtractor();
    extractor.setDataSource(
        context.getResources().getAssets().openFd(MP4_FILE_ASSET_DIRECTORY + inputFileName));

    List<Mp4Muxer.TrackToken> addedTracks = new ArrayList<>();
    int sortKey = 0;
    for (int i = 0; i < extractor.getTrackCount(); i++) {
      Mp4Muxer.TrackToken trackToken =
          mp4Muxer.addTrack(
              sortKey++, MediaFormatUtil.createFormatFromMediaFormat(extractor.getTrackFormat(i)));
      addedTracks.add(trackToken);
      extractor.selectTrack(i);
    }

    do {
      MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();
      bufferInfo.flags = extractor.getSampleFlags();
      bufferInfo.offset = 0;
      bufferInfo.presentationTimeUs = extractor.getSampleTime();
      int  [MASK]  = (int) extractor.getSampleSize();
      bufferInfo.size =  [MASK] ;

      ByteBuffer sampleBuffer = ByteBuffer.allocateDirect( [MASK] );
      extractor.readSampleData(sampleBuffer, /* offset= */ 0);

      sampleBuffer.rewind();

      mp4Muxer.writeSampleData(
          addedTracks.get(extractor.getSampleTrackIndex()), sampleBuffer, bufferInfo);
    } while (extractor.advance());

    extractor.release();
  }
}
","sampleSize
",sampleSize,sampleSize,sampleBufferSizeBytes,sampleSize,
"package com.badlogic.gdx.tools.particleeditor;

import java.awt.FileDialog;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.File;

import javax.swing.ButtonGroup;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.ListSelectionModel;

import com.badlogic.gdx.graphics.g2d.ParticleEmitter;
import com.badlogic.gdx.graphics.g2d.ParticleEmitter.SpriteMode;
import com.badlogic.gdx.utils.Array;

class ImagePanel extends EditorPanel {
        JPanel imagesPanel;
        JList imageList;
        DefaultListModel<String> imageListModel;
        String lastDir;

        public ImagePanel (final ParticleEditor editor, String name, String description) {
                super(null, name, description);
                JPanel contentPanel = getContentPanel();
                {
                        JPanel buttonsPanel = new JPanel(new GridLayout(3, 1));
                        contentPanel.add(buttonsPanel, new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST,
                                GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
                        JButton addButton = new JButton(""Add"");
                        buttonsPanel.add(addButton);
                        addButton.addActionListener(new ActionListener() {
                                public void actionPerformed (ActionEvent event) {
                                        FileDialog dialog = new FileDialog(editor, ""Open Image"", FileDialog.LOAD);
                                        if (lastDir != null) dialog.setDirectory(lastDir);
                                        dialog.setMultipleMode(true);
                                        dialog.setVisible(true);
                                        final File[] files = dialog.getFiles();
                                        final String dir = dialog.getDirectory();
                                        if (dir == null || files == null) return;
                                        lastDir = dir;
                                        final ParticleEmitter emitter = editor.getEmitter();
                                        for (File file : files) {
                                                emitter.getImagePaths().add(file.getAbsolutePath());
                                        }
                                        emitter.getSprites().clear();
                                        updateImageList(emitter.getImagePaths());
                                }
                        });
                        JButton defaultButton = new JButton(""Default"");
                        buttonsPanel.add(defaultButton);
                        defaultButton.addActionListener(new ActionListener() {
                                @Override
                                public void actionPerformed (ActionEvent e) {
                                        final ParticleEmitter emitter = editor.getEmitter();
                                        emitter.setImagePaths(new Array<String>(new String[] {ParticleEditor.DEFAULT_PARTICLE}));
                                        emitter.getSprites().clear();
                                        updateImageList(emitter.getImagePaths());
                                }
                        });
                        JButton defaultPremultButton = new JButton(""Default (Premultiplied Alpha)"");
                        buttonsPanel.add(defaultPremultButton);
                        defaultPremultButton.addActionListener(new ActionListener() {
                                @Override
                                public void actionPerformed (ActionEvent e) {
                                        final ParticleEmitter emitter = editor.getEmitter();
                                        emitter.setImagePaths(new Array<String>(new String[] {ParticleEditor.DEFAULT_PREMULT_PARTICLE}));
                                        emitter.getSprites().clear();
                                        updateImageList(emitter.getImagePaths());
                                }
                        });
                }
                {
                        JPanel modesPanel = new JPanel(new GridLayout(4, 1));
                        contentPanel.add(modesPanel, new GridBagConstraints(1, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST,
                                GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
                        JLabel label = new JLabel(""Sprite mode:"");
                        modesPanel.add(label);
                        ButtonGroup checkboxGroup = new ButtonGroup();
                        JRadioButton singleCheckbox = new JRadioButton(""Single"", editor.getEmitter().getSpriteMode() == SpriteMode.single);
                        modesPanel.add(singleCheckbox);
                        checkboxGroup.add(singleCheckbox);
                        singleCheckbox.addItemListener(new ItemListener() {
                                @Override
                                public void itemStateChanged (ItemEvent e) {
                                        if (e.getStateChange() == ItemEvent.SELECTED) {
                                                editor.getEmitter().setSpriteMode(SpriteMode.single);
                                        }
                                }
                        });
                        JRadioButton randomCheckbox = new JRadioButton(""Random"", editor.getEmitter().getSpriteMode() == SpriteMode.random);
                        modesPanel.add(randomCheckbox);
                        checkboxGroup.add(randomCheckbox);
                        randomCheckbox.addItemListener(new ItemListener() {
                                @Override
                                public void itemStateChanged (ItemEvent e) {
                                        if (e.getStateChange() == ItemEvent.SELECTED) {
                                                editor.getEmitter().setSpriteMode(SpriteMode.random);
                                        }
                                }
                        });
                        JRadioButton animatedCheckbox = new JRadioButton(""Animated"", editor.getEmitter().getSpriteMode() == SpriteMode.animated);
                        modesPanel.add(animatedCheckbox);
                        checkboxGroup.add(animatedCheckbox);
                        animatedCheckbox.addItemListener(new ItemListener() {
                                @Override
                                public void itemStateChanged (ItemEvent e) {
                                        if (e.getStateChange() == ItemEvent.SELECTED) {
                                                editor.getEmitter().setSpriteMode(SpriteMode.animated);
                                        }
                                }
                        });
                }
                {
                        imagesPanel = new JPanel(new GridBagLayout());
                        contentPanel.add(imagesPanel, new GridBagConstraints(2, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST,
                                GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
                        imageListModel = new DefaultListModel<String>();
                        imageList = new JList<String>(imageListModel);
                        imageList.setFixedCellWidth(250);
                        imageList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
                        imagesPanel.add(imageList, new GridBagConstraints(0, 0, 1, 3, 0, 0, GridBagConstraints.NORTHWEST,
                                GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
                        JButton upButton = new JButton(""\u2191"");
                        imagesPanel.add(upButton, new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,
                                new Insets(0, 0, 0, 0), 0, 0));
                        upButton.addActionListener(new ActionListener() {
                                @Override
                                public void actionPerformed (ActionEvent e) {
                                        int index = imageList.getSelectedIndex();
                                        if (index <= 0) return;
                                        final ParticleEmitter emitter = editor.getEmitter();
                                        String imagePath = emitter.getImagePaths().removeIndex(index);
                                        emitter.getImagePaths().insert(index - 1, imagePath);
                                        emitter.getSprites().clear();
                                        updateImageList(emitter.getImagePaths());
                                        imageList.setSelectedIndex(index - 1);
                                }
                        });
                        JButton downButton = new JButton(""\u2193"");
                        imagesPanel.add(downButton, new GridBagConstraints(1, 1, 1, 1, 0, 0, GridBagConstraints.NORTHWEST,
                                GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
                        downButton.addActionListener(new ActionListener() {
                                @Override
                                public void actionPerformed (ActionEvent e) {
                                        int index = imageList.getSelectedIndex();
                                        if (index < 0 || index >= imageList.getModel().getSize() - 1) return;
                                        final ParticleEmitter emitter = editor.getEmitter();
                                        String imagePath = emitter.getImagePaths().removeIndex(index);
                                        emitter.getImagePaths().insert(index + 1, imagePath);
                                        emitter.getSprites().clear();
                                        updateImageList(emitter.getImagePaths());
                                        imageList.setSelectedIndex(index + 1);
                                }
                        });
                        JButton  [MASK]  = new JButton(""X"");
                        imagesPanel.add( [MASK] , new GridBagConstraints(1, 2, 1, 1, 0, 0, GridBagConstraints.NORTHWEST,
                                GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
                         [MASK] .addActionListener(new ActionListener() {
                                @Override
                                public void actionPerformed (ActionEvent e) {
                                        int index = imageList.getSelectedIndex();
                                        if (index < 0) return;
                                        final ParticleEmitter emitter = editor.getEmitter();
                                        Array<String> imagePaths = emitter.getImagePaths();
                                        imagePaths.removeIndex(index);
                                        if (imagePaths.size == 0) imagePaths.add(ParticleEditor.DEFAULT_PARTICLE);
                                        emitter.getSprites().clear();
                                        updateImageList(imagePaths);
                                }
                        });
                }
                updateImageList(editor.getEmitter().getImagePaths());
        }

        public void updateImageList (Array<String> imagePaths) {
                if (imagePaths != null && imagePaths.size > 0) {
                        imagesPanel.setVisible(true);
                        imageListModel.removeAllElements();
                        for (String imagePath : imagePaths) {
                                imageListModel.addElement(new File(imagePath).getName());
                        }
                } else {
                        imagesPanel.setVisible(false);
                }
                revalidate();
        }
}
","removeButton
",xButton,xButton,removeButton,removeButton,
"package com.badlogic.gdx.maps.tiled;

import com.badlogic.gdx.assets.AssetDescriptor;
import com.badlogic.gdx.assets.AssetLoaderParameters;
import com.badlogic.gdx.assets.AssetManager;
import com.badlogic.gdx.assets.loaders.FileHandleResolver;
import com.badlogic.gdx.assets.loaders.SynchronousAssetLoader;
import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.maps.ImageResolver;
import com.badlogic.gdx.maps.ImageResolver.AssetManagerImageResolver;
import com.badlogic.gdx.maps.ImageResolver.DirectImageResolver;
import com.badlogic.gdx.maps.MapProperties;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
import com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile;
import com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.GdxRuntimeException;
import com.badlogic.gdx.utils.ObjectMap;
import com.badlogic.gdx.utils.XmlReader;
import com.badlogic.gdx.utils.XmlReader.Element;

import java.io.IOException;
import java.util.StringTokenizer;

public class TideMapLoader extends SynchronousAssetLoader<TiledMap, TideMapLoader.Parameters> {

        public static class Parameters extends AssetLoaderParameters<TiledMap> {

        }

        private XmlReader xml = new XmlReader();
        private Element root;

        public TideMapLoader () {
                super(new InternalFileHandleResolver());
        }

        public TideMapLoader (FileHandleResolver resolver) {
                super(resolver);
        }

        public TiledMap load (String fileName) {
                try {
                        FileHandle tideFile = resolve(fileName);
                        root = xml.parse(tideFile);
                        ObjectMap<String, Texture> textures = new ObjectMap<String, Texture>();
                        for (FileHandle textureFile : loadTileSheets(root, tideFile)) {
                                textures.put(textureFile.path(), new Texture(textureFile));
                        }
                        DirectImageResolver imageResolver = new DirectImageResolver(textures);
                        TiledMap map = loadMap(root, tideFile, imageResolver);
                        map.setOwnedResources(textures.values().toArray());
                        return map;
                } catch (IOException e) {
                        throw new GdxRuntimeException(""Couldn't load tilemap '"" + fileName + ""'"", e);
                }

        }

        @Override
        public TiledMap load (AssetManager assetManager, String fileName, FileHandle tideFile, Parameters parameter) {
                try {
                        return loadMap(root, tideFile, new AssetManagerImageResolver(assetManager));
                } catch (Exception e) {
                        throw new GdxRuntimeException(""Couldn't load tilemap '"" + fileName + ""'"", e);
                }
        }

        @Override
        public Array<AssetDescriptor> getDependencies (String fileName, FileHandle tmxFile, Parameters parameter) {
                Array<AssetDescriptor> dependencies = new Array<AssetDescriptor>();
                try {
                        root = xml.parse(tmxFile);
                        for (FileHandle image : loadTileSheets(root, tmxFile)) {
                                dependencies.add(new AssetDescriptor(image.path(), Texture.class));
                        }
                        return dependencies;
                } catch (IOException e) {
                        throw new GdxRuntimeException(""Couldn't load tilemap '"" + fileName + ""'"", e);
                }
        }

        /** Loads the map data, given the XML root element and an {@link ImageResolver} used to return the tileset Textures
         * @param root the XML root element
         * @param tmxFile the Filehandle of the tmx file
         * @param imageResolver the {@link ImageResolver}
         * @return the {@link TiledMap} */
        private TiledMap loadMap (Element root, FileHandle tmxFile, ImageResolver imageResolver) {
                TiledMap map = new TiledMap();
                Element properties = root.getChildByName(""Properties"");
                if (properties != null) {
                        loadProperties(map.getProperties(), properties);
                }
                Element tilesheets = root.getChildByName(""TileSheets"");
                for (Element tilesheet : tilesheets.getChildrenByName(""TileSheet"")) {
                        loadTileSheet(map, tilesheet, tmxFile, imageResolver);
                }
                Element layers = root.getChildByName(""Layers"");
                for (Element layer : layers.getChildrenByName(""Layer"")) {
                        loadLayer(map, layer);
                }
                return map;
        }

        /** Loads the tilesets
         * @param root the root XML element
         * @return a list of filenames for images containing tiles
         * @throws IOException */
        private Array<FileHandle> loadTileSheets (Element root, FileHandle tideFile) throws IOException {
                Array<FileHandle> images = new Array<FileHandle>();
                Element tilesheets = root.getChildByName(""TileSheets"");
                for (Element tileset : tilesheets.getChildrenByName(""TileSheet"")) {
                        Element imageSource = tileset.getChildByName(""ImageSource"");
                        FileHandle image = getRelativeFileHandle(tideFile, imageSource.getText());
                        images.add(image);
                }
                return images;
        }

        private void loadTileSheet (TiledMap map, Element element, FileHandle tideFile, ImageResolver imageResolver) {
                if (element.getName().equals(""TileSheet"")) {
                        String id = element.getAttribute(""Id"");
                        String description = element.getChildByName(""Description"").getText();
                        String imageSource = element.getChildByName(""ImageSource"").getText();

                        Element  [MASK]  = element.getChildByName(""Alignment"");
                        String sheetSize =  [MASK] .getAttribute(""SheetSize"");
                        String tileSize =  [MASK] .getAttribute(""TileSize"");
                        String margin =  [MASK] .getAttribute(""Margin"");
                        String spacing =  [MASK] .getAttribute(""Spacing"");

                        String[] sheetSizeParts = sheetSize.split("" x "");
                        int sheetSizeX = Integer.parseInt(sheetSizeParts[0]);
                        int sheetSizeY = Integer.parseInt(sheetSizeParts[1]);

                        String[] tileSizeParts = tileSize.split("" x "");
                        int tileSizeX = Integer.parseInt(tileSizeParts[0]);
                        int tileSizeY = Integer.parseInt(tileSizeParts[1]);

                        String[] marginParts = margin.split("" x "");
                        int marginX = Integer.parseInt(marginParts[0]);
                        int marginY = Integer.parseInt(marginParts[1]);

                        String[] spacingParts = margin.split("" x "");
                        int spacingX = Integer.parseInt(spacingParts[0]);
                        int spacingY = Integer.parseInt(spacingParts[1]);

                        FileHandle image = getRelativeFileHandle(tideFile, imageSource);
                        TextureRegion texture = imageResolver.getImage(image.path());

                        TiledMapTileSets tilesets = map.getTileSets();
                        int firstgid = 1;
                        for (TiledMapTileSet tileset : tilesets) {
                                firstgid += tileset.size();
                        }

                        TiledMapTileSet tileset = new TiledMapTileSet();
                        tileset.setName(id);
                        tileset.getProperties().put(""firstgid"", firstgid);
                        int gid = firstgid;

                        int stopWidth = texture.getRegionWidth() - tileSizeX;
                        int stopHeight = texture.getRegionHeight() - tileSizeY;

                        for (int y = marginY; y <= stopHeight; y += tileSizeY + spacingY) {
                                for (int x = marginX; x <= stopWidth; x += tileSizeX + spacingX) {
                                        TiledMapTile tile = new StaticTiledMapTile(new TextureRegion(texture, x, y, tileSizeX, tileSizeY));
                                        tile.setId(gid);
                                        tileset.putTile(gid++, tile);
                                }
                        }

                        Element properties = element.getChildByName(""Properties"");
                        if (properties != null) {
                                loadProperties(tileset.getProperties(), properties);
                        }

                        tilesets.addTileSet(tileset);
                }
        }

        private void loadLayer (TiledMap map, Element element) {
                if (element.getName().equals(""Layer"")) {
                        String id = element.getAttribute(""Id"");
                        String visible = element.getAttribute(""Visible"");

                        Element dimensions = element.getChildByName(""Dimensions"");
                        String layerSize = dimensions.getAttribute(""LayerSize"");
                        String tileSize = dimensions.getAttribute(""TileSize"");

                        String[] layerSizeParts = layerSize.split("" x "");
                        int layerSizeX = Integer.parseInt(layerSizeParts[0]);
                        int layerSizeY = Integer.parseInt(layerSizeParts[1]);

                        String[] tileSizeParts = tileSize.split("" x "");
                        int tileSizeX = Integer.parseInt(tileSizeParts[0]);
                        int tileSizeY = Integer.parseInt(tileSizeParts[1]);

                        TiledMapTileLayer layer = new TiledMapTileLayer(layerSizeX, layerSizeY, tileSizeX, tileSizeY);
                        layer.setName(id);
                        layer.setVisible(visible.equalsIgnoreCase(""True""));
                        Element tileArray = element.getChildByName(""TileArray"");
                        Array<Element> rows = tileArray.getChildrenByName(""Row"");
                        TiledMapTileSets tilesets = map.getTileSets();
                        TiledMapTileSet currentTileSet = null;
                        int firstgid = 0;
                        int x, y;
                        for (int row = 0, rowCount = rows.size; row < rowCount; row++) {
                                Element currentRow = rows.get(row);
                                y = rowCount - 1 - row;
                                x = 0;
                                for (int child = 0, childCount = currentRow.getChildCount(); child < childCount; child++) {
                                        Element currentChild = currentRow.getChild(child);
                                        String name = currentChild.getName();
                                        if (name.equals(""TileSheet"")) {
                                                currentTileSet = tilesets.getTileSet(currentChild.getAttribute(""Ref""));
                                                firstgid = currentTileSet.getProperties().get(""firstgid"", Integer.class);
                                        } else if (name.equals(""Null"")) {
                                                x += currentChild.getIntAttribute(""Count"");
                                        } else if (name.equals(""Static"")) {
                                                Cell cell = new Cell();
                                                cell.setTile(currentTileSet.getTile(firstgid + currentChild.getIntAttribute(""Index"")));
                                                layer.setCell(x++, y, cell);
                                        } else if (name.equals(""Animated"")) {
                                                // Create an AnimatedTile
                                                int interval = currentChild.getInt(""Interval"");
                                                Element frames = currentChild.getChildByName(""Frames"");
                                                Array<StaticTiledMapTile> frameTiles = new Array<StaticTiledMapTile>();
                                                for (int frameChild = 0, frameChildCount = frames.getChildCount(); frameChild < frameChildCount; frameChild++) {
                                                        Element frame = frames.getChild(frameChild);
                                                        String frameName = frame.getName();
                                                        if (frameName.equals(""TileSheet"")) {
                                                                currentTileSet = tilesets.getTileSet(frame.getAttribute(""Ref""));
                                                                firstgid = currentTileSet.getProperties().get(""firstgid"", Integer.class);
                                                        } else if (frameName.equals(""Static"")) {
                                                                frameTiles.add((StaticTiledMapTile)currentTileSet.getTile(firstgid + frame.getIntAttribute(""Index"")));
                                                        }
                                                }
                                                Cell cell = new Cell();
                                                cell.setTile(new AnimatedTiledMapTile(interval / 1000f, frameTiles));
                                                layer.setCell(x++, y, cell); // TODO: Reuse existing animated tiles
                                        }
                                }
                        }

                        Element properties = element.getChildByName(""Properties"");
                        if (properties != null) {
                                loadProperties(layer.getProperties(), properties);
                        }

                        map.getLayers().add(layer);
                }
        }

        private void loadProperties (MapProperties properties, Element element) {
                if (element.getName().equals(""Properties"")) {
                        for (Element property : element.getChildrenByName(""Property"")) {
                                String key = property.getAttribute(""Key"", null);
                                String type = property.getAttribute(""Type"", null);
                                String value = property.getText();

                                if (type.equals(""Int32"")) {
                                        properties.put(key, Integer.parseInt(value));
                                } else if (type.equals(""String"")) {
                                        properties.put(key, value);
                                } else if (type.equals(""Boolean"")) {
                                        properties.put(key, value.equalsIgnoreCase(""true""));
                                } else {
                                        properties.put(key, value);
                                }
                        }
                }
        }

        private static FileHandle getRelativeFileHandle (FileHandle file, String path) {
                StringTokenizer tokenizer = new StringTokenizer(path, ""\\/"");
                FileHandle result = file.parent();
                while (tokenizer.hasMoreElements()) {
                        String token = tokenizer.nextToken();
                        if (token.equals(""..""))
                                result = result.parent();
                        else {
                                result = result.child(token);
                        }
                }
                return result;
        }

}
","alignment
",alSheAl,tiledAlignment,alignmentElement,tileAlignment,
"

package com.facebook.drawee.generic;

import android.content.res.Resources;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.drawable.Animatable;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import androidx.annotation.VisibleForTesting;
import com.facebook.common.internal.Preconditions;
import com.facebook.drawee.drawable.DrawableParent;
import com.facebook.drawee.drawable.FadeDrawable;
import com.facebook.drawee.drawable.ForwardingDrawable;
import com.facebook.drawee.drawable.MatrixDrawable;
import com.facebook.drawee.drawable.ScaleTypeDrawable;
import com.facebook.drawee.drawable.ScalingUtils;
import com.facebook.drawee.interfaces.SettableDraweeHierarchy;
import com.facebook.fresco.ui.common.OnFadeListener;
import com.facebook.imagepipeline.systrace.FrescoSystrace;
import javax.annotation.Nullable;

/**
 * A SettableDraweeHierarchy that displays placeholder image until the actual image is set. If
 * provided, failure image will be used in case of failure (placeholder otherwise). If provided,
 * retry image will be used in case of failure when retrying is enabled. If provided, progressbar
 * will be displayed until fully loaded. Each image can be displayed with a different scale type (or
 * no scaling at all). Fading between the layers is supported. Rounding is supported.
 *
 * <p>Example hierarchy with a placeholder, retry, failure and the actual image:
 *
 * <pre>
 *  o RootDrawable (top level drawable)
 *  |
 *  +--o FadeDrawable
 *     |
 *     +--o ScaleTypeDrawable (placeholder branch, optional)
 *     |  |
 *     |  +--o Drawable (placeholder image)
 *     |
 *     +--o ScaleTypeDrawable (actual image branch)
 *     |  |
 *     |  +--o ForwardingDrawable (actual image wrapper)
 *     |     |
 *     |     +--o Drawable (actual image)
 *     |
 *     +--o null (progress bar branch, optional)
 *     |
 *     +--o Drawable (retry image branch, optional)
 *     |
 *     +--o ScaleTypeDrawable (failure image branch, optional)
 *        |
 *        +--o Drawable (failure image)
 *  </pre>
 *
 * <p>Note:
 *
 * <ul>
 *   <li>RootDrawable and FadeDrawable are always created.
 *   <li>All branches except the actual image branch are optional (placeholder, failure, retry,
 *       progress bar). If some branch is not specified it won't be created. Index in FadeDrawable
 *       will still be reserved though.
 *   <li>If overlays and/or background are specified, they are added to the same fade drawable, and
 *       are always being displayed.
 *   <li>ScaleType and Matrix transformations will be added only if specified. If both are
 *       unspecified, then the branch for that image is attached to FadeDrawable directly. Matrix
 *       transformation is only supported for the actual image, and it is not recommended to be
 *       used.
 *   <li>Rounding, if specified, is applied to all layers. Rounded drawable can either wrap
 *       FadeDrawable, or if leaf rounding is specified, each leaf drawable will be rounded
 *       separately.
 *   <li>A particular drawable instance should be used by only one DH. If more than one DH is being
 *       built with the same builder, different drawable instances must be specified for each DH.
 * </ul>
 */
public class GenericDraweeHierarchy implements SettableDraweeHierarchy {

  private static final int BACKGROUND_IMAGE_INDEX = 0;
  private static final int PLACEHOLDER_IMAGE_INDEX = 1;
  private static final int ACTUAL_IMAGE_INDEX = 2;
  private static final int PROGRESS_BAR_IMAGE_INDEX = 3;
  private static final int RETRY_IMAGE_INDEX = 4;
  private static final int FAILURE_IMAGE_INDEX = 5;
  private static final int OVERLAY_IMAGES_INDEX = 6;

  private final Drawable mEmptyActualImageDrawable = new ColorDrawable(Color.TRANSPARENT);

  private final Resources mResources;
  private @Nullable RoundingParams mRoundingParams;

  private final RootDrawable mTopLevelDrawable;
  private final FadeDrawable mFadeDrawable;
  private final ForwardingDrawable mActualImageWrapper;

  GenericDraweeHierarchy(GenericDraweeHierarchyBuilder builder) {
    if (FrescoSystrace.isTracing()) {
      FrescoSystrace.beginSection(""GenericDraweeHierarchy()"");
    }
    mResources = builder.getResources();
    mRoundingParams = builder.getRoundingParams();

    mActualImageWrapper = new ForwardingDrawable(mEmptyActualImageDrawable);

    int numOverlays = (builder.getOverlays() != null) ? builder.getOverlays().size() : 1;

    // make sure there is at least one overlay to make setOverlayImage(Drawable)
    // method work.
    if (numOverlays == 0) {
      numOverlays = 1;
    }

    numOverlays += (builder.getPressedStateOverlay() != null) ? 1 : 0;

    // layer indices and count
    int numLayers = OVERLAY_IMAGES_INDEX + numOverlays;

    // array of layers
    Drawable[] layers = new Drawable[numLayers];
    layers[BACKGROUND_IMAGE_INDEX] = buildBranch(builder.getBackground(), null);
    layers[PLACEHOLDER_IMAGE_INDEX] =
        buildBranch(builder.getPlaceholderImage(), builder.getPlaceholderImageScaleType());
    layers[ACTUAL_IMAGE_INDEX] =
        buildActualImageBranch(
            mActualImageWrapper,
            builder.getActualImageScaleType(),
            builder.getActualImageFocusPoint(),
            builder.getActualImageColorFilter());
    layers[PROGRESS_BAR_IMAGE_INDEX] =
        buildBranch(builder.getProgressBarImage(), builder.getProgressBarImageScaleType());
    layers[RETRY_IMAGE_INDEX] =
        buildBranch(builder.getRetryImage(), builder.getRetryImageScaleType());
    layers[FAILURE_IMAGE_INDEX] =
        buildBranch(builder.getFailureImage(), builder.getFailureImageScaleType());
    if (numOverlays > 0) {
      int index = 0;
      if (builder.getOverlays() != null) {
        for (Drawable overlay : builder.getOverlays()) {
          layers[OVERLAY_IMAGES_INDEX + index++] = buildBranch(overlay, null);
        }
      } else {
        index = 1; // reserve space for one overlay
      }
      if (builder.getPressedStateOverlay() != null) {
        layers[OVERLAY_IMAGES_INDEX + index] = buildBranch(builder.getPressedStateOverlay(), null);
      }
    }

    // fade drawable composed of layers
    mFadeDrawable = new FadeDrawable(layers, false, ACTUAL_IMAGE_INDEX);
    mFadeDrawable.setTransitionDuration(builder.getFadeDuration());

    // rounded corners drawable (optional)
    Drawable maybeRoundedDrawable =
        WrappingUtils.maybeWrapWithRoundedOverlayColor(mFadeDrawable, mRoundingParams);

    // top-level drawable
    mTopLevelDrawable = new RootDrawable(maybeRoundedDrawable);
    mTopLevelDrawable.mutate();

    resetFade();
    if (FrescoSystrace.isTracing()) {
      FrescoSystrace.endSection();
    }
  }

  @Nullable
  private Drawable buildActualImageBranch(
      Drawable drawable,
      @Nullable ScalingUtils.ScaleType scaleType,
      @Nullable PointF  [MASK] ,
      @Nullable ColorFilter colorFilter) {
    drawable.setColorFilter(colorFilter);
    drawable = WrappingUtils.maybeWrapWithScaleType(drawable, scaleType,  [MASK] );
    return drawable;
  }

  /** Applies scale type and rounding (both if specified). */
  @Nullable
  private Drawable buildBranch(
      @Nullable Drawable drawable, @Nullable ScalingUtils.ScaleType scaleType) {
    drawable = WrappingUtils.maybeApplyLeafRounding(drawable, mRoundingParams, mResources);
    drawable = WrappingUtils.maybeWrapWithScaleType(drawable, scaleType);
    return drawable;
  }

  private void resetActualImages() {
    mActualImageWrapper.setDrawable(mEmptyActualImageDrawable);
  }

  private void resetFade() {
    if (mFadeDrawable != null) {
      mFadeDrawable.beginBatchMode();
      // turn on all layers (backgrounds, branches, overlays)
      mFadeDrawable.fadeInAllLayers();
      // turn off branches (leaving backgrounds and overlays on)
      fadeOutBranches();
      // turn on placeholder
      fadeInLayer(PLACEHOLDER_IMAGE_INDEX);
      mFadeDrawable.finishTransitionImmediately();
      mFadeDrawable.endBatchMode();
    }
  }

  private void fadeOutBranches() {
    fadeOutLayer(PLACEHOLDER_IMAGE_INDEX);
    fadeOutLayer(ACTUAL_IMAGE_INDEX);
    fadeOutLayer(PROGRESS_BAR_IMAGE_INDEX);
    fadeOutLayer(RETRY_IMAGE_INDEX);
    fadeOutLayer(FAILURE_IMAGE_INDEX);
  }

  private void fadeInLayer(int index) {
    if (index >= 0) {
      mFadeDrawable.fadeInLayer(index);
    }
  }

  private void fadeOutLayer(int index) {
    if (index >= 0) {
      mFadeDrawable.fadeOutLayer(index);
    }
  }

  private void setProgress(float progress) {
    Drawable progressBarDrawable = mFadeDrawable.getDrawable(PROGRESS_BAR_IMAGE_INDEX);
    if (progressBarDrawable == null) {
      return;
    }

    // display progressbar when not fully loaded, hide otherwise
    if (progress >= 0.999f) {
      if (progressBarDrawable instanceof Animatable) {
        ((Animatable) progressBarDrawable).stop();
      }
      fadeOutLayer(PROGRESS_BAR_IMAGE_INDEX);
    } else {
      if (progressBarDrawable instanceof Animatable) {
        ((Animatable) progressBarDrawable).start();
      }
      fadeInLayer(PROGRESS_BAR_IMAGE_INDEX);
    }
    // set drawable level, scaled to [0, 10000] per drawable specification
    progressBarDrawable.setLevel(Math.round(progress * 10000));
  }

  // SettableDraweeHierarchy interface

  @Override
  public Drawable getTopLevelDrawable() {
    return mTopLevelDrawable;
  }

  @Override
  public void reset() {
    resetActualImages();
    resetFade();
  }

  @Override
  public void setImage(Drawable drawable, float progress, boolean immediate) {
    drawable = WrappingUtils.maybeApplyLeafRounding(drawable, mRoundingParams, mResources);
    drawable.mutate();
    mActualImageWrapper.setDrawable(drawable);
    mFadeDrawable.beginBatchMode();
    fadeOutBranches();
    fadeInLayer(ACTUAL_IMAGE_INDEX);
    setProgress(progress);
    if (immediate) {
      mFadeDrawable.finishTransitionImmediately();
    }
    mFadeDrawable.endBatchMode();
  }

  @Override
  public void setProgress(float progress, boolean immediate) {
    if (mFadeDrawable.getDrawable(PROGRESS_BAR_IMAGE_INDEX) == null) {
      return;
    }
    mFadeDrawable.beginBatchMode();
    setProgress(progress);
    if (immediate) {
      mFadeDrawable.finishTransitionImmediately();
    }
    mFadeDrawable.endBatchMode();
  }

  @Override
  public void setFailure(Throwable throwable) {
    mFadeDrawable.beginBatchMode();
    fadeOutBranches();
    if (mFadeDrawable.getDrawable(FAILURE_IMAGE_INDEX) != null) {
      fadeInLayer(FAILURE_IMAGE_INDEX);
    } else {
      fadeInLayer(PLACEHOLDER_IMAGE_INDEX);
    }
    mFadeDrawable.endBatchMode();
  }

  @Override
  public void setRetry(Throwable throwable) {
    mFadeDrawable.beginBatchMode();
    fadeOutBranches();
    if (mFadeDrawable.getDrawable(RETRY_IMAGE_INDEX) != null) {
      fadeInLayer(RETRY_IMAGE_INDEX);
    } else {
      fadeInLayer(PLACEHOLDER_IMAGE_INDEX);
    }
    mFadeDrawable.endBatchMode();
  }

  @Override
  public void setControllerOverlay(@Nullable Drawable drawable) {
    mTopLevelDrawable.setControllerOverlay(drawable);
  }

  @Override
  public Rect getBounds() {
    return mTopLevelDrawable.getBounds();
  }

  // Helper methods for accessing layers

  /**
   * Gets the lowest parent drawable for the layer at the specified index.
   *
   * <p>Following drawables are considered as parents: FadeDrawable, MatrixDrawable,
   * ScaleTypeDrawable. This is because those drawables are added automatically by the hierarchy (if
   * specified), whereas their children are created externally by the client code. When we need to
   * change the previously set drawable this is the parent whose child needs to be replaced.
   */
  private DrawableParent getParentDrawableAtIndex(int index) {
    DrawableParent parent = mFadeDrawable.getDrawableParentForIndex(index);
    if (parent.getDrawable() instanceof MatrixDrawable) {
      parent = (MatrixDrawable) parent.getDrawable();
    }
    if (parent.getDrawable() instanceof ScaleTypeDrawable) {
      parent = (ScaleTypeDrawable) parent.getDrawable();
    }
    return parent;
  }

  /**
   * Sets the drawable at the specified index while keeping the old scale type and rounding. In case
   * the given drawable is null, scale type gets cleared too.
   */
  private void setChildDrawableAtIndex(int index, @Nullable Drawable drawable) {
    if (drawable == null) {
      mFadeDrawable.setDrawable(index, null);
      return;
    }
    drawable = WrappingUtils.maybeApplyLeafRounding(drawable, mRoundingParams, mResources);
    getParentDrawableAtIndex(index).setDrawable(drawable);
  }

  /**
   * Gets the ScaleTypeDrawable at the specified index. In case there is no child at the specified
   * index, a NullPointerException is thrown. In case there is a child, but the ScaleTypeDrawable
   * does not exist, the child will be wrapped with a new ScaleTypeDrawable.
   */
  private ScaleTypeDrawable getScaleTypeDrawableAtIndex(int index) {
    DrawableParent parent = getParentDrawableAtIndex(index);
    if (parent instanceof ScaleTypeDrawable) {
      return (ScaleTypeDrawable) parent;
    } else {
      return WrappingUtils.wrapChildWithScaleType(parent, ScalingUtils.ScaleType.FIT_XY);
    }
  }

  /** Returns whether the given layer has a scale type drawable. */
  private boolean hasScaleTypeDrawableAtIndex(int index) {
    DrawableParent parent = getParentDrawableAtIndex(index);
    return (parent instanceof ScaleTypeDrawable);
  }

  // Mutability

  /** Sets the fade duration. */
  public void setFadeDuration(int durationMs) {
    mFadeDrawable.setTransitionDuration(durationMs);
  }

  /** Gets the fade duration. */
  public int getFadeDuration() {
    return mFadeDrawable.getTransitionDuration();
  }

  /** Sets the actual image focus point. */
  public void setActualImageFocusPoint(PointF  [MASK] ) {
    Preconditions.checkNotNull( [MASK] );
    getScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX).setFocusPoint( [MASK] );
  }

  /** Sets the actual image scale type. */
  public void setActualImageScaleType(ScalingUtils.ScaleType scaleType) {
    Preconditions.checkNotNull(scaleType);
    getScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX).setScaleType(scaleType);
  }

  public @Nullable ScalingUtils.ScaleType getActualImageScaleType() {
    if (!hasScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX)) {
      return null;
    }
    return getScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX).getScaleType();
  }

  public @Nullable PointF getActualImageFocusPoint() {
    if (!hasScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX)) {
      return null;
    }
    return getScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX).getFocusPoint();
  }

  /** Sets the color filter to be applied on the actual image. */
  public void setActualImageColorFilter(@Nullable ColorFilter colorfilter) {
    mActualImageWrapper.setColorFilter(colorfilter);
  }

  /** Gets the non-cropped post-scaling bounds of the actual image. */
  public void getActualImageBounds(RectF outBounds) {
    mActualImageWrapper.getTransformedBounds(outBounds);
  }

  /** Sets a new placeholder drawable with old scale type. */
  public void setPlaceholderImage(@Nullable Drawable drawable) {
    setChildDrawableAtIndex(PLACEHOLDER_IMAGE_INDEX, drawable);
  }

  /** Sets a new placeholder drawable with scale type. */
  public void setPlaceholderImage(Drawable drawable, ScalingUtils.ScaleType scaleType) {
    setChildDrawableAtIndex(PLACEHOLDER_IMAGE_INDEX, drawable);
    getScaleTypeDrawableAtIndex(PLACEHOLDER_IMAGE_INDEX).setScaleType(scaleType);
  }

  /** @return true if there is a placeholder image set. */
  public boolean hasPlaceholderImage() {
    return mFadeDrawable.getDrawable(PLACEHOLDER_IMAGE_INDEX) != null;
  }

  /** Sets the placeholder image focus point. */
  public void setPlaceholderImageFocusPoint(PointF  [MASK] ) {
    Preconditions.checkNotNull( [MASK] );
    getScaleTypeDrawableAtIndex(PLACEHOLDER_IMAGE_INDEX).setFocusPoint( [MASK] );
  }

  /**
   * Sets a new placeholder drawable with old scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   */
  public void setPlaceholderImage(int resourceId) {
    setPlaceholderImage(mResources.getDrawable(resourceId));
  }

  /**
   * Sets a new placeholder drawable with scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   * @param ScalingUtils.ScaleType a new scale type.
   */
  public void setPlaceholderImage(int resourceId, ScalingUtils.ScaleType scaleType) {
    setPlaceholderImage(mResources.getDrawable(resourceId), scaleType);
  }

  /** Sets a new failure drawable with old scale type. */
  public void setFailureImage(@Nullable Drawable drawable) {
    setChildDrawableAtIndex(FAILURE_IMAGE_INDEX, drawable);
  }

  /** Sets a new failure drawable with scale type. */
  public void setFailureImage(Drawable drawable, ScalingUtils.ScaleType scaleType) {
    setChildDrawableAtIndex(FAILURE_IMAGE_INDEX, drawable);
    getScaleTypeDrawableAtIndex(FAILURE_IMAGE_INDEX).setScaleType(scaleType);
  }

  /**
   * Sets a new failure drawable with old scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   */
  public void setFailureImage(int resourceId) {
    setFailureImage(mResources.getDrawable(resourceId));
  }

  /**
   * Sets a new failure drawable with scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   * @param ScalingUtils.ScaleType a new scale type.
   */
  public void setFailureImage(int resourceId, ScalingUtils.ScaleType scaleType) {
    setFailureImage(mResources.getDrawable(resourceId), scaleType);
  }

  /** Sets a new retry drawable with old scale type. */
  public void setRetryImage(@Nullable Drawable drawable) {
    setChildDrawableAtIndex(RETRY_IMAGE_INDEX, drawable);
  }

  /** Sets a new retry drawable with scale type. */
  public void setRetryImage(Drawable drawable, ScalingUtils.ScaleType scaleType) {
    setChildDrawableAtIndex(RETRY_IMAGE_INDEX, drawable);
    getScaleTypeDrawableAtIndex(RETRY_IMAGE_INDEX).setScaleType(scaleType);
  }

  /**
   * Sets a new retry drawable with old scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   */
  public void setRetryImage(int resourceId) {
    setRetryImage(mResources.getDrawable(resourceId));
  }

  /**
   * Sets a new retry drawable with scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   * @param ScalingUtils.ScaleType a new scale type.
   */
  public void setRetryImage(int resourceId, ScalingUtils.ScaleType scaleType) {
    setRetryImage(mResources.getDrawable(resourceId), scaleType);
  }

  /** Sets a new progress bar drawable with old scale type. */
  public void setProgressBarImage(@Nullable Drawable drawable) {
    setChildDrawableAtIndex(PROGRESS_BAR_IMAGE_INDEX, drawable);
  }

  /** Sets a new progress bar drawable with scale type. */
  public void setProgressBarImage(Drawable drawable, ScalingUtils.ScaleType scaleType) {
    setChildDrawableAtIndex(PROGRESS_BAR_IMAGE_INDEX, drawable);
    getScaleTypeDrawableAtIndex(PROGRESS_BAR_IMAGE_INDEX).setScaleType(scaleType);
  }

  /**
   * Sets a new progress bar drawable with old scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   */
  public void setProgressBarImage(int resourceId) {
    setProgressBarImage(mResources.getDrawable(resourceId));
  }

  /**
   * Sets a new progress bar drawable with scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   * @param ScalingUtils.ScaleType a new scale type.
   */
  public void setProgressBarImage(int resourceId, ScalingUtils.ScaleType scaleType) {
    setProgressBarImage(mResources.getDrawable(resourceId), scaleType);
  }

  /** Sets the background image if allowed. */
  public void setBackgroundImage(@Nullable Drawable drawable) {
    setChildDrawableAtIndex(BACKGROUND_IMAGE_INDEX, drawable);
  }

  /**
   * Sets a new overlay image at the specified index.
   *
   * <p>This method will throw if the given index is out of bounds.
   *
   * @param drawable background image
   */
  public void setOverlayImage(int index, @Nullable Drawable drawable) {
    // Note that overlays are by definition top-most and therefore the last elements in the array.
    Preconditions.checkArgument(
        index >= 0 && OVERLAY_IMAGES_INDEX + index < mFadeDrawable.getNumberOfLayers(),
        ""The given index does not correspond to an overlay image."");
    setChildDrawableAtIndex(OVERLAY_IMAGES_INDEX + index, drawable);
  }

  /** Sets the overlay image if allowed. */
  public void setOverlayImage(@Nullable Drawable drawable) {
    setOverlayImage(0, drawable);
  }

  /** Sets the rounding params. */
  public void setRoundingParams(@Nullable RoundingParams roundingParams) {
    mRoundingParams = roundingParams;
    WrappingUtils.updateOverlayColorRounding(mTopLevelDrawable, mRoundingParams);
    for (int i = 0; i < mFadeDrawable.getNumberOfLayers(); i++) {
      WrappingUtils.updateLeafRounding(getParentDrawableAtIndex(i), mRoundingParams, mResources);
    }
  }

  /** Gets the rounding params. */
  @Nullable
  public RoundingParams getRoundingParams() {
    return mRoundingParams;
  }

  @VisibleForTesting
  public boolean hasImage() {
    return mActualImageWrapper.getDrawable() != mEmptyActualImageDrawable;
  }

  public void setOnFadeListener(OnFadeListener onFadeListener) {
    mFadeDrawable.setOnFadeListener(onFadeListener);
  }
}
","focusPoint
",point,"focusPoint
",focusPoint,focusPoint,
"

package com.google.devtools.build.skyframe;

import com.google.common.collect.ImmutableList;

/** A simple {@link Differencer} that is manually informed of invalid/injected nodes. */
public interface RecordingDifferencer extends Differencer, Injectable {
  @Override
  Diff getDiff(WalkableGraph  [MASK] , Version fromVersion, Version toVersion);

  /** Stores the given values for invalidation. */
  void invalidate(Iterable<SkyKey> values);

  /**
   * Invalidates the cached values of any values in error transiently.
   *
   * <p>If a future call to {@link MemoizingEvaluator#evaluate} requests a value that transitively
   * depends on any value that was in an error state (or is one of these), they will be re-computed.
   */
  default void invalidateTransientErrors() {
    // All transient error values have a dependency on the single global ERROR_TRANSIENCE value,
    // so we only have to invalidate that one value to catch everything.
    invalidate(ImmutableList.of(ErrorTransienceValue.KEY));
  }
}
","fromGraph
",graph,walkableGraph,walkableGraph,graph,
"

package com.facebook.samples.zoomable;

import android.graphics.Matrix;
import android.graphics.PointF;
import android.graphics.RectF;
import android.view.MotionEvent;
import androidx.annotation.IntDef;
import androidx.annotation.Nullable;
import com.facebook.common.logging.FLog;
import com.facebook.samples.gestures.TransformGestureDetector;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/** Zoomable controller that calculates transformation based on touch events. */
public class DefaultZoomableController
    implements ZoomableController, TransformGestureDetector.Listener {

  /** Interface for handling call backs when the image bounds are set. */
  public interface ImageBoundsListener {
    void onImageBoundsSet(RectF imageBounds);
  }

  @IntDef(
      flag = true,
      value = {LIMIT_NONE, LIMIT_TRANSLATION_X, LIMIT_TRANSLATION_Y, LIMIT_SCALE, LIMIT_ALL})
  @Retention(RetentionPolicy.SOURCE)
  public @interface LimitFlag {}

  public static final int LIMIT_NONE = 0;
  public static final int LIMIT_TRANSLATION_X = 1;
  public static final int LIMIT_TRANSLATION_Y = 2;
  public static final int LIMIT_SCALE = 4;
  public static final int LIMIT_ALL = LIMIT_TRANSLATION_X | LIMIT_TRANSLATION_Y | LIMIT_SCALE;

  private static final float EPS = 1e-3f;

  private static final Class<?> TAG = DefaultZoomableController.class;

  private static final RectF IDENTITY_RECT = new RectF(0, 0, 1, 1);

  private TransformGestureDetector mGestureDetector;

  private @Nullable ImageBoundsListener mImageBoundsListener;

  private @Nullable Listener mListener = null;

  private boolean mIsEnabled = false;
  private boolean mIsRotationEnabled = false;
  private boolean mIsScaleEnabled = true;
  private boolean mIsTranslationEnabled = true;
  private boolean mIsGestureZoomEnabled = true;

  private float mMinScaleFactor = 1.0f;
  private float mMaxScaleFactor = 2.0f;

  // View bounds, in view-absolute coordinates
  private final RectF mViewBounds = new RectF();
  // Non-transformed image bounds, in view-absolute coordinates
  private final RectF mImageBounds = new RectF();
  // Transformed image bounds, in view-absolute coordinates
  private final RectF mTransformedImageBounds = new RectF();

  private final Matrix mPreviousTransform = new Matrix();
  private final Matrix mActiveTransform = new Matrix();
  private final Matrix mActiveTransformInverse = new Matrix();
  private final float[] mTempValues = new float[9];
  private final RectF mTempRect = new RectF();
  private boolean mWasTransformCorrected;

  public static DefaultZoomableController newInstance() {
    return new DefaultZoomableController(TransformGestureDetector.newInstance());
  }

  public DefaultZoomableController(TransformGestureDetector gestureDetector) {
    mGestureDetector = gestureDetector;
    mGestureDetector.setListener(this);
  }

  /** Rests the controller. */
  public void reset() {
    FLog.v(TAG, ""reset"");
    mGestureDetector.reset();
    mPreviousTransform.reset();
    mActiveTransform.reset();
    onTransformChanged();
  }

  /** Sets the zoomable listener. */
  @Override
  public void setListener(Listener listener) {
    mListener = listener;
  }

  /** Sets whether the controller is enabled or not. */
  @Override
  public void setEnabled(boolean enabled) {
    mIsEnabled = enabled;
    if (!enabled) {
      reset();
    }
  }

  /** Gets whether the controller is enabled or not. */
  @Override
  public boolean isEnabled() {
    return mIsEnabled;
  }

  /** Sets whether the rotation gesture is enabled or not. */
  public void setRotationEnabled(boolean enabled) {
    mIsRotationEnabled = enabled;
  }

  /** Gets whether the rotation gesture is enabled or not. */
  public boolean isRotationEnabled() {
    return mIsRotationEnabled;
  }

  /** Sets whether the scale gesture is enabled or not. */
  public void setScaleEnabled(boolean enabled) {
    mIsScaleEnabled = enabled;
  }

  /** Gets whether the scale gesture is enabled or not. */
  public boolean isScaleEnabled() {
    return mIsScaleEnabled;
  }

  /** Sets whether the translation gesture is enabled or not. */
  public void setTranslationEnabled(boolean enabled) {
    mIsTranslationEnabled = enabled;
  }

  /** Gets whether the translations gesture is enabled or not. */
  public boolean isTranslationEnabled() {
    return mIsTranslationEnabled;
  }

  /**
   * Sets the minimum scale factor allowed.
   *
   * <p>Hierarchy's scaling (if any) is not taken into account.
   */
  public void setMinScaleFactor(float  [MASK] ) {
    mMinScaleFactor =  [MASK] ;
  }

  /** Gets the minimum scale factor allowed. */
  public float getMinScaleFactor() {
    return mMinScaleFactor;
  }

  /**
   * Sets the maximum scale factor allowed.
   *
   * <p>Hierarchy's scaling (if any) is not taken into account.
   */
  public void setMaxScaleFactor(float maxScaleFactor) {
    mMaxScaleFactor = maxScaleFactor;
  }

  /** Gets the maximum scale factor allowed. */
  public float getMaxScaleFactor() {
    return mMaxScaleFactor;
  }

  /** Sets whether gesture zooms are enabled or not. */
  public void setGestureZoomEnabled(boolean isGestureZoomEnabled) {
    mIsGestureZoomEnabled = isGestureZoomEnabled;
  }

  /** Gets whether gesture zooms are enabled or not. */
  public boolean isGestureZoomEnabled() {
    return mIsGestureZoomEnabled;
  }

  /** Gets the current scale factor. */
  @Override
  public float getScaleFactor() {
    return getMatrixScaleFactor(mActiveTransform);
  }

  /** Sets the image bounds, in view-absolute coordinates. */
  @Override
  public void setImageBounds(RectF imageBounds) {
    if (!imageBounds.equals(mImageBounds)) {
      mImageBounds.set(imageBounds);
      onTransformChanged();
      if (mImageBoundsListener != null) {
        mImageBoundsListener.onImageBoundsSet(mImageBounds);
      }
    }
  }

  /** Gets the non-transformed image bounds, in view-absolute coordinates. */
  public RectF getImageBounds() {
    return mImageBounds;
  }

  /** Gets the transformed image bounds, in view-absolute coordinates */
  private RectF getTransformedImageBounds() {
    return mTransformedImageBounds;
  }

  /** Sets the view bounds. */
  @Override
  public void setViewBounds(RectF viewBounds) {
    mViewBounds.set(viewBounds);
  }

  /** Gets the view bounds. */
  public RectF getViewBounds() {
    return mViewBounds;
  }

  /** Sets the image bounds listener. */
  public void setImageBoundsListener(@Nullable ImageBoundsListener imageBoundsListener) {
    mImageBoundsListener = imageBoundsListener;
  }

  /** Gets the image bounds listener. */
  public @Nullable ImageBoundsListener getImageBoundsListener() {
    return mImageBoundsListener;
  }

  /** Returns true if the zoomable transform is identity matrix. */
  @Override
  public boolean isIdentity() {
    return isMatrixIdentity(mActiveTransform, 1e-3f);
  }

  /**
   * Returns true if the transform was corrected during the last update.
   *
   * <p>We should rename this method to `wasTransformedWithoutCorrection` and just return the
   * internal flag directly. However, this requires interface change and negation of meaning.
   */
  @Override
  public boolean wasTransformCorrected() {
    return mWasTransformCorrected;
  }

  /**
   * Gets the matrix that transforms image-absolute coordinates to view-absolute coordinates. The
   * zoomable transformation is taken into account.
   *
   * <p>Internal matrix is exposed for performance reasons and is not to be modified by the callers.
   */
  @Override
  public Matrix getTransform() {
    return mActiveTransform;
  }

  /**
   * Gets the matrix that transforms image-relative coordinates to view-absolute coordinates. The
   * zoomable transformation is taken into account.
   */
  public void getImageRelativeToViewAbsoluteTransform(Matrix outMatrix) {
    outMatrix.setRectToRect(IDENTITY_RECT, mTransformedImageBounds, Matrix.ScaleToFit.FILL);
  }

  /**
   * Maps point from view-absolute to image-relative coordinates. This takes into account the
   * zoomable transformation.
   */
  public PointF mapViewToImage(PointF viewPoint) {
    float[] points = mTempValues;
    points[0] = viewPoint.x;
    points[1] = viewPoint.y;
    mActiveTransform.invert(mActiveTransformInverse);
    mActiveTransformInverse.mapPoints(points, 0, points, 0, 1);
    mapAbsoluteToRelative(points, points, 1);
    return new PointF(points[0], points[1]);
  }

  /**
   * Maps point from image-relative to view-absolute coordinates. This takes into account the
   * zoomable transformation.
   */
  public PointF mapImageToView(PointF imagePoint) {
    float[] points = mTempValues;
    points[0] = imagePoint.x;
    points[1] = imagePoint.y;
    mapRelativeToAbsolute(points, points, 1);
    mActiveTransform.mapPoints(points, 0, points, 0, 1);
    return new PointF(points[0], points[1]);
  }

  /**
   * Maps array of 2D points from view-absolute to image-relative coordinates. This does NOT take
   * into account the zoomable transformation. Points are represented by a float array of [x0, y0,
   * x1, y1, ...].
   *
   * @param destPoints destination array (may be the same as source array)
   * @param srcPoints source array
   * @param numPoints number of points to map
   */
  private void mapAbsoluteToRelative(float[] destPoints, float[] srcPoints, int numPoints) {
    for (int i = 0; i < numPoints; i++) {
      destPoints[i * 2 + 0] = (srcPoints[i * 2 + 0] - mImageBounds.left) / mImageBounds.width();
      destPoints[i * 2 + 1] = (srcPoints[i * 2 + 1] - mImageBounds.top) / mImageBounds.height();
    }
  }

  /**
   * Maps array of 2D points from image-relative to view-absolute coordinates. This does NOT take
   * into account the zoomable transformation. Points are represented by float array of [x0, y0, x1,
   * y1, ...].
   *
   * @param destPoints destination array (may be the same as source array)
   * @param srcPoints source array
   * @param numPoints number of points to map
   */
  private void mapRelativeToAbsolute(float[] destPoints, float[] srcPoints, int numPoints) {
    for (int i = 0; i < numPoints; i++) {
      destPoints[i * 2 + 0] = srcPoints[i * 2 + 0] * mImageBounds.width() + mImageBounds.left;
      destPoints[i * 2 + 1] = srcPoints[i * 2 + 1] * mImageBounds.height() + mImageBounds.top;
    }
  }

  /**
   * Zooms to the desired scale and positions the image so that the given image point corresponds to
   * the given view point.
   *
   * @param scale desired scale, will be limited to {min, max} scale factor
   * @param imagePoint 2D point in image's relative coordinate system (i.e. 0 <= x, y <= 1)
   * @param viewPoint 2D point in view's absolute coordinate system
   */
  public void zoomToPoint(float scale, PointF imagePoint, PointF viewPoint) {
    FLog.v(TAG, ""zoomToPoint"");
    calculateZoomToPointTransform(mActiveTransform, scale, imagePoint, viewPoint, LIMIT_ALL);
    onTransformChanged();
  }

  /**
   * Calculates the zoom transformation that would zoom to the desired scale and position the image
   * so that the given image point corresponds to the given view point.
   *
   * @param outTransform the matrix to store the result to
   * @param scale desired scale, will be limited to {min, max} scale factor
   * @param imagePoint 2D point in image's relative coordinate system (i.e. 0 <= x, y <= 1)
   * @param viewPoint 2D point in view's absolute coordinate system
   * @param limitFlags whether to limit translation and/or scale.
   * @return whether or not the transform has been corrected due to limitation
   */
  protected boolean calculateZoomToPointTransform(
      Matrix outTransform,
      float scale,
      PointF imagePoint,
      PointF viewPoint,
      @LimitFlag int limitFlags) {
    float[] viewAbsolute = mTempValues;
    viewAbsolute[0] = imagePoint.x;
    viewAbsolute[1] = imagePoint.y;
    mapRelativeToAbsolute(viewAbsolute, viewAbsolute, 1);
    float distanceX = viewPoint.x - viewAbsolute[0];
    float distanceY = viewPoint.y - viewAbsolute[1];
    boolean transformCorrected = false;
    outTransform.setScale(scale, scale, viewAbsolute[0], viewAbsolute[1]);
    transformCorrected |= limitScale(outTransform, viewAbsolute[0], viewAbsolute[1], limitFlags);
    outTransform.postTranslate(distanceX, distanceY);
    transformCorrected |= limitTranslation(outTransform, limitFlags);
    return transformCorrected;
  }

  /** Sets a new zoom transformation. */
  public void setTransform(Matrix newTransform) {
    FLog.v(TAG, ""setTransform"");
    mActiveTransform.set(newTransform);
    onTransformChanged();
  }

  /** Gets the gesture detector. */
  protected TransformGestureDetector getDetector() {
    return mGestureDetector;
  }

  /** Notifies controller of the received touch event. */
  @Override
  public boolean onTouchEvent(MotionEvent event) {
    FLog.v(TAG, ""onTouchEvent: action: "", event.getAction());
    if (mIsEnabled && mIsGestureZoomEnabled) {
      return mGestureDetector.onTouchEvent(event);
    }
    return false;
  }

  /* TransformGestureDetector.Listener methods  */

  @Override
  public void onGestureBegin(TransformGestureDetector detector) {
    FLog.v(TAG, ""onGestureBegin"");
    mPreviousTransform.set(mActiveTransform);
    onTransformBegin();
    // We only received a touch down event so far, and so we don't know yet in which direction a
    // future move event will follow. Therefore, if we can't scroll in all directions, we have to
    // assume the worst case where the user tries to scroll out of edge, which would cause
    // transformation to be corrected.
    mWasTransformCorrected = !canScrollInAllDirection();
  }

  @Override
  public void onGestureUpdate(TransformGestureDetector detector) {
    FLog.v(TAG, ""onGestureUpdate"");
    boolean transformCorrected = calculateGestureTransform(mActiveTransform, LIMIT_ALL);
    onTransformChanged();
    if (transformCorrected) {
      mGestureDetector.restartGesture();
    }
    // A transformation happened, but was it without correction?
    mWasTransformCorrected = transformCorrected;
  }

  @Override
  public void onGestureEnd(TransformGestureDetector detector) {
    FLog.v(TAG, ""onGestureEnd"");
    onTransformEnd();
  }

  /**
   * Calculates the zoom transformation based on the current gesture.
   *
   * @param outTransform the matrix to store the result to
   * @param limitTypes whether to limit translation and/or scale.
   * @return whether or not the transform has been corrected due to limitation
   */
  protected boolean calculateGestureTransform(Matrix outTransform, @LimitFlag int limitTypes) {
    TransformGestureDetector detector = mGestureDetector;
    boolean transformCorrected = false;
    outTransform.set(mPreviousTransform);
    if (mIsRotationEnabled) {
      float angle = detector.getRotation() * (float) (180 / Math.PI);
      outTransform.postRotate(angle, detector.getPivotX(), detector.getPivotY());
    }
    if (mIsScaleEnabled) {
      float scale = detector.getScale();
      outTransform.postScale(scale, scale, detector.getPivotX(), detector.getPivotY());
    }
    transformCorrected |=
        limitScale(outTransform, detector.getPivotX(), detector.getPivotY(), limitTypes);
    if (mIsTranslationEnabled) {
      outTransform.postTranslate(detector.getTranslationX(), detector.getTranslationY());
    }
    transformCorrected |= limitTranslation(outTransform, limitTypes);
    return transformCorrected;
  }

  private void onTransformBegin() {
    if (mListener != null && isEnabled()) {
      mListener.onTransformBegin(mActiveTransform);
    }
  }

  private void onTransformChanged() {
    mActiveTransform.mapRect(mTransformedImageBounds, mImageBounds);
    if (mListener != null && isEnabled()) {
      mListener.onTransformChanged(mActiveTransform);
    }
  }

  private void onTransformEnd() {
    if (mListener != null && isEnabled()) {
      mListener.onTransformEnd(mActiveTransform);
    }
  }

  /**
   * Keeps the scaling factor within the specified limits.
   *
   * @param pivotX x coordinate of the pivot point
   * @param pivotY y coordinate of the pivot point
   * @param limitTypes whether to limit scale.
   * @return whether limiting has been applied or not
   */
  private boolean limitScale(
      Matrix transform, float pivotX, float pivotY, @LimitFlag int limitTypes) {
    if (!shouldLimit(limitTypes, LIMIT_SCALE)) {
      return false;
    }
    float currentScale = getMatrixScaleFactor(transform);
    float targetScale = limit(currentScale, mMinScaleFactor, mMaxScaleFactor);
    if (targetScale != currentScale) {
      float scale = targetScale / currentScale;
      transform.postScale(scale, scale, pivotX, pivotY);
      return true;
    }
    return false;
  }

  /**
   * Limits the translation so that there are no empty spaces on the sides if possible.
   *
   * <p>The image is attempted to be centered within the view bounds if the transformed image is
   * smaller. There will be no empty spaces within the view bounds if the transformed image is
   * bigger. This applies to each dimension (horizontal and vertical) independently.
   *
   * @param limitTypes whether to limit translation along the specific axis.
   * @return whether limiting has been applied or not
   */
  private boolean limitTranslation(Matrix transform, @LimitFlag int limitTypes) {
    if (!shouldLimit(limitTypes, LIMIT_TRANSLATION_X | LIMIT_TRANSLATION_Y)) {
      return false;
    }
    RectF b = mTempRect;
    b.set(mImageBounds);
    transform.mapRect(b);
    float offsetLeft =
        shouldLimit(limitTypes, LIMIT_TRANSLATION_X)
            ? getOffset(
                b.left, b.right, mViewBounds.left, mViewBounds.right, mImageBounds.centerX())
            : 0;
    float offsetTop =
        shouldLimit(limitTypes, LIMIT_TRANSLATION_Y)
            ? getOffset(
                b.top, b.bottom, mViewBounds.top, mViewBounds.bottom, mImageBounds.centerY())
            : 0;
    if (offsetLeft != 0 || offsetTop != 0) {
      transform.postTranslate(offsetLeft, offsetTop);
      return true;
    }
    return false;
  }

  /**
   * Checks whether the specified limit flag is present in the limits provided.
   *
   * <p>If the flag contains multiple flags together using a bitwise OR, this only checks that at
   * least one of the flags is included.
   *
   * @param limits the limits to apply
   * @param flag the limit flag(s) to check for
   * @return true if the flag (or one of the flags) is included in the limits
   */
  private static boolean shouldLimit(@LimitFlag int limits, @LimitFlag int flag) {
    return (limits & flag) != LIMIT_NONE;
  }

  /**
   * Returns the offset necessary to make sure that: - the image is centered within the limit if the
   * image is smaller than the limit - there is no empty space on left/right if the image is bigger
   * than the limit
   */
  private float getOffset(
      float imageStart, float imageEnd, float limitStart, float limitEnd, float limitCenter) {
    float imageWidth = imageEnd - imageStart, limitWidth = limitEnd - limitStart;
    float limitInnerWidth = Math.min(limitCenter - limitStart, limitEnd - limitCenter) * 2;
    // center if smaller than limitInnerWidth
    if (imageWidth < limitInnerWidth) {
      return limitCenter - (imageEnd + imageStart) / 2;
    }
    // to the edge if in between and limitCenter is not (limitLeft + limitRight) / 2
    if (imageWidth < limitWidth) {
      if (limitCenter < (limitStart + limitEnd) / 2) {
        return limitStart - imageStart;
      } else {
        return limitEnd - imageEnd;
      }
    }
    // to the edge if larger than limitWidth and empty space visible
    if (imageStart > limitStart) {
      return limitStart - imageStart;
    }
    if (imageEnd < limitEnd) {
      return limitEnd - imageEnd;
    }
    return 0;
  }

  /** Limits the value to the given min and max range. */
  private float limit(float value, float min, float max) {
    return Math.min(Math.max(min, value), max);
  }

  /**
   * Gets the scale factor for the given matrix. This method assumes the equal scaling factor for X
   * and Y axis.
   */
  private float getMatrixScaleFactor(Matrix transform) {
    transform.getValues(mTempValues);
    return mTempValues[Matrix.MSCALE_X];
  }

  /** Same as {@code Matrix.isIdentity()}, but with tolerance {@code eps}. */
  private boolean isMatrixIdentity(Matrix transform, float eps) {
    // Checks whether the given matrix is close enough to the identity matrix:
    //   1 0 0
    //   0 1 0
    //   0 0 1
    // Or equivalently to the zero matrix, after subtracting 1.0f from the diagonal elements:
    //   0 0 0
    //   0 0 0
    //   0 0 0
    transform.getValues(mTempValues);
    mTempValues[0] -= 1.0f; // m00
    mTempValues[4] -= 1.0f; // m11
    mTempValues[8] -= 1.0f; // m22
    for (int i = 0; i < 9; i++) {
      if (Math.abs(mTempValues[i]) > eps) {
        return false;
      }
    }
    return true;
  }

  /** Returns whether the scroll can happen in all directions. I.e. the image is not on any edge. */
  private boolean canScrollInAllDirection() {
    return mTransformedImageBounds.left < mViewBounds.left - EPS
        && mTransformedImageBounds.top < mViewBounds.top - EPS
        && mTransformedImageBounds.right > mViewBounds.right + EPS
        && mTransformedImageBounds.bottom > mViewBounds.bottom + EPS;
  }

  @Override
  public int computeHorizontalScrollRange() {
    return (int) mTransformedImageBounds.width();
  }

  @Override
  public int computeHorizontalScrollOffset() {
    return (int) (mViewBounds.left - mTransformedImageBounds.left);
  }

  @Override
  public int computeHorizontalScrollExtent() {
    return (int) mViewBounds.width();
  }

  @Override
  public int computeVerticalScrollRange() {
    return (int) mTransformedImageBounds.height();
  }

  @Override
  public int computeVerticalScrollOffset() {
    return (int) (mViewBounds.top - mTransformedImageBounds.top);
  }

  @Override
  public int computeVerticalScrollExtent() {
    return (int) mViewBounds.height();
  }

  public Listener getListener() {
    return mListener;
  }
}
","minScaleFactor
",scaleScale,"minScaleFactor
","minScaleFactor
",scaleFactor,
"package com.google.android.exoplayer2.source.dash;

import static java.lang.Math.max;

import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.Format;
import com.google.android.exoplayer2.FormatHolder;
import com.google.android.exoplayer2.decoder.DecoderInputBuffer;
import com.google.android.exoplayer2.metadata.emsg.EventMessage;
import com.google.android.exoplayer2.metadata.emsg.EventMessageEncoder;
import com.google.android.exoplayer2.source.SampleStream;
import com.google.android.exoplayer2.source.dash.manifest.EventStream;
import com.google.android.exoplayer2.util.Util;
import java.io.IOException;

/**
 * A {@link SampleStream} consisting of serialized {@link EventMessage}s read from an {@link
 * EventStream}.
 *
 * @deprecated com.google.android.exoplayer2 is deprecated. Please migrate to androidx.media3 (which
 *     contains the same ExoPlayer code). See <a
 *     href=""https://developer.android.com/guide/topics/media/media3/getting-started/migration-guide"">the
 *     migration guide</a> for more details, including a script to help with the migration.
 */
@Deprecated
/* package */ final class EventSampleStream implements SampleStream {

  private final Format upstreamFormat;
  private final EventMessageEncoder eventMessageEncoder;

  private long[] eventTimesUs;
  private boolean eventStreamAppendable;
  private EventStream eventStream;

  private boolean isFormatSentDownstream;
  private int currentIndex;
  private long pendingSeekPositionUs;

  public EventSampleStream(
      EventStream eventStream, Format upstreamFormat, boolean eventStreamAppendable) {
    this.upstreamFormat = upstreamFormat;
    this.eventStream = eventStream;
    eventMessageEncoder = new EventMessageEncoder();
    pendingSeekPositionUs = C.TIME_UNSET;
    eventTimesUs = eventStream.presentationTimesUs;
    updateEventStream(eventStream, eventStreamAppendable);
  }

  public String eventStreamId() {
    return eventStream.id();
  }

  public void updateEventStream(EventStream eventStream, boolean eventStreamAppendable) {
    long lastReadPositionUs = currentIndex == 0 ? C.TIME_UNSET : eventTimesUs[currentIndex - 1];

    this.eventStreamAppendable = eventStreamAppendable;
    this.eventStream = eventStream;
    this.eventTimesUs = eventStream.presentationTimesUs;
    if (pendingSeekPositionUs != C.TIME_UNSET) {
      seekToUs(pendingSeekPositionUs);
    } else if (lastReadPositionUs != C.TIME_UNSET) {
      currentIndex =
          Util.binarySearchCeil(
              eventTimesUs, lastReadPositionUs, /* inclusive= */ false, /* stayInBounds= */ false);
    }
  }

  /**
   * Seeks to the specified position in microseconds.
   *
   * @param positionUs The seek position in microseconds.
   */
  public void seekToUs(long positionUs) {
    currentIndex =
        Util.binarySearchCeil(
            eventTimesUs, positionUs, /* inclusive= */ true, /* stayInBounds= */ false);
    boolean isPendingSeek = eventStreamAppendable && currentIndex == eventTimesUs.length;
    pendingSeekPositionUs = isPendingSeek ? positionUs : C.TIME_UNSET;
  }

  @Override
  public boolean isReady() {
    return true;
  }

  @Override
  public void maybeThrowError() throws IOException {
    // Do nothing.
  }

  @Override
  public int readData(
      FormatHolder formatHolder, DecoderInputBuffer buffer, @ReadFlags int readFlags) {
    boolean noMoreEventsInStream = currentIndex == eventTimesUs.length;
    if (noMoreEventsInStream && !eventStreamAppendable) {
      buffer.setFlags(C.BUFFER_FLAG_END_OF_STREAM);
      return C.RESULT_BUFFER_READ;
    }
    if ((readFlags & FLAG_REQUIRE_FORMAT) != 0 || !isFormatSentDownstream) {
      formatHolder.format = upstreamFormat;
      isFormatSentDownstream = true;
      return C.RESULT_FORMAT_READ;
    }
    if (noMoreEventsInStream) {
      // More events may be appended later.
      return C.RESULT_NOTHING_READ;
    }
    int sampleIndex = currentIndex;
    if ((readFlags & SampleStream.FLAG_PEEK) == 0) {
      currentIndex++;
    }
    if ((readFlags & SampleStream.FLAG_OMIT_SAMPLE_DATA) == 0) {
      byte[] serializedEvent = eventMessageEncoder.encode(eventStream.events[sampleIndex]);
      buffer.ensureSpaceForWrite(serializedEvent.length);
      buffer.data.put(serializedEvent);
    }
    buffer.timeUs = eventTimesUs[sampleIndex];
    buffer.setFlags(C.BUFFER_FLAG_KEY_FRAME);
    return C.RESULT_BUFFER_READ;
  }

  @Override
  public int skipData(long positionUs) {
    int  [MASK]  = max(currentIndex, Util.binarySearchCeil(eventTimesUs, positionUs, true, false));
    int skipped =  [MASK]  - currentIndex;
    currentIndex =  [MASK] ;
    return skipped;
  }
}
","newIndex
",endStartIndex,endIndex,targetIndex,eventIndex,
"
package com.github.chrisbanes.photoview.sample;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import androidx.appcompat.app.AppCompatActivity;
import androidx.appcompat.widget.Toolbar;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

public class LauncherActivity extends AppCompatActivity {

    public static final String[] options = {
            ""Simple Sample"",
            ""ViewPager Sample"",
            ""Rotation Sample"",
            ""Picasso Sample"",
            ""Coil Sample"",
            ""Activity Transition Sample"",
            ""Immersive Sample""
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_launcher);
        Toolbar toolbar = findViewById(R.id.toolbar);
        toolbar.setTitle(R.string.app_name);
        RecyclerView recyclerView = findViewById(R.id.list);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        recyclerView.setAdapter(new ItemAdapter());
    }


    private static class ItemAdapter extends RecyclerView.Adapter<ItemViewHolder> {
        @Override
        public ItemViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
            final ItemViewHolder holder = ItemViewHolder.newInstance(parent);
            holder.itemView.setOnClickListener(v -> {
                Class clazz;

                switch (holder.getAdapterPosition()) {
                    default:
                    case 0:
                        clazz = SimpleSampleActivity.class;
                        break;
                    case 1:
                        clazz = ViewPagerActivity.class;
                        break;
                    case 2:
                        clazz = RotationSampleActivity.class;
                        break;
                    case 3:
                        clazz = PicassoSampleActivity.class;
                        break;
                    case 4:
                        clazz = CoilSampleActivity.class;
                        break;
                    case 5:
                        clazz = ActivityTransitionActivity.class;
                        break;
                    case 6:
                        clazz = ImmersiveActivity.class;
                }

                Context context = holder.itemView.getContext();
                context.startActivity(new Intent(context, clazz));
            });
            return holder;
        }

        @Override
        public void onBindViewHolder(final ItemViewHolder holder, int  [MASK] ) {
            holder.bind(options[ [MASK] ]);
        }

        @Override
        public int getItemCount() {
            return options.length;
        }
    }

    private static class ItemViewHolder extends RecyclerView.ViewHolder {

        public static ItemViewHolder newInstance(ViewGroup parent) {
            View view = LayoutInflater.from(parent.getContext())
                    .inflate(R.layout.item_sample, parent, false);
            return new ItemViewHolder(view);
        }

        public TextView mTextTitle;

        public ItemViewHolder(View view) {
            super(view);
            mTextTitle = view.findViewById(R.id.title);
        }

        private void bind(String title) {
            mTextTitle.setText(title);
        }
    }
}
","position
",,bindingIndex,position,position,
"

package com.google.common.collect;

import static java.util.Arrays.asList;

import com.google.common.base.Function;
import com.google.common.collect.testing.CollectionTestSuiteBuilder;
import com.google.common.collect.testing.MinimalCollection;
import com.google.common.collect.testing.TestStringCollectionGenerator;
import com.google.common.collect.testing.features.CollectionFeature;
import com.google.common.collect.testing.features.CollectionSize;
import com.google.common.testing.ForwardingWrapperTester;
import java.util.Collection;
import junit.framework.Test;
import junit.framework.TestCase;
import junit.framework.TestSuite;

/**
 * Tests for {@link ForwardingCollection}.
 *
 * @author Robert Konigsberg
 * @author Hayward Chan
 * @author Louis Wasserman
 */
public class ForwardingCollectionTest extends TestCase {
  static final class StandardImplForwardingCollection<T> extends ForwardingCollection<T> {
    private final Collection<T> backingCollection;

    StandardImplForwardingCollection(Collection<T> backingCollection) {
      this.backingCollection = backingCollection;
    }

    @Override
    protected Collection<T> delegate() {
      return backingCollection;
    }

    @Override
    public boolean addAll(Collection<? extends T> collection) {
      return standardAddAll(collection);
    }

    @Override
    public void clear() {
      standardClear();
    }

    @Override
    public boolean contains(Object object) {
      return standardContains(object);
    }

    @Override
    public boolean containsAll(Collection<?> collection) {
      return standardContainsAll(collection);
    }

    @Override
    public boolean remove(Object object) {
      return standardRemove(object);
    }

    @Override
    public boolean removeAll(Collection<?> collection) {
      return standardRemoveAll(collection);
    }

    @Override
    public boolean retainAll(Collection<?> collection) {
      return standardRetainAll(collection);
    }

    @Override
    public Object[] toArray() {
      return standardToArray();
    }

    @Override
    public <T> T[] toArray(T[]  [MASK] ) {
      return standardToArray( [MASK] );
    }

    @Override
    public String toString() {
      return standardToString();
    }
  }

  public static Test suite() {
    TestSuite suite = new TestSuite();

    suite.addTestSuite(ForwardingCollectionTest.class);
    suite.addTest(
        CollectionTestSuiteBuilder.using(
                new TestStringCollectionGenerator() {
                  @Override
                  protected Collection<String> create(String[] elements) {
                    return new StandardImplForwardingCollection<>(
                        Lists.newLinkedList(asList(elements)));
                  }
                })
            .named(""ForwardingCollection[LinkedList] with standard implementations"")
            .withFeatures(
                CollectionSize.ANY,
                CollectionFeature.ALLOWS_NULL_VALUES,
                CollectionFeature.GENERAL_PURPOSE)
            .createTestSuite());
    suite.addTest(
        CollectionTestSuiteBuilder.using(
                new TestStringCollectionGenerator() {
                  @Override
                  protected Collection<String> create(String[] elements) {
                    return new StandardImplForwardingCollection<>(MinimalCollection.of(elements));
                  }
                })
            .named(""ForwardingCollection[MinimalCollection] with standard"" + "" implementations"")
            .withFeatures(CollectionSize.ANY, CollectionFeature.ALLOWS_NULL_VALUES)
            .createTestSuite());

    return suite;
  }

  @SuppressWarnings({""rawtypes"", ""unchecked""})
  public void testForwarding() {
    new ForwardingWrapperTester()
        .testForwarding(
            Collection.class,
            new Function<Collection, Collection>() {
              @Override
              public Collection apply(Collection delegate) {
                return wrap(delegate);
              }
            });
  }

  private static <T> Collection<T> wrap(final Collection<T> delegate) {
    return new ForwardingCollection<T>() {
      @Override
      protected Collection<T> delegate() {
        return delegate;
      }
    };
  }
}
","array
",toupleOfTArray,"array
",t,a,
"

package com.google.inject;

import static com.google.common.base.Preconditions.checkState;

import com.google.inject.binder.AnnotatedBindingBuilder;
import com.google.inject.binder.AnnotatedConstantBindingBuilder;
import com.google.inject.binder.AnnotatedElementBuilder;
import com.google.inject.binder.LinkedBindingBuilder;
import com.google.inject.matcher.Matcher;
import com.google.inject.spi.Message;
import com.google.inject.spi.ProvisionListener;
import com.google.inject.spi.TypeConverter;
import com.google.inject.spi.TypeListener;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import org.aopalliance.intercept.MethodInterceptor;

/**
 * A module whose configuration information is hidden from its environment by default. Only bindings
 * that are explicitly exposed will be available to other modules and to the users of the injector.
 * This module may expose the bindings it creates and the bindings of the modules it installs.
 *
 * <p>A private module can be nested within a regular module or within another private module using
 * {@link Binder#install install()}. Its bindings live in a new environment that inherits bindings,
 * type converters, scopes, and interceptors from the surrounding (""parent"") environment. When you
 * nest multiple private modules, the result is a tree of environments where the injector's
 * environment is the root.
 *
 * <p>Guice EDSL bindings can be exposed with {@link #expose(Class) expose()}. {@literal @}{@link
 * com.google.inject.Provides Provides} bindings can be exposed with the {@literal @}{@link Exposed}
 * annotation:
 *
 * <pre>
 * public class FooBarBazModule extends PrivateModule {
 *   protected void configure() {
 *     bind(Foo.class).to(RealFoo.class);
 *     expose(Foo.class);
 *
 *     install(new TransactionalBarModule());
 *     expose(Bar.class).annotatedWith(Transactional.class);
 *
 *     bind(SomeImplementationDetail.class);
 *     install(new MoreImplementationDetailsModule());
 *   }
 *
 *   {@literal @}Provides {@literal @}Exposed
 *   public Baz provideBaz() {
 *     return new SuperBaz();
 *   }
 * }
 * </pre>
 *
 * <p>Private modules are implemented using {@link Injector#createChildInjector(Module[]) parent
 * injectors}. When it can satisfy their dependencies, just-in-time bindings will be created in the
 * root environment. Such bindings are shared among all environments in the tree. See the note in
 * {@code createChildInjector} about how hierarchical injectors change the importance of otherwise
 * unnecessary binding statements (such as {@code bind(ServiceImpl.class);}).
 *
 * <p>The scope of a binding is constrained to its environment. A singleton bound in a private
 * module will be unique to its environment. But a binding for the same type in a different private
 * module will yield a different instance.
 *
 * <p>A shared binding that injects the {@code Injector} gets the root injector, which only has
 * access to bindings in the root environment. An explicit binding that injects the {@code Injector}
 * gets access to all bindings in the child environment.
 *
 * <p>To promote a just-in-time binding to an explicit binding, bind it:
 *
 * <pre>
 *   bind(FooImpl.class);
 * </pre>
 *
 * @author jessewilson@google.com (Jesse Wilson)
 * @since 2.0
 */
public abstract class PrivateModule implements Module {

  /** Like abstract module, the binder of the current private module */
  private PrivateBinder binder;

  @Override
  public final synchronized void configure(Binder binder) {
    checkState(this.binder == null, ""Re-entry is not allowed."");

    // Guice treats PrivateModules specially and passes in a PrivateBinder automatically.
    this.binder = (PrivateBinder) binder.skipSources(PrivateModule.class);
    try {
      configure();
    } finally {
      this.binder = null;
    }
  }

  /**
   * Creates bindings and other configurations private to this module. Use {@link #expose(Class)
   * expose()} to make the bindings in this module available externally.
   */
  protected abstract void configure();

  /** Makes the binding for {@code key} available to other modules and the injector. */
  protected final <T> void expose(Key<T> key) {
    binder().expose(key);
  }

  /**
   * Makes a binding for {@code type} available to other modules and the injector. Use {@link
   * AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
   * binding annotation.
   */
  protected final AnnotatedElementBuilder expose(Class<?> type) {
    return binder().expose(type);
  }

  /**
   * Makes a binding for {@code type} available to other modules and the injector. Use {@link
   * AnnotatedElementBuilder#annotatedWith(Class) annotatedWith()} to expose {@code type} with a
   * binding annotation.
   */
  protected final AnnotatedElementBuilder expose(TypeLiteral<?> type) {
    return binder().expose(type);
  }

  // everything below is copied from AbstractModule

  /** Returns the current binder. */
  protected PrivateBinder binder() {
    checkState(binder != null, ""The binder can only be used inside configure()"");
    return binder;
  }

  /** @see Binder#bindScope(Class, Scope) */
  protected final void bindScope(Class<? extends Annotation> scopeAnnotation, Scope scope) {
    binder().bindScope(scopeAnnotation, scope);
  }

  /** @see Binder#bind(Key) */
  protected final <T> LinkedBindingBuilder<T> bind(Key<T> key) {
    return binder().bind(key);
  }

  /** @see Binder#bind(TypeLiteral) */
  protected final <T> AnnotatedBindingBuilder<T> bind(TypeLiteral<T> typeLiteral) {
    return binder().bind(typeLiteral);
  }

  /** @see Binder#bind(Class) */
  protected final <T> AnnotatedBindingBuilder<T> bind(Class<T> clazz) {
    return binder().bind(clazz);
  }

  /** @see Binder#bindConstant() */
  protected final AnnotatedConstantBindingBuilder bindConstant() {
    return binder().bindConstant();
  }

  /** @see Binder#install(Module) */
  protected final void install(Module module) {
    binder().install(module);
  }

  /** @see Binder#addError(String, Object[]) */
  protected final void addError(String message, Object...  [MASK] ) {
    binder().addError(message,  [MASK] );
  }

  /** @see Binder#addError(Throwable) */
  protected final void addError(Throwable t) {
    binder().addError(t);
  }

  /** @see Binder#addError(Message) */
  protected final void addError(Message message) {
    binder().addError(message);
  }

  /** @see Binder#requestInjection(Object) */
  protected final void requestInjection(Object instance) {
    binder().requestInjection(instance);
  }

  /** @see Binder#requestStaticInjection(Class[]) */
  protected final void requestStaticInjection(Class<?>... types) {
    binder().requestStaticInjection(types);
  }

  /**
   * @see Binder#bindInterceptor(com.google.inject.matcher.Matcher,
   *     com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])
   */
  protected final void bindInterceptor(
      Matcher<? super Class<?>> classMatcher,
      Matcher<? super Method> methodMatcher,
      MethodInterceptor... interceptors) {
    binder().bindInterceptor(classMatcher, methodMatcher, interceptors);
  }

  /** Instructs Guice to require a binding to the given key. */
  protected final void requireBinding(Key<?> key) {
    binder().getProvider(key);
  }

  /** Instructs Guice to require a binding to the given type. */
  protected final void requireBinding(Class<?> type) {
    binder().getProvider(type);
  }

  /** @see Binder#getProvider(Key) */
  protected final <T> Provider<T> getProvider(Key<T> key) {
    return binder().getProvider(key);
  }

  /** @see Binder#getProvider(Class) */
  protected final <T> Provider<T> getProvider(Class<T> type) {
    return binder().getProvider(type);
  }

  /**
   * @see Binder#convertToTypes(com.google.inject.matcher.Matcher,
   *     com.google.inject.spi.TypeConverter)
   */
  protected final void convertToTypes(
      Matcher<? super TypeLiteral<?>> typeMatcher, TypeConverter converter) {
    binder().convertToTypes(typeMatcher, converter);
  }

  /** @see Binder#currentStage() */
  protected final Stage currentStage() {
    return binder().currentStage();
  }

  /** @see Binder#getMembersInjector(Class) */
  protected <T> MembersInjector<T> getMembersInjector(Class<T> type) {
    return binder().getMembersInjector(type);
  }

  /** @see Binder#getMembersInjector(TypeLiteral) */
  protected <T> MembersInjector<T> getMembersInjector(TypeLiteral<T> type) {
    return binder().getMembersInjector(type);
  }

  /**
   * @see Binder#bindListener(com.google.inject.matcher.Matcher, com.google.inject.spi.TypeListener)
   */
  protected void bindListener(Matcher<? super TypeLiteral<?>> typeMatcher, TypeListener listener) {
    binder().bindListener(typeMatcher, listener);
  }

  /**
   * @see Binder#bindListener(Matcher, ProvisionListener...)
   * @since 4.0
   */
  protected void bindListener(
      Matcher<? super Binding<?>> bindingMatcher, ProvisionListener... listeners) {
    binder().bindListener(bindingMatcher, listeners);
  }
}
","arguments
",extableData,parameters,errorArguments,errors,
"

package org.openrefine.wikibase.qa.scrutinizers;

import org.openrefine.wikibase.qa.QAWarning;
import org.wikidata.wdtk.datamodel.interfaces.EntityIdValue;
import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;
import org.wikidata.wdtk.datamodel.interfaces.Snak;
import org.wikidata.wdtk.datamodel.interfaces.Statement;
import org.wikidata.wdtk.datamodel.interfaces.Value;
import org.wikidata.wdtk.datamodel.interfaces.ValueSnak;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * A scrutinizer that checks for properties using the same value on different entities.
 * 
 * @author Antonin Delpeuch
 *
 */
public class DistinctValuesScrutinizer extends StatementScrutinizer {

    public final static String type = ""identical-values-for-distinct-valued-property"";
    public String distinctValuesConstraintQid;

    private Map<PropertyIdValue, Map<Value, EntityIdValue>> _seenValues;

    public DistinctValuesScrutinizer() {
        _seenValues = new HashMap<>();
    }

    @Override
    public boolean prepareDependencies() {
        distinctValuesConstraintQid = getConstraintsRelatedId(""distinct_values_constraint_qid"");
        return _fetcher != null && distinctValuesConstraintQid != null;
    }

    @Override
    public void scrutinize(Statement statement, EntityIdValue entityId, boolean added) {
        if (!added) {
            // not scrutinizing removed statements
            return;
        }
        Snak  [MASK]  = statement.getClaim().getMainSnak();
        PropertyIdValue pid =  [MASK] .getPropertyId();
        List<Statement> statementList = _fetcher.getConstraintsByType(pid, distinctValuesConstraintQid);
        if (!statementList.isEmpty() &&  [MASK]  instanceof ValueSnak) {
            Value  [MASK] Value = ((ValueSnak)  [MASK] ).getValue();
            Map<Value, EntityIdValue> seen = _seenValues.get(pid);
            if (seen == null) {
                seen = new HashMap<Value, EntityIdValue>();
                _seenValues.put(pid, seen);
            }
            if (seen.containsKey( [MASK] Value)) {
                EntityIdValue otherId = seen.get( [MASK] Value);
                QAWarning issue = new QAWarning(type, pid.getId(), QAWarning.Severity.IMPORTANT, 1);
                issue.setProperty(""property_entity"", pid);
                issue.setProperty(""item1_entity"", entityId);
                issue.setProperty(""item2_entity"", otherId);
                // we disable faceting for this issue because the distinct values are likely
                // coming from different rows, and our current faceting mechanism is not able to detect those.
                issue.setFacetable(false);
                addIssue(issue);
            } else {
                seen.put( [MASK] Value, entityId);
            }
        }
    }

}
","mainSnak
",mainSn,mainSnak,mainSnak,snak,
"

package com.badlogic.gdx.backends.android;

import android.annotation.TargetApi;
import android.app.Activity;
import android.content.Context;
import android.content.res.Configuration;
import android.opengl.GLSurfaceView;
import android.os.Build;
import android.os.Debug;
import android.os.Handler;
import android.os.Looper;
import android.service.dreams.DreamService;
import android.view.Gravity;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.widget.FrameLayout;
import com.badlogic.gdx.*;
import com.badlogic.gdx.backends.android.surfaceview.FillResolutionStrategy;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Clipboard;
import com.badlogic.gdx.utils.GdxNativesLoader;
import com.badlogic.gdx.utils.SnapshotArray;

/** An implementation of the {@link Application} interface for Android. Create an {@link Activity} that derives from this class.
 * In the Activity#onCreate(Bundle) method call the {@link #initialize(ApplicationListener)} method specifying the configuration
 * for the {@link GLSurfaceView}.
 * 
 * @author mzechner */
@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
public class AndroidDaydream extends DreamService implements AndroidApplicationBase {

        protected AndroidGraphics graphics;
        protected AndroidInput input;
        protected AndroidAudio audio;
        protected AndroidFiles files;
        protected AndroidNet net;
        protected AndroidClipboard clipboard;
        protected ApplicationListener listener;
        protected Handler handler;
        protected boolean firstResume = true;
        protected final Array<Runnable> runnables = new Array<Runnable>();
        protected final Array<Runnable> executedRunnables = new Array<Runnable>();
        protected final SnapshotArray<LifecycleListener> lifecycleListeners = new SnapshotArray<LifecycleListener>(
                LifecycleListener.class);
        protected int logLevel = LOG_INFO;
        protected ApplicationLogger applicationLogger;

        /** This method has to be called in the Activity#onCreate(Bundle) method. It sets up all the things necessary to get input,
         * render via OpenGL and so on. Uses a default {@link AndroidApplicationConfiguration}.
         * @param listener the {@link ApplicationListener} implementing the program logic */
        public void initialize (ApplicationListener listener) {
                AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();
                initialize(listener, config);
        }

        /** This method has to be called in the Activity#onCreate(Bundle) method. It sets up all the things necessary to get input,
         * render via OpenGL and so on. You can configure other aspects of the application with the rest of the fields in the
         * {@link AndroidApplicationConfiguration} instance.
         * @param listener the {@link ApplicationListener} implementing the program logic
         * @param config the {@link AndroidApplicationConfiguration}, defining various settings of the application (use accelerometer,
         *           etc.). */
        public void initialize (ApplicationListener listener, AndroidApplicationConfiguration config) {
                init(listener, config, false);
        }

        /** This method has to be called in the Activity#onCreate(Bundle) method. It sets up all the things necessary to get input,
         * render via OpenGL and so on. Uses a default {@link AndroidApplicationConfiguration}.
         * <p>
         * Note: you have to add the returned view to your layout!
         * @param listener the {@link ApplicationListener} implementing the program logic
         * @return the {@link GLSurfaceView} of the application */
        public View initializeForView (ApplicationListener listener) {
                AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();
                return initializeForView(listener, config);
        }

        /** This method has to be called in the Activity#onCreate(Bundle) method. It sets up all the things necessary to get input,
         * render via OpenGL and so on. You can configure other aspects of the application with the rest of the fields in the
         * {@link AndroidApplicationConfiguration} instance.
         * <p>
         * Note: you have to add the returned view to your layout!
         * @param listener the {@link ApplicationListener} implementing the program logic
         * @param config the {@link AndroidApplicationConfiguration}, defining various settings of the application (use accelerometer,
         *           etc.).
         * @return the {@link GLSurfaceView} of the application */
        public View initializeForView (ApplicationListener listener, AndroidApplicationConfiguration config) {
                init(listener, config, true);
                return graphics.getView();
        }

        private void init (ApplicationListener listener, AndroidApplicationConfiguration config, boolean isForView) {
                GdxNativesLoader.load();
                setApplicationLogger(new AndroidApplicationLogger());
                graphics = new AndroidGraphics(this, config,
                        config.resolutionStrategy == null ? new FillResolutionStrategy() : config.resolutionStrategy);
                input = createInput(this, this, graphics.view, config);
                audio = createAudio(this, config);
                files = createFiles();
                net = new AndroidNet(this, config);
                this.listener = listener;
                this.handler = new Handler();
                this.clipboard = new AndroidClipboard(this);

                // Add a specialized audio lifecycle listener
                addLifecycleListener(new LifecycleListener() {

                        @Override
                        public void resume () {
                                audio.resume();
                        }

                        @Override
                        public void pause () {
                                audio.pause();
                        }

                        @Override
                        public void dispose () {
                                audio.dispose();
                                audio = null;
                        }
                });

                Gdx.app = this;
                Gdx.input = this.getInput();
                Gdx.audio = this.getAudio();
                Gdx.files = this.getFiles();
                Gdx.graphics = this.getGraphics();
                Gdx.net = this.getNet();

                if (!isForView) {
                        setFullscreen(true);
                        setContentView(graphics.getView(), createLayoutParams());
                }

                createWakeLock(config.useWakelock);

                // detect an already connected bluetooth keyboardAvailable
                if (getResources().getConfiguration().keyboard != Configuration.KEYBOARD_NOKEYS) input.setKeyboardAvailable(true);
        }

        protected FrameLayout.LayoutParams createLayoutParams () {
                FrameLayout.LayoutParams  [MASK]  = new FrameLayout.LayoutParams(android.view.ViewGroup.LayoutParams.MATCH_PARENT,
                        android.view.ViewGroup.LayoutParams.MATCH_PARENT);
                 [MASK] .gravity = Gravity.CENTER;
                return  [MASK] ;
        }

        protected void createWakeLock (boolean use) {
                if (use) {
                        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
                }
        }

        @Override
        public void onDreamingStopped () {
                boolean isContinuous = graphics.isContinuousRendering();
                graphics.setContinuousRendering(true);
                graphics.pause();

                input.onDreamingStopped();

                graphics.clearManagedCaches();
                graphics.destroy();
                graphics.setContinuousRendering(isContinuous);

                graphics.onPauseGLSurfaceView();

                super.onDreamingStopped();
        }

        @Override
        public void onDreamingStarted () {
                Gdx.app = this;
                Gdx.input = this.getInput();
                Gdx.audio = this.getAudio();
                Gdx.files = this.getFiles();
                Gdx.graphics = this.getGraphics();
                Gdx.net = this.getNet();

                input.onDreamingStarted();

                if (graphics != null) {
                        graphics.onResumeGLSurfaceView();
                }

                if (!firstResume) {
                        graphics.resume();
                } else
                        firstResume = false;
                super.onDreamingStarted();
        }

        @Override
        public void onDetachedFromWindow () {
                super.onDetachedFromWindow();
        }

        @Override
        public ApplicationListener getApplicationListener () {
                return listener;
        }

        @Override
        public Audio getAudio () {
                return audio;
        }

        @Override
        public Files getFiles () {
                return files;
        }

        @Override
        public Graphics getGraphics () {
                return graphics;
        }

        @Override
        public AndroidInput getInput () {
                return input;
        }

        @Override
        public Net getNet () {
                return net;
        }

        @Override
        public ApplicationType getType () {
                return ApplicationType.Android;
        }

        @Override
        public int getVersion () {
                return android.os.Build.VERSION.SDK_INT;
        }

        @Override
        public long getJavaHeap () {
                return Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        }

        @Override
        public long getNativeHeap () {
                return Debug.getNativeHeapAllocatedSize();
        }

        @Override
        public Preferences getPreferences (String name) {
                return new AndroidPreferences(getSharedPreferences(name, Context.MODE_PRIVATE));
        }

        @Override
        public Clipboard getClipboard () {
                return clipboard;
        }

        @Override
        public void postRunnable (Runnable runnable) {
                synchronized (runnables) {
                        runnables.add(runnable);
                        Gdx.graphics.requestRendering();
                }
        }

        @Override
        public void onConfigurationChanged (Configuration config) {
                super.onConfigurationChanged(config);
                boolean keyboardAvailable = false;
                if (config.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO) keyboardAvailable = true;
                input.setKeyboardAvailable(keyboardAvailable);
        }

        @Override
        public void exit () {
                handler.post(new Runnable() {
                        @Override
                        public void run () {
                                AndroidDaydream.this.finish();
                        }
                });
        }

        @Override
        public void debug (String tag, String message) {
                if (logLevel >= LOG_DEBUG) getApplicationLogger().debug(tag, message);
        }

        @Override
        public void debug (String tag, String message, Throwable exception) {
                if (logLevel >= LOG_DEBUG) getApplicationLogger().debug(tag, message, exception);
        }

        @Override
        public void log (String tag, String message) {
                if (logLevel >= LOG_INFO) getApplicationLogger().log(tag, message);
        }

        @Override
        public void log (String tag, String message, Throwable exception) {
                if (logLevel >= LOG_INFO) getApplicationLogger().log(tag, message, exception);
        }

        @Override
        public void error (String tag, String message) {
                if (logLevel >= LOG_ERROR) getApplicationLogger().error(tag, message);
        }

        @Override
        public void error (String tag, String message, Throwable exception) {
                if (logLevel >= LOG_ERROR) getApplicationLogger().error(tag, message, exception);
        }

        @Override
        public void setLogLevel (int logLevel) {
                this.logLevel = logLevel;
        }

        @Override
        public int getLogLevel () {
                return logLevel;
        }

        @Override
        public void setApplicationLogger (ApplicationLogger applicationLogger) {
                this.applicationLogger = applicationLogger;
        }

        @Override
        public ApplicationLogger getApplicationLogger () {
                return applicationLogger;
        }

        @Override
        public void addLifecycleListener (LifecycleListener listener) {
                synchronized (lifecycleListeners) {
                        lifecycleListeners.add(listener);
                }
        }

        @Override
        public void removeLifecycleListener (LifecycleListener listener) {
                synchronized (lifecycleListeners) {
                        lifecycleListeners.removeValue(listener, true);
                }
        }

        @Override
        public Context getContext () {
                return this;
        }

        @Override
        public Array<Runnable> getRunnables () {
                return runnables;
        }

        @Override
        public Array<Runnable> getExecutedRunnables () {
                return executedRunnables;
        }

        @Override
        public SnapshotArray<LifecycleListener> getLifecycleListeners () {
                return lifecycleListeners;
        }

        @Override
        public Window getApplicationWindow () {
                return this.getWindow();
        }

        @Override
        public Handler getHandler () {
                return this.handler;
        }

        @Override
        public AndroidAudio createAudio (Context context, AndroidApplicationConfiguration config) {
                return new DefaultAndroidAudio(context, config);
        }

        @Override
        public AndroidInput createInput (Application activity, Context context, Object view, AndroidApplicationConfiguration config) {
                return new DefaultAndroidInput(this, this, graphics.view, config);
        }

        protected AndroidFiles createFiles () {
                this.getFilesDir(); // workaround for Android bug #10515463
                return new DefaultAndroidFiles(this.getAssets(), this, true);
        }

        @Override
        public void runOnUiThread (Runnable runnable) {
                if (Looper.myLooper() != Looper.getMainLooper()) {
                        // The current thread is not the UI thread.
                        // Let's post the runnable to the event queue of the UI thread.
                        new Handler(Looper.getMainLooper()).post(runnable);
                } else {
                        // The current thread is the UI thread already.
                        // Let's execute the runnable immediately.
                        runnable.run();
                }
        }

        @Override
        public void useImmersiveMode (boolean b) {
                throw new UnsupportedOperationException();
        }
}
","layoutParams
",params,frameLayoutPar,layoutParams,layoutParams,
"package com.alibaba.json.bvt.issue_1500;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.serializer.SerializeFilter;
import com.alibaba.fastjson.serializer.SerializerFeature;
import com.alibaba.fastjson.serializer.SimplePropertyPreFilter;
import junit.framework.TestCase;

public class Issue1580_private extends TestCase {
    public void test_for_issue() throws Exception {
        SimplePropertyPreFilter classAFilter = new SimplePropertyPreFilter(Model.class, ""code"");
        SerializeFilter[] filters =new SerializeFilter[]{classAFilter};

        Model  [MASK]  = new Model();
         [MASK] .code = 1001;
         [MASK] .name = ""N1"";

        String json = JSON.toJSONString( [MASK] , filters, SerializerFeature.BeanToArray );
        assertEquals(""[1001,null]"", json);
    }

    private static class Model {
        private int code;
        private String name;

        public int getCode() {
            return code;
        }

        public void setCode(int code) {
            this.code = code;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
}
","model
",modelModel,model,modelInstance,model,
"
package proguard.preverify;

import proguard.classfile.*;
import proguard.classfile.attribute.*;
import proguard.classfile.attribute.visitor.*;
import proguard.classfile.editor.CodeAttributeComposer;
import proguard.classfile.instruction.*;
import proguard.classfile.instruction.visitor.InstructionVisitor;
import proguard.classfile.util.SimplifiedVisitor;
import proguard.classfile.visitor.*;
import proguard.optimize.peephole.BranchTargetFinder;

/**
 * This AttributeVisitor inlines local subroutines (jsr/ret) in the code
 * attributes that it visits.
 *
 * @author Eric Lafortune
 */
public class CodeSubroutineInliner
extends      SimplifiedVisitor
implements   AttributeVisitor,
             InstructionVisitor,
             ExceptionInfoVisitor
{
    //*
    private static final boolean DEBUG = false;
    /*/
    private static       boolean DEBUG = System.getProperty(""csi"") != null;
    //*/

    private final BranchTargetFinder    branchTargetFinder    = new BranchTargetFinder();
    private final CodeAttributeComposer codeAttributeComposer = new CodeAttributeComposer(true, true, true);

    private ExceptionInfoVisitor subroutineExceptionInliner = this;
    private int                  clipStart                  = 0;
    private int                  clipEnd                    = Integer.MAX_VALUE;


    // Implementations for AttributeVisitor.

    public void visitAnyAttribute(Clazz clazz, Attribute attribute) {}


    public void visitCodeAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute)
    {
//        DEBUG =
//            clazz.getName().equals(""abc/Def"") &&
//            method.getName(clazz).equals(""abc"");
//        CodeAttributeComposer.DEBUG = DEBUG;

        // TODO: Remove this when the subroutine inliner has stabilized.
        // Catch any unexpected exceptions from the actual visiting method.
        try
        {
            // Process the code.
            visitCodeAttribute0(clazz, method, codeAttribute);
        }
        catch (RuntimeException ex)
        {
            System.err.println(""Unexpected error while inlining subroutines:"");
            System.err.println(""  Class       = [""+clazz.getName()+""]"");
            System.err.println(""  Method      = [""+method.getName(clazz)+method.getDescriptor(clazz)+""]"");
            System.err.println(""  Exception   = [""+ex.getClass().getName()+""] (""+ex.getMessage()+"")"");

            if (DEBUG)
            {
                method.accept(clazz, new ClassPrinter());
            }

            throw ex;
        }
    }


    public void visitCodeAttribute0(Clazz clazz, Method method, CodeAttribute codeAttribute)
    {
        branchTargetFinder.visitCodeAttribute(clazz, method, codeAttribute);

        // Don't bother if there aren't any subroutines anyway.
        if (!branchTargetFinder.containsSubroutines())
        {
            return;
        }

        if (DEBUG)
        {
            System.out.println(""SubroutineInliner: processing [""+clazz.getName()+"".""+method.getName(clazz)+method.getDescriptor(clazz)+""]"");
        }

        // Append the body of the code.
        codeAttributeComposer.reset();
        codeAttributeComposer.beginCodeFragment(codeAttribute.u4codeLength);

        // Copy the non-subroutine instructions.
        int offset  = 0;
        while (offset < codeAttribute.u4codeLength)
        {
            Instruction instruction = InstructionFactory.create(codeAttribute.code, offset);
            int instructionLength = instruction.length(offset);

            // Is this a returning subroutine?
            if (branchTargetFinder.isSubroutine(offset) &&
                branchTargetFinder.isSubroutineReturning(offset))
            {
                // Skip the subroutine.
                if (DEBUG)
                {
                    System.out.println(""  Skipping original subroutine instruction ""+instruction.toString(offset));
                }

                // Append a label at this offset instead.
                codeAttributeComposer.appendLabel(offset);
            }
            else
            {
                // Copy the instruction, inlining any subroutine call recursively.
                instruction.accept(clazz, method, codeAttribute, offset, this);
            }

            offset += instructionLength;
        }

        // Copy the exceptions. Note that exceptions with empty try blocks
        // are automatically removed.
        codeAttribute.exceptionsAccept(clazz,
                                       method,
                                       subroutineExceptionInliner);

        if (DEBUG)
        {
            System.out.println(""  Appending label after code at [""+offset+""]"");
        }

        // Append a label just after the code.
        codeAttributeComposer.appendLabel(codeAttribute.u4codeLength);

        // End and update the code attribute.
        codeAttributeComposer.endCodeFragment();
        codeAttributeComposer.visitCodeAttribute(clazz, method, codeAttribute);
    }


    /**
     * Appends the specified subroutine.
     */
    private void inlineSubroutine(Clazz         clazz,
                                  Method        method,
                                  CodeAttribute codeAttribute,
                                  int           subroutineInvocationOffset,
                                  int           subroutineStart)
    {
        int subroutineEnd = branchTargetFinder.subroutineEnd(subroutineStart);

        if (DEBUG)
        {
            System.out.println(""  Inlining subroutine [""+subroutineStart+"" -> ""+subroutineEnd+""] at [""+subroutineInvocationOffset+""]"");
        }

        // Don't go inlining exceptions that are already applicable to this
        // subroutine invocation.
        ExceptionInfoVisitor oldSubroutineExceptionInliner = subroutineExceptionInliner;
        int                   [MASK]                   = clipStart;
        int                  oldClipEnd                    = clipEnd;

        subroutineExceptionInliner =
            new ExceptionExcludedOffsetFilter(subroutineInvocationOffset,
                                              subroutineExceptionInliner);
        clipStart = subroutineStart;
        clipEnd   = subroutineEnd;

        codeAttributeComposer.beginCodeFragment(codeAttribute.u4codeLength);

        // Copy the subroutine instructions, inlining any subroutine calls
        // recursively.
        codeAttribute.instructionsAccept(clazz,
                                         method,
                                         subroutineStart,
                                         subroutineEnd,
                                         this);

        if (DEBUG)
        {
            System.out.println(""    Appending label after inlined subroutine at [""+subroutineEnd+""]"");
        }

        // Append a label just after the code.
        codeAttributeComposer.appendLabel(subroutineEnd);

        // Inline the subroutine exceptions.
        codeAttribute.exceptionsAccept(clazz,
                                       method,
                                       subroutineStart,
                                       subroutineEnd,
                                       subroutineExceptionInliner);

        // We can again inline exceptions that are applicable to this
        // subroutine invocation.
        subroutineExceptionInliner = oldSubroutineExceptionInliner;
        clipStart                  =  [MASK] ;
        clipEnd                    = oldClipEnd;

        codeAttributeComposer.endCodeFragment();
    }


    // Implementations for InstructionVisitor.

    public void visitAnyInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, Instruction instruction)
    {
        if (branchTargetFinder.isSubroutineStart(offset))
        {
            if (DEBUG)
            {
                System.out.println(""    Replacing first subroutine instruction ""+instruction.toString(offset)+"" by a label"");
            }

            // Append a label at this offset instead of saving the subroutine
            // return address.
            codeAttributeComposer.appendLabel(offset);
        }
        else
        {
            // Append the instruction.
            codeAttributeComposer.appendInstruction(offset, instruction);
        }
    }


    public void visitVariableInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, VariableInstruction variableInstruction)
    {
        byte opcode = variableInstruction.opcode;
        if (opcode == InstructionConstants.OP_RET)
        {
            // Is the return instruction the last instruction of the subroutine?
            if (branchTargetFinder.subroutineEnd(offset) == offset + variableInstruction.length(offset))
            {
                if (DEBUG)
                {
                    System.out.println(""    Replacing subroutine return at [""+offset+""] by a label"");
                }

                // Append a label at this offset instead of the subroutine return.
                codeAttributeComposer.appendLabel(offset);
            }
            else
            {
                if (DEBUG)
                {
                    System.out.println(""    Replacing subroutine return at [""+offset+""] by a simple branch"");
                }

                // Replace the instruction by a branch.
                Instruction replacementInstruction =
                    new BranchInstruction(InstructionConstants.OP_GOTO,
                                          branchTargetFinder.subroutineEnd(offset) - offset);

                codeAttributeComposer.appendInstruction(offset, replacementInstruction);
            }
        }
        else if (branchTargetFinder.isSubroutineStart(offset))
        {
            if (DEBUG)
            {
                System.out.println(""    Replacing first subroutine instruction ""+variableInstruction.toString(offset)+"" by a label"");
            }

            // Append a label at this offset instead of saving the subroutine
            // return address.
            codeAttributeComposer.appendLabel(offset);
        }
        else
        {
            // Append the instruction.
            codeAttributeComposer.appendInstruction(offset, variableInstruction);
        }
    }


    public void visitBranchInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, BranchInstruction branchInstruction)
    {
        byte opcode = branchInstruction.opcode;
        if (opcode == InstructionConstants.OP_JSR ||
            opcode == InstructionConstants.OP_JSR_W)
        {
            int branchOffset = branchInstruction.branchOffset;
            int branchTarget = offset + branchOffset;

            // Is the subroutine ever returning?
            if (branchTargetFinder.isSubroutineReturning(branchTarget))
            {
                // Append a label at this offset instead of the subroutine invocation.
                codeAttributeComposer.appendLabel(offset);

                // Inline the invoked subroutine.
                inlineSubroutine(clazz,
                                 method,
                                 codeAttribute,
                                 offset,
                                 branchTarget);
            }
            else
            {
                if (DEBUG)
                {
                    System.out.println(""Replacing subroutine invocation at [""+offset+""] by a simple branch"");
                }

                // Replace the subroutine invocation by a simple branch.
                Instruction replacementInstruction =
                    new BranchInstruction(InstructionConstants.OP_GOTO,
                                          branchOffset);

                codeAttributeComposer.appendInstruction(offset, replacementInstruction);
            }
        }
        else
        {
            // Append the instruction.
            codeAttributeComposer.appendInstruction(offset, branchInstruction);
        }
    }


    // Implementations for ExceptionInfoVisitor.

    public void visitExceptionInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, ExceptionInfo exceptionInfo)
    {
        int startPC   = Math.max(exceptionInfo.u2startPC, clipStart);
        int endPC     = Math.min(exceptionInfo.u2endPC,   clipEnd);
        int handlerPC = exceptionInfo.u2handlerPC;
        int catchType = exceptionInfo.u2catchType;

        // Exclude any subroutine invocations that jump out of the try block,
        // by adding a try block before (and later on, after) each invocation.
        for (int offset = startPC; offset < endPC; offset++)
        {
            if (branchTargetFinder.isSubroutineInvocation(offset))
            {
                Instruction instruction = InstructionFactory.create(codeAttribute.code, offset);
                int instructionLength = instruction.length(offset);

                // Is it a subroutine invocation?
                if (!exceptionInfo.isApplicable(offset + ((BranchInstruction)instruction).branchOffset))
                {
                    if (DEBUG)
                    {
                        System.out.println(""  Appending extra exception [""+startPC+"" -> ""+offset+""] -> ""+handlerPC);
                    }

                    // Append a try block that ends before the subroutine invocation.
                    codeAttributeComposer.appendException(new ExceptionInfo(startPC,
                                                                            offset,
                                                                            handlerPC,
                                                                            catchType));

                    // The next try block will start after the subroutine invocation.
                    startPC = offset + instructionLength;
                }
            }
        }

        if (DEBUG)
        {
            if (startPC == exceptionInfo.u2startPC &&
                endPC   == exceptionInfo.u2endPC)
            {
                System.out.println(""  Appending exception [""+startPC+"" -> ""+endPC+""] -> ""+handlerPC);
            }
            else
            {
                System.out.println(""  Appending clipped exception [""+exceptionInfo.u2startPC+"" -> ""+exceptionInfo.u2endPC+""] ~> [""+startPC+"" -> ""+endPC+""] -> ""+handlerPC);
            }
        }

        // Append the exception. Note that exceptions with empty try blocks
        // are automatically ignored.
        codeAttributeComposer.appendException(new ExceptionInfo(startPC,
                                                                endPC,
                                                                handlerPC,
                                                                catchType));
    }
}
","oldClipStart
",oldStart,oldClipStart,startOffset,subroutineIndex,
"package jadx.plugins.mappings.save;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import net.fabricmc.mappingio.MappedElementKind;
import net.fabricmc.mappingio.MappingUtil;
import net.fabricmc.mappingio.MappingWriter;
import net.fabricmc.mappingio.format.MappingFormat;
import net.fabricmc.mappingio.tree.MappingTree;
import net.fabricmc.mappingio.tree.MemoryMappingTree;

import jadx.api.ICodeInfo;
import jadx.api.data.ICodeComment;
import jadx.api.data.ICodeRename;
import jadx.api.data.IJavaNodeRef.RefType;
import jadx.api.data.impl.JadxCodeData;
import jadx.api.data.impl.JadxCodeRef;
import jadx.api.metadata.ICodeNodeRef;
import jadx.api.metadata.annotations.InsnCodeOffset;
import jadx.api.metadata.annotations.NodeDeclareRef;
import jadx.api.metadata.annotations.VarNode;
import jadx.api.utils.CodeUtils;
import jadx.core.Consts;
import jadx.core.codegen.TypeGen;
import jadx.core.dex.info.ClassInfo;
import jadx.core.dex.info.FieldInfo;
import jadx.core.dex.info.MethodInfo;
import jadx.core.dex.nodes.ClassNode;
import jadx.core.dex.nodes.FieldNode;
import jadx.core.dex.nodes.MethodNode;
import jadx.core.dex.nodes.RootNode;
import jadx.core.utils.files.FileUtils;
import jadx.plugins.mappings.RenameMappingsData;
import jadx.plugins.mappings.utils.DalvikToJavaBytecodeUtils;

public class MappingExporter {
        private static final Logger LOG = LoggerFactory.getLogger(MappingExporter.class);

        private final RootNode root;
        private final @Nullable MappingTree loadedMappingTree;

        public MappingExporter(RootNode root) {
                this.root = root;
                this.loadedMappingTree = RenameMappingsData.getTree(this.root);
        }

        private List<SimpleEntry<VarNode, Integer>> collectMethodVars(MethodNode methodNode) {
                ICodeInfo codeInfo = methodNode.getTopParentClass().getCode();
                int mthDefPos = methodNode.getDefPosition();
                int mthLineEndPos = CodeUtils.getLineEndForPos(codeInfo.getCodeStr(), mthDefPos);

                List<SimpleEntry<VarNode, Integer>> vars = new ArrayList<>();
                AtomicInteger lastOffset = new AtomicInteger(-1);
                codeInfo.getCodeMetadata().searchDown(mthLineEndPos, (pos, ann) -> {
                        if (ann instanceof InsnCodeOffset) {
                                lastOffset.set(((InsnCodeOffset) ann).getOffset());
                        }
                        if (ann instanceof NodeDeclareRef) {
                                ICodeNodeRef declRef = ((NodeDeclareRef) ann).getNode();
                                if (declRef instanceof VarNode) {
                                        VarNode varNode = (VarNode) declRef;
                                        if (!varNode.getMth().equals(methodNode)) {
                                                // Stop if we've gone too far and have entered a different method
                                                return Boolean.TRUE;
                                        }
                                        if (lastOffset.get() != -1) {
                                                vars.add(new SimpleEntry<VarNode, Integer>(varNode, lastOffset.get()));
                                        } else {
                                                LOG.warn(""Local variable not present in bytecode, skipping: ""
                                                                + methodNode.getMethodInfo().getRawFullId() + ""#"" + varNode.getName());
                                        }
                                        lastOffset.set(-1);
                                }
                        }
                        return null;
                });
                return vars;
        }

        public void exportMappings(Path path, JadxCodeData codeData, MappingFormat mappingFormat) {
                MemoryMappingTree mappingTree = new MemoryMappingTree();
                // Map < SrcName >
                Set<String> mappedClasses = new HashSet<>();
                // Map < DeclClass + ShortId >
                Set<String> mappedFields = new HashSet<>();
                Set<String> mappedMethods = new HashSet<>();
                Set<String> methodsWithMappedElements = new HashSet<>();
                // Map < DeclClass + MethodShortId + CodeRef, NewName >
                Map<String, String> mappedMethodArgsAndVars = new HashMap<>();
                // Map < DeclClass + *ShortId + *CodeRef, Comment >
                Map<String, String> comments = new HashMap<>();

                // We have to do this so we know for sure which elements are *manually* renamed
                for (ICodeRename codeRename : codeData.getRenames()) {
                        if (codeRename.getNodeRef().getType().equals(RefType.CLASS)) {
                                mappedClasses.add(codeRename.getNodeRef().getDeclaringClass());
                        } else if (codeRename.getNodeRef().getType().equals(RefType.FIELD)) {
                                mappedFields.add(codeRename.getNodeRef().getDeclaringClass() + codeRename.getNodeRef().getShortId());
                        } else if (codeRename.getNodeRef().getType().equals(RefType.METHOD)) {
                                if (codeRename.getCodeRef() == null) {
                                        mappedMethods.add(codeRename.getNodeRef().getDeclaringClass() + codeRename.getNodeRef().getShortId());
                                } else {
                                        methodsWithMappedElements.add(codeRename.getNodeRef().getDeclaringClass() + codeRename.getNodeRef().getShortId());
                                        mappedMethodArgsAndVars.put(codeRename.getNodeRef().getDeclaringClass()
                                                        + codeRename.getNodeRef().getShortId()
                                                        + codeRename.getCodeRef(),
                                                        codeRename.getNewName());
                                }
                        }
                }
                for (ICodeComment codeComment : codeData.getComments()) {
                        comments.put(codeComment.getNodeRef().getDeclaringClass()
                                        + (codeComment.getNodeRef().getShortId() == null ? """" : codeComment.getNodeRef().getShortId())
                                        + (codeComment.getCodeRef() == null ? """" : codeComment.getCodeRef()),
                                        codeComment.getComment());
                        if (codeComment.getCodeRef() != null) {
                                methodsWithMappedElements.add(codeComment.getNodeRef().getDeclaringClass() + codeComment.getNodeRef().getShortId());
                        }
                }

                try {
                        if (mappingFormat.hasSingleFile()) {
                                FileUtils.deleteFileIfExists(path);
                                FileUtils.makeDirsForFile(path);
                                Files.createFile(path);
                        } else {
                                FileUtils.makeDirs(path);
                        }

                        String srcNamespace = MappingUtil.NS_SOURCE_FALLBACK;
                        String dstNamespace = MappingUtil.NS_TARGET_FALLBACK;

                        // Copy mappings from potentially imported mappings file
                        if (loadedMappingTree != null && loadedMappingTree.getDstNamespaces() != null) {
                                loadedMappingTree.accept(mappingTree);
                        }

                        mappingTree.visitHeader();
                        mappingTree.visitNamespaces(srcNamespace, Collections.singletonList(dstNamespace));
                        mappingTree.visitContent();

                        for (ClassNode cls : root.getClasses()) {
                                ClassInfo classInfo = cls.getClassInfo();
                                String classPath = classInfo.makeRawFullName().replace('.', '/');
                                String rawClassName = classInfo.getRawName();

                                if (classInfo.hasAlias()
                                                && !classInfo.getAliasShortName().equals(classInfo.getShortName())
                                                && mappedClasses.contains(rawClassName)) {
                                        mappingTree.visitClass(classPath);
                                        String alias = classInfo.makeAliasRawFullName().replace('.', '/');

                                        if (alias.startsWith(Consts.DEFAULT_PACKAGE_NAME)) {
                                                alias = alias.substring(Consts.DEFAULT_PACKAGE_NAME.length() + 1);
                                        }
                                        mappingTree.visitDstName(MappedElementKind.CLASS, 0, alias);
                                }
                                if (comments.containsKey(rawClassName)) {
                                        mappingTree.visitClass(classPath);
                                        mappingTree.visitComment(MappedElementKind.CLASS, comments.get(rawClassName));
                                }

                                for (FieldNode fld : cls.getFields()) {
                                        FieldInfo fieldInfo = fld.getFieldInfo();
                                        if (fieldInfo.hasAlias() && mappedFields.contains(rawClassName + fieldInfo.getShortId())) {
                                                visitField(mappingTree, classPath, fieldInfo.getName(), TypeGen.signature(fieldInfo.getType()));
                                                mappingTree.visitDstName(MappedElementKind.FIELD, 0, fieldInfo.getAlias());
                                        }
                                        if (comments.containsKey(rawClassName + fieldInfo.getShortId())) {
                                                visitField(mappingTree, classPath, fieldInfo.getName(), TypeGen.signature(fieldInfo.getType()));
                                                mappingTree.visitComment(MappedElementKind.FIELD, comments.get(rawClassName + fieldInfo.getShortId()));
                                        }
                                }

                                for (MethodNode mth : cls.getMethods()) {
                                        MethodInfo methodInfo = mth.getMethodInfo();
                                        String methodName = methodInfo.getName();
                                        String methodDesc = methodInfo.getShortId().substring(methodName.length());
                                        if (methodInfo.hasAlias() && mappedMethods.contains(rawClassName + methodInfo.getShortId())) {
                                                visitMethod(mappingTree, classPath, methodName, methodDesc);
                                                mappingTree.visitDstName(MappedElementKind.METHOD, 0, methodInfo.getAlias());
                                        }
                                        if (comments.containsKey(rawClassName + methodInfo.getShortId())) {
                                                visitMethod(mappingTree, classPath, methodName, methodDesc);
                                                mappingTree.visitComment(MappedElementKind.METHOD, comments.get(rawClassName + methodInfo.getShortId()));
                                        }

                                        if (!methodsWithMappedElements.contains(rawClassName + methodInfo.getShortId())) {
                                                continue;
                                        }
                                        // Method args
                                        int lvtIndex = mth.getAccessFlags().isStatic() ? 0 : 1;
                                        List<VarNode> args = mth.collectArgsWithoutLoading();
                                        for (VarNode arg : args) {
                                                Integer lvIndex = DalvikToJavaBytecodeUtils.getMethodArgLvIndex(arg);
                                                if (lvIndex == null) {
                                                        lvIndex = -1;
                                                }
                                                String key = rawClassName + methodInfo.getShortId()
                                                                + JadxCodeRef.forVar(arg.getReg(), arg.getSsa());
                                                if (mappedMethodArgsAndVars.containsKey(key)) {
                                                        visitMethodArg(mappingTree, classPath, methodName, methodDesc, args.indexOf(arg), lvIndex);
                                                        mappingTree.visitDstName(MappedElementKind.METHOD_ARG, 0, mappedMethodArgsAndVars.get(key));
                                                        mappedMethodArgsAndVars.remove(key);
                                                }
                                                lvtIndex++;
                                                // Not checking for comments since method args can't have any
                                        }
                                        // Method vars
                                        List<SimpleEntry<VarNode, Integer>> vars = collectMethodVars(mth);
                                        for (SimpleEntry<VarNode, Integer> entry : vars) {
                                                VarNode var = entry.getKey();
                                                int  [MASK]  = entry.getValue();
                                                Integer lvIndex = DalvikToJavaBytecodeUtils.getMethodVarLvIndex(var);
                                                if (lvIndex == null) {
                                                        lvIndex = -1;
                                                }
                                                String key = rawClassName + methodInfo.getShortId()
                                                                + JadxCodeRef.forVar(var.getReg(), var.getSsa());
                                                if (mappedMethodArgsAndVars.containsKey(key)) {
                                                        visitMethodVar(mappingTree, classPath, methodName, methodDesc, lvtIndex, lvIndex,  [MASK] );
                                                        mappingTree.visitDstName(MappedElementKind.METHOD_VAR, 0, mappedMethodArgsAndVars.get(key));
                                                }
                                                key = rawClassName + methodInfo.getShortId() + JadxCodeRef.forInsn( [MASK] );
                                                if (comments.containsKey(key)) {
                                                        visitMethodVar(mappingTree, classPath, methodName, methodDesc, lvtIndex, lvIndex,  [MASK] );
                                                        mappingTree.visitComment(MappedElementKind.METHOD_VAR, comments.get(key));
                                                }
                                                lvtIndex++;
                                        }
                                }
                        }
                        // Write file
                        MappingWriter writer = MappingWriter.create(path, mappingFormat);
                        mappingTree.accept(writer);
                        mappingTree.visitEnd();
                        writer.close();
                } catch (IOException e) {
                        LOG.error(""Failed to save deobfuscation map file '{}'"", path.toAbsolutePath(), e);
                }
        }

        private void visitField(MemoryMappingTree tree, String classPath, String srcName, String srcDesc) {
                tree.visitClass(classPath);
                tree.visitField(srcName, srcDesc);
        }

        private void visitMethod(MemoryMappingTree tree, String classPath, String srcName, String srcDesc) {
                tree.visitClass(classPath);
                tree.visitMethod(srcName, srcDesc);
        }

        private void visitMethodArg(MemoryMappingTree tree, String classPath, String methodSrcName, String methodSrcDesc, int argPosition,
                        int lvIndex) {
                visitMethod(tree, classPath, methodSrcName, methodSrcDesc);
                tree.visitMethodArg(argPosition, lvIndex, null);
        }

        private void visitMethodVar(MemoryMappingTree tree, String classPath, String methodSrcName, String methodSrcDesc, int lvtIndex,
                        int lvIndex, int startOpIdx) {
                visitMethod(tree, classPath, methodSrcName, methodSrcDesc);
                tree.visitMethodVar(lvtIndex, lvIndex, startOpIdx, null);
        }
}
","offset
",insn,index,startOpIndex,startOperationIndex,
"

package com.tencent.tinker.build.apkparser;

import com.tencent.tinker.build.patch.Configuration;
import com.tencent.tinker.commons.util.IOHelper;

import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import tinker.net.dongliu.apk.parser.ApkParser;
import tinker.net.dongliu.apk.parser.bean.ApkMeta;
import tinker.net.dongliu.apk.parser.exception.ParserException;
import tinker.net.dongliu.apk.parser.parser.ApkMetaTranslator;
import tinker.net.dongliu.apk.parser.parser.BinaryXmlParser;
import tinker.net.dongliu.apk.parser.parser.CompositeXmlStreamer;
import tinker.net.dongliu.apk.parser.parser.ResourceTableParser;
import tinker.net.dongliu.apk.parser.parser.XmlTranslator;
import tinker.net.dongliu.apk.parser.struct.AndroidConstants;
import tinker.net.dongliu.apk.parser.struct.ResourceValue;
import tinker.net.dongliu.apk.parser.struct.StringPool;
import tinker.net.dongliu.apk.parser.struct.resource.ResourceTable;
import tinker.net.dongliu.apk.parser.struct.xml.Attribute;
import tinker.net.dongliu.apk.parser.utils.ParseUtils;
import tinker.net.dongliu.apk.parser.utils.Utils;

/**
 * Created by zhangshaowen on 16/5/5.
 */
public class AndroidParser {
    public static final int TYPE_SERVICE            = 1;
    public static final int TYPE_ACTIVITY           = 2;
    public static final int TYPE_BROADCAST_RECEIVER = 3;
    public static final int TYPE_CONTENT_PROVIDER   = 4;

    public final List<String> activities = new ArrayList<>();
    public final List<String> receivers  = new ArrayList<>();
    public final List<String> services   = new ArrayList<>();
    public final List<String> providers  = new ArrayList<>();
    public final ApkMeta apkMeta;
    public final String  xml;

    public final HashMap<String, String> metaDatas = new HashMap<>();


    public AndroidParser(ApkMeta apkMeta, String xml) throws ParserException {
        this.apkMeta = apkMeta;
        this.xml = xml;
        parse();
    }

    public static boolean resourceTableLogicalChange(Configuration config) throws IOException {
        ApkParser parser = new ApkParser(config.mOldApkFile);
        ApkParser newParser = new ApkParser(config.mNewApkFile);
        parser.parseResourceTable();
        newParser.parseResourceTable();
        return parser.getResourceTable().equals(newParser.getResourceTable());
    }

    public static void editResourceTableString(String from, String to, File originFile, File destFile) throws IOException {
        if (from == null || to == null) {
            return;
        }
        if (!originFile.exists()) {
            throw new RuntimeException(""origin resources.arsc is not exist, path:"" + originFile.getPath());
        }

        if (from.length() != to.length()) {
            throw new RuntimeException(""only support the same string length now!"");
        }
        ApkParser parser = new ApkParser();
        parser.parseResourceTable(originFile);
        ResourceTable resourceTable = parser.getResourceTable();
        StringPool stringPool = resourceTable.getStringPool();
        ByteBuffer buffer = resourceTable.getBuffers();
        byte[] array = buffer.array();
        int length = stringPool.getPool().length;
        boolean found = false;
        for (int i = 0; i < length; i++) {
            String value = stringPool.get(i);
            if (value.equals(from)) {
                found = true;
                long offset = stringPool.getPoolOffsets().get(i);
                //length
                offset += 2;
                byte[] tempByte;
                if (stringPool.isUtf8()) {
                    tempByte = to.getBytes(ParseUtils.charsetUTF8);
                    if (to.length() != tempByte.length) {
                        throw new RuntimeException(String.format(
                            ""editResourceTableString length is different, name %d, tempByte %d\n"", to.length(), tempByte.length));
                    }
                } else {
                    tempByte = to.getBytes(ParseUtils.charsetUTF16);
                    if ((to.length() * 2) != tempByte.length) {
                        throw new RuntimeException(String.format(
                            ""editResourceTableString length is different, name %d, tempByte %d\n"", to.length(), tempByte.length));
                    }
                }
                System.arraycopy(tempByte, 0, array, (int) offset, tempByte.length);
            }
        }
        if (!found) {
            throw new RuntimeException(""can't found string:"" + from + "" in the resources.arsc file's string pool!"");
        }

        //write array to file
        FileOutputStream fileOutputStream = null;
        try {
            fileOutputStream = new FileOutputStream(destFile);
            fileOutputStream.write(array);
        } finally {
            IOHelper.closeQuietly(fileOutputStream);
        }
    }

    public static AndroidParser getAndroidManifest(File file) throws IOException, ParseException {
        ZipFile zf = null;
        try {
            zf = new ZipFile(file);
            final ByteBuffer arscData = getZipEntryData(zf, AndroidConstants.RESOURCE_FILE);
            final ResourceTableParser resTableParser = new ResourceTableParser(arscData);
            resTableParser.parse();
            final ResourceTable resTable = resTableParser.getResourceTable();

            final ByteBuffer manifestData = getZipEntryData(zf, AndroidConstants.MANIFEST_FILE);
            final BinaryXmlParser xmlParser = new BinaryXmlParser(manifestData, resTable);
            final ApkMetaTranslator metaTranslator = new ApkMetaTranslator();
            final XmlTranslatorForPatch xmlTranslator = new XmlTranslatorForPatch();
            final CompositeXmlStreamer compositeStreamer = new CompositeXmlStreamer(metaTranslator, xmlTranslator);
            xmlParser.setXmlStreamer(compositeStreamer);
            xmlParser.parse();

            AndroidParser androidManifest = new AndroidParser(metaTranslator.getApkMeta(), xmlTranslator.getXml());
            return androidManifest;
        } finally {
            if (zf != null) {
                try {
                    zf.close();
                } catch (Throwable ignored) {
                    // Ignored.
                }
            }
        }
    }

    private static ByteBuffer getZipEntryData(ZipFile zf, String entryPath) throws IOException {
        final ZipEntry entry = zf.getEntry(entryPath);
        InputStream is = null;
        try {
            is = new BufferedInputStream(zf.getInputStream(entry));
            final byte[] data = Utils.toByteArray(is);
            return ByteBuffer.wrap(data);
        } finally {
            if (is != null) {
                try {
                    is.close();
                } catch (Throwable ignored) {
                    // Ignored.
                }
            }
        }
    }

    private static final class XmlTranslatorForPatch extends XmlTranslator {

        @Override
        public void onAttribute(Attribute attribute) {
            final ResourceValue attrVal = attribute.getTypedValue();
            if (attrVal != null && attrVal instanceof ResourceValue.ReferenceResourceValue) {
                attribute.setValue(attrVal.toString());
            }
            super.onAttribute(attribute);
        }
    }

    private static String getAttribute(NamedNodeMap namedNodeMap, String name) {
        Node node = namedNodeMap.getNamedItem(name);
        if (node == null) {
            if (name.startsWith(""android:"")) {
                name = name.substring(""android:"".length());
            }
            node = namedNodeMap.getNamedItem(name);
            if (node == null) {
                return null;
            }
        }
        return node.getNodeValue();
    }

    /**
     * @return a list of all components
     */
    public List<String> getComponents() {
        List<String> components = new ArrayList<>();
        components.addAll(activities);
        components.addAll(services);
        components.addAll(receivers);
        components.addAll(providers);
        return components;
    }

    private void parse() throws ParserException {
        DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
        Document document;
        try {
            DocumentBuilder builder = builderFactory.newDocumentBuilder();
            // Block any external content resolving actions since we don't need them and a report
            // says these actions may cause security problems.
            builder.setEntityResolver(new EntityResolver() {
                @Override
                public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {
                    return new InputSource();
                }
            });
            document = builder.parse(new ByteArrayInputStream(xml.getBytes(""UTF-8"")));
            Node manifestNode = document.getElementsByTagName(""manifest"").item(0);
            NodeList nodes = manifestNode.getChildNodes();
            for (int i = 0; i < nodes.getLength(); i++) {
                Node node = nodes.item(i);
                String nodeName = node.getNodeName();
                if (nodeName.equals(""application"")) {
                    NodeList  [MASK]  = node.getChildNodes();
                    for (int j = 0; j <  [MASK] .getLength(); j++) {
                        Node child =  [MASK] .item(j);
                        String childName = child.getNodeName();
                        switch (childName) {
                            case ""service"":
                                services.add(getAndroidComponent(child, TYPE_SERVICE));
                                break;
                            case ""activity"":
                                activities.add(getAndroidComponent(child, TYPE_ACTIVITY));
                                break;
                            case ""receiver"":
                                receivers.add(getAndroidComponent(child, TYPE_BROADCAST_RECEIVER));
                                break;
                            case ""provider"":
                                providers.add(getAndroidComponent(child, TYPE_CONTENT_PROVIDER));
                                break;
                            case ""meta-data"":
                                NamedNodeMap attributes = child.getAttributes();
                                metaDatas.put(getAttribute(attributes, ""android:name""), getAttribute(attributes, ""android:value""));
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
        } catch (Exception e) {
            throw new ParserException(""Error parsing AndroidManifest.xml"", e);
        }
    }

    private String getAndroidComponent(Node node, int type) {
        NamedNodeMap attributes = node.getAttributes();
        return getAttribute(attributes, ""android:name"");
    }
}
","children
",applicationNList,childList,componentNodes,componentNodes,
"

package com.google.j2objc.net;

import junit.framework.TestCase;

/**
 * Unit tests for {@link NSErrorException}.
 *
 * @author Tom Ball
 */
public class NSErrorExceptionTest extends TestCase {

  private static native Object createNSError(String domain, long code, String description,
      String  [MASK] , Object underlyingError) /*-[
    NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
    if (description_) {
      [userInfo setObject:description_ forKey:NSLocalizedDescriptionKey];
    }
    if ( [MASK] ) {
      [userInfo setObject: [MASK]  forKey:NSURLErrorFailingURLStringErrorKey];
    }
    if (underlyingError) {
      [userInfo setObject:underlyingError forKey:NSUnderlyingErrorKey];
    }
    return [NSError errorWithDomain:domain code:code userInfo:userInfo];
  ]-*/;

  public void testBasicError() {
    // NSURLErrorCancelled = -999.
    String description = ""cancelled"";
    Object nsError = createNSError(""NSURLErrorDomain"", -999, description, null, null);
    NSErrorException exception = new NSErrorException(nsError);
    assertEquals(""incorrect domain"", ""NSURLErrorDomain"", exception.getDomain());
    assertEquals(""incorrect code"", -999L, exception.getErrorCode());
    assertEquals(""incorrect description"", description, exception.getMessage());
    assertEquals(""incorrect code name"", ""NSURLErrorCancelled"", exception.getErrorName());
    assertNull(""unexpected URL"", exception.getFailingURLString());
    assertNull(""unexpected cause"", exception.getCause());
  }

  public void testNextedError() {
    // NSURLErrorSecureConnectionFailed = -1200, NSURLErrorServerCertificateUntrusted = -1202.
    String untrustedDescription = ""certificate untrusted"";
    String url = ""https://0.0.0.0"";
    Object untrustedError =
        createNSError(""NSURLErrorDomain"", -1202, untrustedDescription, url, null);
    String connectFailedDescription = ""secure connection failed"";
    Object nsError =
        createNSError(""NSURLErrorDomain"", -1200, connectFailedDescription, url, untrustedError);
    NSErrorException exception = new NSErrorException(nsError);
    assertEquals(""incorrect domain"", ""NSURLErrorDomain"", exception.getDomain());
    assertEquals(""incorrect code"", -1200L, exception.getErrorCode());
    assertEquals(""incorrect description"", connectFailedDescription, exception.getMessage());
    assertEquals(""incorrect code name"", ""NSURLErrorSecureConnectionFailed"",
        exception.getErrorName());
    assertEquals(""incorrect URL"", url, exception.getFailingURLString());
    NSErrorException cause = (NSErrorException) exception.getCause();
    assertNotNull(""no cause"", cause);

    assertEquals(""incorrect cause domain"", ""NSURLErrorDomain"", cause.getDomain());
    assertEquals(""incorrect cause code"", -1202L, cause.getErrorCode());
    assertEquals(""incorrect cause description"", untrustedDescription, cause.getMessage());
    assertEquals(""incorrect cause code name"", ""NSURLErrorServerCertificateUntrusted"",
        cause.getErrorName());
    assertEquals(""incorrect cause URL"", url, cause.getFailingURLString());
    assertNull(""unexpected nested cause"", cause.getCause());
  }
}
","failingURL
",fixedUrl,failingURLString,urlString,failingURLString,
"
package com.github.mikephil.charting.renderer;

import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Paint.Align;
import android.graphics.Path;
import android.graphics.RectF;

import com.github.mikephil.charting.components.LimitLine;
import com.github.mikephil.charting.components.YAxis;
import com.github.mikephil.charting.components.YAxis.AxisDependency;
import com.github.mikephil.charting.components.YAxis.YAxisLabelPosition;
import com.github.mikephil.charting.utils.MPPointD;
import com.github.mikephil.charting.utils.Transformer;
import com.github.mikephil.charting.utils.Utils;
import com.github.mikephil.charting.utils.ViewPortHandler;

import java.util.List;

public class YAxisRendererHorizontalBarChart extends YAxisRenderer {

    public YAxisRendererHorizontalBarChart(ViewPortHandler viewPortHandler, YAxis yAxis,
                                           Transformer trans) {
        super(viewPortHandler, yAxis, trans);

        mLimitLinePaint.setTextAlign(Align.LEFT);
    }

    /**
     * Computes the axis values.
     *
     * @param yMin - the minimum y-value in the data object for this axis
     * @param yMax - the maximum y-value in the data object for this axis
     */
    @Override
    public void computeAxis(float yMin, float yMax, boolean inverted) {

        // calculate the starting and entry point of the y-labels (depending on
        // zoom / contentrect bounds)
        if (mViewPortHandler.contentHeight() > 10 && !mViewPortHandler.isFullyZoomedOutX()) {

            MPPointD p1 = mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(),
                    mViewPortHandler.contentTop());
            MPPointD p2 = mTrans.getValuesByTouchPoint(mViewPortHandler.contentRight(),
                    mViewPortHandler.contentTop());

            if (!inverted) {
                yMin = (float) p1.x;
                yMax = (float) p2.x;
            } else {
                yMin = (float) p2.x;
                yMax = (float) p1.x;
            }

            MPPointD.recycleInstance(p1);
            MPPointD.recycleInstance(p2);
        }

        computeAxisValues(yMin, yMax);
    }

    /**
     * draws the y-axis labels to the screen
     */
    @Override
    public void renderAxisLabels(Canvas c) {

        if (!mYAxis.isEnabled() || !mYAxis.isDrawLabelsEnabled())
            return;

        float[] positions = getTransformedPositions();

        mAxisLabelPaint.setTypeface(mYAxis.getTypeface());
        mAxisLabelPaint.setTextSize(mYAxis.getTextSize());
        mAxisLabelPaint.setColor(mYAxis.getTextColor());
        mAxisLabelPaint.setTextAlign(Align.CENTER);

        float baseYOffset = Utils.convertDpToPixel(2.5f);
        float textHeight = Utils.calcTextHeight(mAxisLabelPaint, ""Q"");

        AxisDependency dependency = mYAxis.getAxisDependency();
        YAxisLabelPosition labelPosition = mYAxis.getLabelPosition();

        float yPos = 0f;

        if (dependency == AxisDependency.LEFT) {

            if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
                yPos = mViewPortHandler.contentTop() - baseYOffset;
            } else {
                yPos = mViewPortHandler.contentTop() - baseYOffset;
            }

        } else {

            if (labelPosition == YAxisLabelPosition.OUTSIDE_CHART) {
                yPos = mViewPortHandler.contentBottom() + textHeight + baseYOffset;
            } else {
                yPos = mViewPortHandler.contentBottom() + textHeight + baseYOffset;
            }
        }

        drawYLabels(c, yPos, positions, mYAxis.getYOffset());
    }

    @Override
    public void renderAxisLine(Canvas c) {

        if (!mYAxis.isEnabled() || !mYAxis.isDrawAxisLineEnabled())
            return;

        mAxisLinePaint.setColor(mYAxis.getAxisLineColor());
        mAxisLinePaint.setStrokeWidth(mYAxis.getAxisLineWidth());

        if (mYAxis.getAxisDependency() == AxisDependency.LEFT) {
            c.drawLine(mViewPortHandler.contentLeft(),
                    mViewPortHandler.contentTop(), mViewPortHandler.contentRight(),
                    mViewPortHandler.contentTop(), mAxisLinePaint);
        } else {
            c.drawLine(mViewPortHandler.contentLeft(),
                    mViewPortHandler.contentBottom(), mViewPortHandler.contentRight(),
                    mViewPortHandler.contentBottom(), mAxisLinePaint);
        }
    }

    /**
     * draws the y-labels on the specified x-position
     *
     * @param fixedPosition
     * @param positions
     */
    @Override
    protected void drawYLabels(Canvas c, float fixedPosition, float[] positions, float offset) {

        mAxisLabelPaint.setTypeface(mYAxis.getTypeface());
        mAxisLabelPaint.setTextSize(mYAxis.getTextSize());
        mAxisLabelPaint.setColor(mYAxis.getTextColor());

        final int from = mYAxis.isDrawBottomYLabelEntryEnabled() ? 0 : 1;
        final int to = mYAxis.isDrawTopYLabelEntryEnabled()
                ? mYAxis.mEntryCount
                : (mYAxis.mEntryCount - 1);

        float xOffset = mYAxis.getLabelXOffset();

        for (int i = from; i < to; i++) {

            String text = mYAxis.getFormattedLabel(i);

            c.drawText(text,
                    positions[i * 2],
                    fixedPosition - offset + xOffset,
                    mAxisLabelPaint);
        }
    }

    @Override
    protected float[] getTransformedPositions() {

        if(mGetTransformedPositionsBuffer.length != mYAxis.mEntryCount * 2) {
            mGetTransformedPositionsBuffer = new float[mYAxis.mEntryCount * 2];
        }
        float[] positions = mGetTransformedPositionsBuffer;

        for (int i = 0; i < positions.length; i += 2) {
            // only fill x values, y values are not needed for x-labels
            positions[i] = mYAxis.mEntries[i / 2];
        }

        mTrans.pointValuesToPixel(positions);
        return positions;
    }

    @Override
    public RectF getGridClippingRect() {
        mGridClippingRect.set(mViewPortHandler.getContentRect());
        mGridClippingRect.inset(-mAxis.getGridLineWidth(), 0.f);
        return mGridClippingRect;
    }

    @Override
    protected Path linePath(Path p, int i, float[] positions) {

        p.moveTo(positions[i], mViewPortHandler.contentTop());
        p.lineTo(positions[i], mViewPortHandler.contentBottom());

        return p;
    }

    protected Path mDrawZeroLinePathBuffer = new Path();

    @Override
    protected void drawZeroLine(Canvas c) {

        int clipRestoreCount = c.save();
        mZeroLineClippingRect.set(mViewPortHandler.getContentRect());
        mZeroLineClippingRect.inset(-mYAxis.getZeroLineWidth(), 0.f);
        c.clipRect(mLimitLineClippingRect);

        // draw zero line
        MPPointD pos = mTrans.getPixelForValues(0f, 0f);

        mZeroLinePaint.setColor(mYAxis.getZeroLineColor());
        mZeroLinePaint.setStrokeWidth(mYAxis.getZeroLineWidth());

        Path zeroLinePath = mDrawZeroLinePathBuffer;
        zeroLinePath.reset();

        zeroLinePath.moveTo((float) pos.x - 1, mViewPortHandler.contentTop());
        zeroLinePath.lineTo((float) pos.x - 1, mViewPortHandler.contentBottom());

        // draw a path because lines don't support dashing on lower android versions
        c.drawPath(zeroLinePath, mZeroLinePaint);

        c.restoreToCount(clipRestoreCount);
    }

    protected Path mRenderLimitLinesPathBuffer = new Path();
    protected float[] mRenderLimitLinesBuffer = new float[4];
    /**
     * Draws the LimitLines associated with this axis to the screen.
     * This is the standard XAxis renderer using the YAxis limit lines.
     *
     * @param c
     */
    @Override
    public void renderLimitLines(Canvas c) {

        List<LimitLine> limitLines = mYAxis.getLimitLines();

        if (limitLines == null || limitLines.size() <= 0)
            return;

        float[] pts = mRenderLimitLinesBuffer;
        pts[0] = 0;
        pts[1] = 0;
        pts[2] = 0;
        pts[3] = 0;
        Path limitLinePath = mRenderLimitLinesPathBuffer;
        limitLinePath.reset();

        for (int i = 0; i < limitLines.size(); i++) {

            LimitLine l = limitLines.get(i);

            if (!l.isEnabled())
                continue;

            int clipRestoreCount = c.save();
            mLimitLineClippingRect.set(mViewPortHandler.getContentRect());
            mLimitLineClippingRect.inset(-l.getLineWidth(), 0.f);
            c.clipRect(mLimitLineClippingRect);

            pts[0] = l.getLimit();
            pts[2] = l.getLimit();

            mTrans.pointValuesToPixel(pts);

            pts[1] = mViewPortHandler.contentTop();
            pts[3] = mViewPortHandler.contentBottom();

            limitLinePath.moveTo(pts[0], pts[1]);
            limitLinePath.lineTo(pts[2], pts[3]);

            mLimitLinePaint.setStyle(Paint.Style.STROKE);
            mLimitLinePaint.setColor(l.getLineColor());
            mLimitLinePaint.setPathEffect(l.getDashPathEffect());
            mLimitLinePaint.setStrokeWidth(l.getLineWidth());

            c.drawPath(limitLinePath, mLimitLinePaint);
            limitLinePath.reset();

            String label = l.getLabel();

            // if drawing the limit-value label is enabled
            if (label != null && !label.equals("""")) {

                mLimitLinePaint.setStyle(l.getTextStyle());
                mLimitLinePaint.setPathEffect(null);
                mLimitLinePaint.setColor(l.getTextColor());
                mLimitLinePaint.setTypeface(l.getTypeface());
                mLimitLinePaint.setStrokeWidth(0.5f);
                mLimitLinePaint.setTextSize(l.getTextSize());

                float xOffset = l.getLineWidth() + l.getXOffset();
                float yOffset = Utils.convertDpToPixel(2f) + l.getYOffset();

                final LimitLine.LimitLabelPosition position = l.getLabelPosition();

                if (position == LimitLine.LimitLabelPosition.RIGHT_TOP) {

                    final float  [MASK]  = Utils.calcTextHeight(mLimitLinePaint, label);
                    mLimitLinePaint.setTextAlign(Align.LEFT);
                    c.drawText(label, pts[0] + xOffset, mViewPortHandler.contentTop() + yOffset +  [MASK] , mLimitLinePaint);
                } else if (position == LimitLine.LimitLabelPosition.RIGHT_BOTTOM) {

                    mLimitLinePaint.setTextAlign(Align.LEFT);
                    c.drawText(label, pts[0] + xOffset, mViewPortHandler.contentBottom() - yOffset, mLimitLinePaint);
                } else if (position == LimitLine.LimitLabelPosition.LEFT_TOP) {

                    mLimitLinePaint.setTextAlign(Align.RIGHT);
                    final float  [MASK]  = Utils.calcTextHeight(mLimitLinePaint, label);
                    c.drawText(label, pts[0] - xOffset, mViewPortHandler.contentTop() + yOffset +  [MASK] , mLimitLinePaint);
                } else {

                    mLimitLinePaint.setTextAlign(Align.RIGHT);
                    c.drawText(label, pts[0] - xOffset, mViewPortHandler.contentBottom() - yOffset, mLimitLinePaint);
                }
            }

            c.restoreToCount(clipRestoreCount);
        }
    }
}
","labelLineHeight
",textHeight,limitLineTextHeight,textHeight,labelHeight,
"
package io.netty.handler.codec.frame;

import io.netty.buffer.ByteBuf;
import io.netty.channel.embedded.EmbeddedChannel;
import io.netty.handler.codec.EncoderException;
import io.netty.handler.codec.LengthFieldPrepender;
import io.netty.util.CharsetUtil;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static io.netty.buffer.Unpooled.*;
import java.nio.ByteOrder;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.fail;

public class LengthFieldPrependerTest {

    private ByteBuf msg;

    @BeforeEach
    public void setUp() throws Exception {
        msg = copiedBuffer(""A"", CharsetUtil.ISO_8859_1);
    }

    @Test
    public void testPrependLength() throws Exception {
        final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(4));
        ch.writeOutbound(msg);
        ByteBuf buf = ch.readOutbound();
        assertEquals(4, buf.readableBytes());
        assertEquals(msg.readableBytes(), buf.readInt());
        buf.release();

        buf = ch.readOutbound();
        assertSame(buf, msg);
        buf.release();
    }

    @Test
    public void testPrependLengthIncludesLengthFieldLength() throws Exception {
        final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(4, true));
        ch.writeOutbound(msg);
        ByteBuf buf = ch.readOutbound();
        assertEquals(4, buf.readableBytes());
        assertEquals(5, buf.readInt());
        buf.release();

        buf = ch.readOutbound();
        assertSame(buf, msg);
        buf.release();
    }

    @Test
    public void testPrependAdjustedLength() throws Exception {
        final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(4, -1));
        ch.writeOutbound(msg);
        ByteBuf buf = ch.readOutbound();
        assertEquals(4, buf.readableBytes());
        assertEquals(msg.readableBytes() - 1, buf.readInt());
        buf.release();

        buf = ch.readOutbound();
        assertSame(buf, msg);
        buf.release();
    }

    @Test
    public void testAdjustedLengthLessThanZero() throws Exception {
        final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(4, -2));
        try {
            ch.writeOutbound(msg);
            fail(EncoderException.class.getSimpleName() + "" must be raised."");
        } catch (EncoderException e) {
            // Expected
        }
    }

    @Test
    public void testPrependLengthInLittleEndian() throws Exception {
        final EmbeddedChannel ch = new EmbeddedChannel(new LengthFieldPrepender(ByteOrder.LITTLE_ENDIAN, 4, 0, false));
        ch.writeOutbound(msg);
        ByteBuf buf = ch.readOutbound();
        assertEquals(4, buf.readableBytes());
        byte[]  [MASK]  = new byte[buf.readableBytes()];
        buf.getBytes(0,  [MASK] );
        assertEquals(1,  [MASK] [0]);
        assertEquals(0,  [MASK] [1]);
        assertEquals(0,  [MASK] [2]);
        assertEquals(0,  [MASK] [3]);
        buf.release();

        buf = ch.readOutbound();
        assertSame(buf, msg);
        buf.release();
        assertFalse(ch.finish(), ""The channel must have been completely read"");
    }

}
","writtenBytes
",bytes,bytes,lengthFieldBytes,lengthBytes,
"
package io.netty.resolver.dns;

import io.netty.channel.EventLoop;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioDatagramChannel;
import io.netty.handler.codec.dns.DnsRecord;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.util.List;

import static io.netty.resolver.dns.Cache.MAX_SUPPORTED_TTL_SECS;
import static org.assertj.core.api.Assertions.assertThat;

class DnsNameResolverBuilderTest {
    private static final EventLoopGroup GROUP = new NioEventLoopGroup(1);

    private DnsNameResolverBuilder builder;
    private DnsNameResolver resolver;

    @BeforeEach
    void setUp() {
        builder = new DnsNameResolverBuilder(GROUP.next()).channelType(NioDatagramChannel.class);
    }

    @AfterEach
    void tearDown() {
        if (resolver != null) {
            resolver.close();
        }
    }

    @AfterAll
    static void shutdownEventLoopGroup() {
        GROUP.shutdownGracefully();
    }

    @Test
    void testDefaults() {
        resolver = builder.build();

        checkDefaultDnsCache((DefaultDnsCache) resolver.resolveCache(), MAX_SUPPORTED_TTL_SECS, 0, 0);

        checkDefaultDnsCnameCache((DefaultDnsCnameCache) resolver.cnameCache(), MAX_SUPPORTED_TTL_SECS, 0);

        checkDefaultAuthoritativeDnsServerCache(
                (DefaultAuthoritativeDnsServerCache) resolver.authoritativeDnsServerCache(), MAX_SUPPORTED_TTL_SECS, 0);
    }

    @Test
    void testCustomDnsCacheDefaultTtl() {
        DnsCache testDnsCache = new TestDnsCache();
        resolver = builder.resolveCache(testDnsCache).build();

        assertThat(resolver.resolveCache()).isSameAs(testDnsCache);

        checkDefaultDnsCnameCache((DefaultDnsCnameCache) resolver.cnameCache(), MAX_SUPPORTED_TTL_SECS, 0);

        checkDefaultAuthoritativeDnsServerCache(
                (DefaultAuthoritativeDnsServerCache) resolver.authoritativeDnsServerCache(), MAX_SUPPORTED_TTL_SECS, 0);
    }

    @Test
    void testCustomDnsCacheCustomTtl() {
        DnsCache testDnsCache = new TestDnsCache();
        resolver = builder.resolveCache(testDnsCache).ttl(1, 2).negativeTtl(3).build();

        assertThat(resolver.resolveCache()).isSameAs(testDnsCache);

        checkDefaultDnsCnameCache((DefaultDnsCnameCache) resolver.cnameCache(), 2, 1);

        checkDefaultAuthoritativeDnsServerCache(
                (DefaultAuthoritativeDnsServerCache) resolver.authoritativeDnsServerCache(), 2, 1);
    }

    @Test
    void testCustomDnsCnameCacheDefaultTtl() {
        DnsCnameCache testDnsCnameCache = new TestDnsCnameCache();
        resolver = builder.cnameCache(testDnsCnameCache).build();

        checkDefaultDnsCache((DefaultDnsCache) resolver.resolveCache(), MAX_SUPPORTED_TTL_SECS, 0, 0);

        assertThat(resolver.cnameCache()).isSameAs(testDnsCnameCache);

        checkDefaultAuthoritativeDnsServerCache(
                (DefaultAuthoritativeDnsServerCache) resolver.authoritativeDnsServerCache(), MAX_SUPPORTED_TTL_SECS, 0);
    }

    @Test
    void testCustomDnsCnameCacheCustomTtl() {
        DnsCnameCache testDnsCnameCache = new TestDnsCnameCache();
        resolver = builder.cnameCache(testDnsCnameCache).ttl(1, 2).negativeTtl(3).build();

        checkDefaultDnsCache((DefaultDnsCache) resolver.resolveCache(), 2, 1, 3);

        assertThat(resolver.cnameCache()).isSameAs(testDnsCnameCache);

        checkDefaultAuthoritativeDnsServerCache(
                (DefaultAuthoritativeDnsServerCache) resolver.authoritativeDnsServerCache(), 2, 1);
    }

    @Test
    void testCustomAuthoritativeDnsServerCacheDefaultTtl() {
        AuthoritativeDnsServerCache testAuthoritativeDnsServerCache = new TestAuthoritativeDnsServerCache();
        resolver = builder.authoritativeDnsServerCache(testAuthoritativeDnsServerCache).build();

        checkDefaultDnsCache((DefaultDnsCache) resolver.resolveCache(), MAX_SUPPORTED_TTL_SECS, 0, 0);

        checkDefaultDnsCnameCache((DefaultDnsCnameCache) resolver.cnameCache(), MAX_SUPPORTED_TTL_SECS, 0);

        assertThat(resolver.authoritativeDnsServerCache()).isSameAs(testAuthoritativeDnsServerCache);
    }

    @Test
    void testCustomAuthoritativeDnsServerCacheCustomTtl() {
        AuthoritativeDnsServerCache testAuthoritativeDnsServerCache = new TestAuthoritativeDnsServerCache();
        resolver = builder.authoritativeDnsServerCache(testAuthoritativeDnsServerCache)
                .ttl(1, 2).negativeTtl(3).build();

        checkDefaultDnsCache((DefaultDnsCache) resolver.resolveCache(), 2, 1, 3);

        checkDefaultDnsCnameCache((DefaultDnsCnameCache) resolver.cnameCache(), 2, 1);

        assertThat(resolver.authoritativeDnsServerCache()).isSameAs(testAuthoritativeDnsServerCache);
    }

    @Test
    void disableQueryTimeoutWithZero() {
        resolver = builder.queryTimeoutMillis(0).build();
        assertThat(resolver.queryTimeoutMillis()).isEqualTo(0);
    }

    private static void checkDefaultDnsCache(DefaultDnsCache dnsCache,
            int expectedMaxTtl, int expectedMinTtl, int expectedNegativeTtl) {
        assertThat(dnsCache.maxTtl()).isEqualTo(expectedMaxTtl);
        assertThat(dnsCache.minTtl()).isEqualTo(expectedMinTtl);
        assertThat(dnsCache.negativeTtl()).isEqualTo(expectedNegativeTtl);
    }

    private static void checkDefaultDnsCnameCache(DefaultDnsCnameCache dnsCnameCache,
            int expectedMaxTtl, int expectedMinTtl) {
        assertThat(dnsCnameCache.maxTtl()).isEqualTo(expectedMaxTtl);
        assertThat(dnsCnameCache.minTtl()).isEqualTo(expectedMinTtl);
    }

    private static void checkDefaultAuthoritativeDnsServerCache(
            DefaultAuthoritativeDnsServerCache authoritativeDnsServerCache,
            int expectedMaxTtl, int expectedMinTtl) {
        assertThat(authoritativeDnsServerCache.maxTtl()).isEqualTo(expectedMaxTtl);
        assertThat(authoritativeDnsServerCache.minTtl()).isEqualTo(expectedMinTtl);
    }

    private static final class TestDnsCache implements DnsCache {

        @Override
        public void clear() {
            //no-op
        }

        @Override
        public boolean clear(String hostname) {
            return false;
        }

        @Override
        public List<? extends DnsCacheEntry> get(String hostname, DnsRecord[] additional) {
            return null;
        }

        @Override
        public DnsCacheEntry cache(String hostname, DnsRecord[] additional, InetAddress address,
                long originalTtl, EventLoop loop) {
            return null;
        }

        @Override
        public DnsCacheEntry cache(String hostname, DnsRecord[] additional, Throwable  [MASK] , EventLoop loop) {
            return null;
        }
    }

    private static final class TestDnsCnameCache implements DnsCnameCache {

        @Override
        public String get(String hostname) {
            return null;
        }

        @Override
        public void cache(String hostname, String cname, long originalTtl, EventLoop loop) {
            //no-op
        }

        @Override
        public void clear() {
            //no-op
        }

        @Override
        public boolean clear(String hostname) {
            return false;
        }
    }

    private static final class TestAuthoritativeDnsServerCache implements AuthoritativeDnsServerCache {

        @Override
        public DnsServerAddressStream get(String hostname) {
            return null;
        }

        @Override
        public void cache(String hostname, InetSocketAddress address, long originalTtl, EventLoop loop) {
            //no-op
        }

        @Override
        public void clear() {
            //no-op
        }

        @Override
        public boolean clear(String hostname) {
            return false;
        }
    }
}
","cause
",cause,cause,error,errors,