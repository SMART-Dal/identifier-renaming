X,y
"/*
 * Copyright 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.ext.ima;

import static com.google.android.exoplayer2.Player.COMMAND_GET_VOLUME;
import static com.google.android.exoplayer2.ext.ima.ImaUtil.BITRATE_UNSET;
import static com.google.android.exoplayer2.ext.ima.ImaUtil.TIMEOUT_UNSET;
import static com.google.android.exoplayer2.ext.ima.ImaUtil.getAdGroupTimesUsForCuePoints;
import static com.google.android.exoplayer2.ext.ima.ImaUtil.getImaLooper;
import static com.google.android.exoplayer2.util.Assertions.checkNotNull;
import static com.google.android.exoplayer2.util.Assertions.checkState;
import static com.google.android.exoplayer2.util.Util.msToUs;
import static java.lang.Math.max;
import static java.lang.annotation.ElementType.TYPE_USE;

import android.content.Context;
import android.net.Uri;
import android.os.Handler;
import android.os.SystemClock;
import android.view.ViewGroup;
import androidx.annotation.IntDef;
import androidx.annotation.Nullable;
import com.google.ads.interactivemedia.v3.api.AdDisplayContainer;
import com.google.ads.interactivemedia.v3.api.AdError;
import com.google.ads.interactivemedia.v3.api.AdErrorEvent;
import com.google.ads.interactivemedia.v3.api.AdErrorEvent.AdErrorListener;
import com.google.ads.interactivemedia.v3.api.AdEvent;
import com.google.ads.interactivemedia.v3.api.AdEvent.AdEventListener;
import com.google.ads.interactivemedia.v3.api.AdEvent.AdEventType;
import com.google.ads.interactivemedia.v3.api.AdPodInfo;
import com.google.ads.interactivemedia.v3.api.AdsLoader;
import com.google.ads.interactivemedia.v3.api.AdsLoader.AdsLoadedListener;
import com.google.ads.interactivemedia.v3.api.AdsManager;
import com.google.ads.interactivemedia.v3.api.AdsManagerLoadedEvent;
import com.google.ads.interactivemedia.v3.api.AdsRenderingSettings;
import com.google.ads.interactivemedia.v3.api.AdsRequest;
import com.google.ads.interactivemedia.v3.api.ImaSdkSettings;
import com.google.ads.interactivemedia.v3.api.player.AdMediaInfo;
import com.google.ads.interactivemedia.v3.api.player.ContentProgressProvider;
import com.google.ads.interactivemedia.v3.api.player.VideoAdPlayer;
import com.google.ads.interactivemedia.v3.api.player.VideoAdPlayer.VideoAdPlayerCallback;
import com.google.ads.interactivemedia.v3.api.player.VideoProgressUpdate;
import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.ExoPlayerLibraryInfo;
import com.google.android.exoplayer2.PlaybackException;
import com.google.android.exoplayer2.Player;
import com.google.android.exoplayer2.Timeline;
import com.google.android.exoplayer2.source.ads.AdPlaybackState;
import com.google.android.exoplayer2.source.ads.AdsLoader.EventListener;
import com.google.android.exoplayer2.source.ads.AdsMediaSource.AdLoadException;
import com.google.android.exoplayer2.ui.AdOverlayInfo;
import com.google.android.exoplayer2.ui.AdViewProvider;
import com.google.android.exoplayer2.upstream.DataSpec;
import com.google.android.exoplayer2.util.Log;
import com.google.android.exoplayer2.util.Util;
import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import java.io.IOException;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Handles loading and playback of a single ad tag.
 *
 * @deprecated com.google.android.exoplayer2 is deprecated. Please migrate to androidx.media3 (which
 *     contains the same ExoPlayer code). See <a
 *     href=""https://developer.android.com/guide/topics/media/media3/getting-started/migration-guide"">the
 *     migration guide</a> for more details, including a script to help with the migration.
 */
@Deprecated
/* package */ final class AdTagLoader implements Player.Listener {

  private static final String TAG = ""AdTagLoader"";

  private static final String IMA_SDK_SETTINGS_PLAYER_TYPE = ""google/exo.ext.ima"";
  private static final String IMA_SDK_SETTINGS_PLAYER_VERSION = ExoPlayerLibraryInfo.VERSION;

  /**
   * Interval at which ad progress updates are provided to the IMA SDK, in milliseconds. 200 ms is
   * the interval recommended by the Media Rating Council (MRC) for minimum polling of viewable
   * video impressions.
   * http://www.mediaratingcouncil.org/063014%20Viewable%20Ad%20Impression%20Guideline_Final.pdf.
   *
   * @see VideoAdPlayer.VideoAdPlayerCallback
   */
  private static final int AD_PROGRESS_UPDATE_INTERVAL_MS = 200;

  /** The value used in {@link VideoProgressUpdate}s to indicate an unset duration. */
  private static final long IMA_DURATION_UNSET = -1L;

  /**
   * Threshold before the end of content at which IMA is notified that content is complete if the
   * player buffers, in milliseconds.
   */
  private static final long THRESHOLD_END_OF_CONTENT_MS = 5000;
  /**
   * Threshold before the start of an ad at which IMA is expected to be able to preload the ad, in
   * milliseconds.
   */
  private static final long THRESHOLD_AD_PRELOAD_MS = 4000;
  /** The threshold below which ad cue points are treated as matching, in microseconds. */
  private static final long THRESHOLD_AD_MATCH_US = 1000;

  /** The state of ad playback. */
  @Documented
  @Retention(RetentionPolicy.SOURCE)
  @Target(TYPE_USE)
  @IntDef({IMA_AD_STATE_NONE, IMA_AD_STATE_PLAYING, IMA_AD_STATE_PAUSED})
  private @interface ImaAdState {}

  /** The ad playback state when IMA is not playing an ad. */
  private static final int IMA_AD_STATE_NONE = 0;
  /**
   * The ad playback state when IMA has called {@link ComponentListener#playAd(AdMediaInfo)} and not
   * {@link ComponentListener##pauseAd(AdMediaInfo)}.
   */
  private static final int IMA_AD_STATE_PLAYING = 1;
  /**
   * The ad playback state when IMA has called {@link ComponentListener#pauseAd(AdMediaInfo)} while
   * playing an ad.
   */
  private static final int IMA_AD_STATE_PAUSED = 2;

  private final ImaUtil.Configuration configuration;
  private final ImaUtil.ImaFactory imaFactory;
  private final List<String> supportedMimeTypes;
  private final DataSpec adTagDataSpec;
  private final Object adsId;
  private final Timeline.Period period;
  private final Handler handler;
  private final ComponentListener componentListener;
  private final List<EventListener> eventListeners;
  private final List<VideoAdPlayer.VideoAdPlayerCallback> adCallbacks;
  private final Runnable updateAdProgressRunnable;
  private final BiMap<AdMediaInfo, AdInfo> adInfoByAdMediaInfo;
  private final AdDisplayContainer adDisplayContainer;
  private final AdsLoader adsLoader;
  private final Runnable adLoadTimeoutRunnable;

  @Nullable private Object pendingAdRequestContext;
  @Nullable private Player player;
  private VideoProgressUpdate lastContentProgress;
  private VideoProgressUpdate lastAdProgress;
  private int lastVolumePercent;

  @Nullable private AdsManager adsManager;
  private boolean isAdsManagerInitialized;
  @Nullable private AdLoadException pendingAdLoadError;
  private Timeline timeline;
  private long contentDurationMs;
  private AdPlaybackState adPlaybackState;

  private boolean released;

  // Fields tracking IMA's state.

  /** Whether IMA has sent an ad event to pause content since the last resume content event. */
  private boolean imaPausedContent;
  /** The current ad playback state. */
  private @ImaAdState int imaAdState;
  /** The current ad media info, or {@code null} if in state {@link #IMA_AD_STATE_NONE}. */
  @Nullable private AdMediaInfo imaAdMediaInfo;
  /** The current ad info, or {@code null} if in state {@link #IMA_AD_STATE_NONE}. */
  @Nullable private AdInfo imaAdInfo;
  /** Whether IMA has been notified that playback of content has finished. */
  private boolean sentContentComplete;

  // Fields tracking the player/loader state.

  /** Whether the player is playing an ad. */
  private boolean playingAd;
  /** Whether the player is buffering an ad. */
  private boolean bufferingAd;
  /**
   * If the player is playing an ad, stores the ad index in its ad group. {@link C#INDEX_UNSET}
   * otherwise.
   */
  private int playingAdIndexInAdGroup;
  /**
   * The ad info for a pending ad for which the media failed preparation, or {@code null} if no
   * pending ads have failed to prepare.
   */
  @Nullable private AdInfo pendingAdPrepareErrorAdInfo;
  /**
   * If a content period has finished but IMA has not yet called {@link
   * ComponentListener#playAd(AdMediaInfo)}, stores the value of {@link
   * SystemClock#elapsedRealtime()} when the content stopped playing. This can be used to determine
   * a fake, increasing content position. {@link C#TIME_UNSET} otherwise.
   */
  private long fakeContentProgressElapsedRealtimeMs;
  /**
   * If {@link #fakeContentProgressElapsedRealtimeMs} is set, stores the offset from which the
   * content progress should increase. {@link C#TIME_UNSET} otherwise.
   */
  private long fakeContentProgressOffsetMs;
  /** Stores the pending content position when a seek operation was intercepted to play an ad. */
  private long pendingContentPositionMs;
  /**
   * Whether {@link ComponentListener#getContentProgress()} has sent {@link
   * #pendingContentPositionMs} to IMA.
   */
  private boolean sentPendingContentPositionMs;
  /**
   * Stores the real time in milliseconds at which the player started buffering, possibly due to not
   * having preloaded an ad, or {@link C#TIME_UNSET} if not applicable.
   */
  private long waitingForPreloadElapsedRealtimeMs;

  /** Creates a new ad tag loader, starting the ad request if the ad tag is valid. */
  @SuppressWarnings({""nullness:methodref.receiver.bound"", ""nullness:method.invocation""})
  public AdTagLoader(
      Context context,
      ImaUtil.Configuration configuration,
      ImaUtil.ImaFactory imaFactory,
      List<String> supportedMimeTypes,
      DataSpec adTagDataSpec,
      Object adsId,
      @Nullable ViewGroup adViewGroup) {
    this.configuration = configuration;
    this.imaFactory = imaFactory;
    @Nullable ImaSdkSettings imaSdkSettings = configuration.imaSdkSettings;
    if (imaSdkSettings == null) {
      imaSdkSettings = imaFactory.createImaSdkSettings();
      if (configuration.debugModeEnabled) {
        imaSdkSettings.setDebugMode(true);
      }
    }
    imaSdkSettings.setPlayerType(IMA_SDK_SETTINGS_PLAYER_TYPE);
    imaSdkSettings.setPlayerVersion(IMA_SDK_SETTINGS_PLAYER_VERSION);
    this.supportedMimeTypes = supportedMimeTypes;
    this.adTagDataSpec = adTagDataSpec;
    this.adsId = adsId;
    period = new Timeline.Period();
    handler = Util.createHandler(getImaLooper(), /* callback= */ null);
    componentListener = new ComponentListener();
    eventListeners = new ArrayList<>();
    adCallbacks = new ArrayList<>(/* initialCapacity= */ 1);
    if (configuration.applicationVideoAdPlayerCallback != null) {
      adCallbacks.add(configuration.applicationVideoAdPlayerCallback);
    }
    updateAdProgressRunnable = this::updateAdProgress;
    adInfoByAdMediaInfo = HashBiMap.create();
    lastContentProgress = VideoProgressUpdate.VIDEO_TIME_NOT_READY;
    lastAdProgress = VideoProgressUpdate.VIDEO_TIME_NOT_READY;
    fakeContentProgressElapsedRealtimeMs = C.TIME_UNSET;
    fakeContentProgressOffsetMs = C.TIME_UNSET;
    pendingContentPositionMs = C.TIME_UNSET;
    waitingForPreloadElapsedRealtimeMs = C.TIME_UNSET;
    contentDurationMs = C.TIME_UNSET;
    timeline = Timeline.EMPTY;
    adPlaybackState = AdPlaybackState.NONE;
    adLoadTimeoutRunnable = this::handleAdLoadTimeout;
    if (adViewGroup != null) {
      adDisplayContainer =
          imaFactory.createAdDisplayContainer(adViewGroup, /* player= */ componentListener);
    } else {
      adDisplayContainer =
          imaFactory.createAudioAdDisplayContainer(context, /* player= */ componentListener);
    }
    if (configuration.companionAdSlots != null) {
      adDisplayContainer.setCompanionSlots(configuration.companionAdSlots);
    }
    adsLoader = requestAds(context, imaSdkSettings, adDisplayContainer);
  }

  /** Returns the underlying IMA SDK ads loader. */
  public AdsLoader getAdsLoader() {
    return adsLoader;
  }

  /** Returns the IMA SDK ad display container. */
  public AdDisplayContainer getAdDisplayContainer() {
    return adDisplayContainer;
  }

  /** Skips the current skippable ad, if there is one. */
  public void skipAd() {
    if (adsManager != null) {
      adsManager.skip();
    }
  }

  /**
   * Moves UI focus to the skip button (or other interactive elements), if currently shown. See
   * {@link AdsManager#focus()}.
   */
  public void focusSkipButton() {
    if (adsManager != null) {
      adsManager.focus();
    }
  }

  /**
   * Starts passing events from this instance (including any pending ad playback state) and
   * registers obstructions.
   */
  public void addListenerWithAdView(EventListener eventListener, AdViewProvider adViewProvider) {
    boolean isStarted = !eventListeners.isEmpty();
    eventListeners.add(eventListener);
    if (isStarted) {
      if (!AdPlaybackState.NONE.equals(adPlaybackState)) {
        // Pass the existing ad playback state to the new listener.
        eventListener.onAdPlaybackState(adPlaybackState);
      }
      return;
    }
    lastVolumePercent = 0;
    lastAdProgress = VideoProgressUpdate.VIDEO_TIME_NOT_READY;
    lastContentProgress = VideoProgressUpdate.VIDEO_TIME_NOT_READY;
    maybeNotifyPendingAdLoadError();
    if (!AdPlaybackState.NONE.equals(adPlaybackState)) {
      // Pass the ad playback state to the player, and resume ads if necessary.
      eventListener.onAdPlaybackState(adPlaybackState);
    } else if (adsManager != null) {
      adPlaybackState =
          new AdPlaybackState(adsId, getAdGroupTimesUsForCuePoints(adsManager.getAdCuePoints()));
      updateAdPlaybackState();
    }
    for (AdOverlayInfo overlayInfo : adViewProvider.getAdOverlayInfos()) {
      adDisplayContainer.registerFriendlyObstruction(
          imaFactory.createFriendlyObstruction(
              overlayInfo.view,
              ImaUtil.getFriendlyObstructionPurpose(overlayInfo.purpose),
              overlayInfo.reasonDetail));
    }
  }

  /**
   * Populates the ad playback state with loaded cue points, if available. Any preroll will be
   * paused immediately while waiting for this instance to be {@link #activate(Player) activated}.
   */
  public void maybePreloadAds(long contentPositionMs, long contentDurationMs) {
    maybeInitializeAdsManager(contentPositionMs, contentDurationMs);
  }

  /** Activates playback. */
  public void activate(Player player) {
    this.player = player;
    player.addListener(this);

    boolean playWhenReady = player.getPlayWhenReady();
    onTimelineChanged(player.getCurrentTimeline(), Player.TIMELINE_CHANGE_REASON_SOURCE_UPDATE);
    @Nullable AdsManager adsManager = this.adsManager;
    if (!AdPlaybackState.NONE.equals(adPlaybackState) && adsManager != null && imaPausedContent) {
      // Check whether the current ad break matches the expected ad break based on the current
      // position. If not, discard the current ad break so that the correct ad break can load.
      long contentPositionMs = getContentPeriodPositionMs(player, timeline, period);
      int adGroupForPositionIndex =
          adPlaybackState.getAdGroupIndexForPositionUs(
              msToUs(contentPositionMs), msToUs(contentDurationMs));
      if (adGroupForPositionIndex != C.INDEX_UNSET
          && imaAdInfo != null
          && imaAdInfo.adGroupIndex != adGroupForPositionIndex) {
        if (configuration.debugModeEnabled) {
          Log.d(TAG, ""Discarding preloaded ad "" + imaAdInfo);
        }
        adsManager.discardAdBreak();
      }
      if (playWhenReady) {
        adsManager.resume();
      }
    }
  }

  /** Deactivates playback. */
  public void deactivate() {
    Player player = checkNotNull(this.player);
    if (!AdPlaybackState.NONE.equals(adPlaybackState) && imaPausedContent) {
      if (adsManager != null) {
        adsManager.pause();
      }
      adPlaybackState =
          adPlaybackState.withAdResumePositionUs(
              playingAd ? msToUs(player.getCurrentPosition()) : 0);
    }
    lastVolumePercent = getPlayerVolumePercent();
    lastAdProgress = getAdVideoProgressUpdate();
    lastContentProgress = getContentVideoProgressUpdate();

    player.removeListener(this);
    this.player = null;
  }

  /** Stops passing of events from this instance and unregisters obstructions. */
  public void removeListener(EventListener eventListener) {
    eventListeners.remove(eventListener);
    if (eventListeners.isEmpty()) {
      adDisplayContainer.unregisterAllFriendlyObstructions();
    }
  }

  /** Releases all resources used by the ad tag loader. */
  public void release() {
    if (released) {
      return;
    }
    released = true;
    pendingAdRequestContext = null;
    destroyAdsManager();
    adsLoader.removeAdsLoadedListener(componentListener);
    adsLoader.removeAdErrorListener(componentListener);
    if (configuration.applicationAdErrorListener != null) {
      adsLoader.removeAdErrorListener(configuration.applicationAdErrorListener);
    }
    adsLoader.release();
    imaPausedContent = false;
    imaAdState = IMA_AD_STATE_NONE;
    imaAdMediaInfo = null;
    stopUpdatingAdProgress();
    imaAdInfo = null;
    pendingAdLoadError = null;
    // No more ads will play once the loader is released, so mark all ad groups as skipped.
    for (int i = 0; i < adPlaybackState.adGroupCount; i++) {
      adPlaybackState = adPlaybackState.withSkippedAdGroup(i);
    }
    updateAdPlaybackState();
  }

  /** Notifies the IMA SDK that the specified ad has been prepared for playback. */
  public void handlePrepareComplete(int adGroupIndex, int adIndexInAdGroup) {
    AdInfo adInfo = new AdInfo(adGroupIndex, adIndexInAdGroup);
    if (configuration.debugModeEnabled) {
      Log.d(TAG, ""Prepared ad "" + adInfo);
    }
    @Nullable AdMediaInfo adMediaInfo = adInfoByAdMediaInfo.inverse().get(adInfo);
    if (adMediaInfo != null) {
      for (int i = 0; i < adCallbacks.size(); i++) {
        adCallbacks.get(i).onLoaded(adMediaInfo);
      }
    } else {
      Log.w(TAG, ""Unexpected prepared ad "" + adInfo);
    }
  }

  /** Notifies the IMA SDK that the specified ad has failed to prepare for playback. */
  public void handlePrepareError(int adGroupIndex, int adIndexInAdGroup, IOException exception) {
    if (player == null) {
      return;
    }
    try {
      handleAdPrepareError(adGroupIndex, adIndexInAdGroup, exception);
    } catch (RuntimeException e) {
      maybeNotifyInternalError(""handlePrepareError"", e);
    }
  }

  // Player.Listener implementation.

  @Override
  public void onTimelineChanged(Timeline timeline, @Player.TimelineChangeReason int reason) {
    if (timeline.isEmpty()) {
      // The player is being reset or contains no media.
      return;
    }
    this.timeline = timeline;
    Player player = checkNotNull(this.player);
    long contentDurationUs = timeline.getPeriod(player.getCurrentPeriodIndex(), period).durationUs;
    contentDurationMs = Util.usToMs(contentDurationUs);
    if (contentDurationUs != adPlaybackState.contentDurationUs) {
      adPlaybackState = adPlaybackState.withContentDurationUs(contentDurationUs);
      updateAdPlaybackState();
    }
    long contentPositionMs = getContentPeriodPositionMs(player, timeline, period);
    maybeInitializeAdsManager(contentPositionMs, contentDurationMs);
    handleTimelineOrPositionChanged();
  }

  @Override
  public void onPositionDiscontinuity(
      Player.PositionInfo oldPosition,
      Player.PositionInfo newPosition,
      @Player.DiscontinuityReason int reason) {
    handleTimelineOrPositionChanged();
  }

  @Override
  public void onPlaybackStateChanged(@Player.State int playbackState) {
    @Nullable Player player = this.player;
    if (adsManager == null || player == null) {
      return;
    }

    if (playbackState == Player.STATE_BUFFERING
        && !player.isPlayingAd()
        && isWaitingForFirstAdToPreload()) {
      waitingForPreloadElapsedRealtimeMs = SystemClock.elapsedRealtime();
    } else if (playbackState == Player.STATE_READY) {
      waitingForPreloadElapsedRealtimeMs = C.TIME_UNSET;
    }

    handlePlayerStateChanged(player.getPlayWhenReady(), playbackState);
  }

  @Override
  public void onPlayWhenReadyChanged(
      boolean playWhenReady, @Player.PlayWhenReadyChangeReason int reason) {
    if (adsManager == null || player == null) {
      return;
    }

    if (imaAdState == IMA_AD_STATE_PLAYING && !playWhenReady) {
      adsManager.pause();
      return;
    }

    if (imaAdState == IMA_AD_STATE_PAUSED && playWhenReady) {
      adsManager.resume();
      return;
    }
    handlePlayerStateChanged(playWhenReady, player.getPlaybackState());
  }

  @Override
  public void onPlayerError(PlaybackException error) {
    if (imaAdState != IMA_AD_STATE_NONE) {
      AdMediaInfo adMediaInfo = checkNotNull(imaAdMediaInfo);
      for (int i = 0; i < adCallbacks.size(); i++) {
        adCallbacks.get(i).onError(adMediaInfo);
      }
    }
  }

  // Internal methods.

  private AdsLoader requestAds(
      Context context, ImaSdkSettings imaSdkSettings, AdDisplayContainer adDisplayContainer) {
    AdsLoader adsLoader = imaFactory.createAdsLoader(context, imaSdkSettings, adDisplayContainer);
    adsLoader.addAdErrorListener(componentListener);
    if (configuration.applicationAdErrorListener != null) {
      adsLoader.addAdErrorListener(configuration.applicationAdErrorListener);
    }
    adsLoader.addAdsLoadedListener(componentListener);
    AdsRequest request;
    try {
      request = ImaUtil.getAdsRequestForAdTagDataSpec(imaFactory, adTagDataSpec);
    } catch (IOException e) {
      adPlaybackState = new AdPlaybackState(adsId);
      updateAdPlaybackState();
      pendingAdLoadError = AdLoadException.createForAllAds(e);
      maybeNotifyPendingAdLoadError();
      return adsLoader;
    }
    pendingAdRequestContext = new Object();
    request.setUserRequestContext(pendingAdRequestContext);
    if (configuration.enableContinuousPlayback != null) {
      request.setContinuousPlayback(configuration.enableContinuousPlayback);
    }
    if (configuration.vastLoadTimeoutMs != TIMEOUT_UNSET) {
      request.setVastLoadTimeout(configuration.vastLoadTimeoutMs);
    }
    request.setContentProgressProvider(componentListener);
    adsLoader.requestAds(request);
    return adsLoader;
  }

  private void maybeInitializeAdsManager(long contentPositionMs, long contentDurationMs) {
    @Nullable AdsManager adsManager = this.adsManager;
    if (!isAdsManagerInitialized && adsManager != null) {
      isAdsManagerInitialized = true;
      @Nullable
      AdsRenderingSettings adsRenderingSettings =
          setupAdsRendering(contentPositionMs, contentDurationMs);
      if (adsRenderingSettings == null) {
        // There are no ads to play.
        destroyAdsManager();
      } else {
        adsManager.init(adsRenderingSettings);
        adsManager.start();
        if (configuration.debugModeEnabled) {
          Log.d(TAG, ""Initialized with ads rendering settings: "" + adsRenderingSettings);
        }
      }
      updateAdPlaybackState();
    }
  }

  /**
   * Configures ads rendering for starting playback, returning the settings for the IMA SDK or
   * {@code null} if no ads should play.
   */
  @Nullable
  private AdsRenderingSettings setupAdsRendering(long contentPositionMs, long contentDurationMs) {
    AdsRenderingSettings adsRenderingSettings = imaFactory.createAdsRenderingSettings();
    adsRenderingSettings.setEnablePreloading(true);
    adsRenderingSettings.setMimeTypes(
        configuration.adMediaMimeTypes != null
            ? configuration.adMediaMimeTypes
            : supportedMimeTypes);
    if (configuration.mediaLoadTimeoutMs != TIMEOUT_UNSET) {
      adsRenderingSettings.setLoadVideoTimeout(configuration.mediaLoadTimeoutMs);
    }
    if (configuration.mediaBitrate != BITRATE_UNSET) {
      adsRenderingSettings.setBitrateKbps(configuration.mediaBitrate / 1000);
    }
    adsRenderingSettings.setFocusSkipButtonWhenAvailable(
        configuration.focusSkipButtonWhenAvailable);
    if (configuration.adUiElements != null) {
      adsRenderingSettings.setUiElements(configuration.adUiElements);
    }

    // Skip ads based on the start position as required.
    int adGroupForPositionIndex =
        adPlaybackState.getAdGroupIndexForPositionUs(
            msToUs(contentPositionMs), msToUs(contentDurationMs));
    if (adGroupForPositionIndex != C.INDEX_UNSET) {
      boolean playAdWhenStartingPlayback =
          adPlaybackState.getAdGroup(adGroupForPositionIndex).timeUs == msToUs(contentPositionMs)
              || configuration.playAdBeforeStartPosition;
      if (!playAdWhenStartingPlayback) {
        adGroupForPositionIndex++;
      } else if (hasMidrollAdGroups(adPlaybackState)) {
        // Provide the player's initial position to trigger loading and playing the ad. If there are
        // no midrolls, we are playing a preroll and any pending content position wouldn't be
        // cleared.
        pendingContentPositionMs = contentPositionMs;
      }
      if (adGroupForPositionIndex > 0) {
        for (int i = 0; i < adGroupForPositionIndex; i++) {
          adPlaybackState = adPlaybackState.withSkippedAdGroup(i);
        }
        if (adGroupForPositionIndex == adPlaybackState.adGroupCount) {
          // We don't need to play any ads. Because setPlayAdsAfterTime does not discard non-VMAP
          // ads, we signal that no ads will render so the caller can destroy the ads manager.
          return null;
        }
        long adGroupForPositionTimeUs = adPlaybackState.getAdGroup(adGroupForPositionIndex).timeUs;
        long adGroupBeforePositionTimeUs =
            adPlaybackState.getAdGroup(adGroupForPositionIndex - 1).timeUs;
        if (adGroupForPositionTimeUs == C.TIME_END_OF_SOURCE) {
          // Play the postroll by offsetting the start position just past the last non-postroll ad.
          adsRenderingSettings.setPlayAdsAfterTime(
              (double) adGroupBeforePositionTimeUs / C.MICROS_PER_SECOND + 1d);
        } else {
          // Play ads after the midpoint between the ad to play and the one before it, to avoid
          // issues with rounding one of the two ad times.
          double midpointTimeUs = (adGroupForPositionTimeUs + adGroupBeforePositionTimeUs) / 2d;
          adsRenderingSettings.setPlayAdsAfterTime(midpointTimeUs / C.MICROS_PER_SECOND);
        }
      }
    }
    return adsRenderingSettings;
  }

  private VideoProgressUpdate getContentVideoProgressUpdate() {
    boolean hasContentDuration = contentDurationMs != C.TIME_UNSET;
    long contentPositionMs;
    if (pendingContentPositionMs != C.TIME_UNSET) {
      sentPendingContentPositionMs = true;
      contentPositionMs = pendingContentPositionMs;
    } else if (player == null) {
      return lastContentProgress;
    } else if (fakeContentProgressElapsedRealtimeMs != C.TIME_UNSET) {
      long elapsedSinceEndMs = SystemClock.elapsedRealtime() - fakeContentProgressElapsedRealtimeMs;
      contentPositionMs = fakeContentProgressOffsetMs + elapsedSinceEndMs;
    } else if (imaAdState == IMA_AD_STATE_NONE && !playingAd && hasContentDuration) {
      contentPositionMs = getContentPeriodPositionMs(player, timeline, period);
    } else {
      return VideoProgressUpdate.VIDEO_TIME_NOT_READY;
    }
    long contentDurationMs = hasContentDuration ? this.contentDurationMs : IMA_DURATION_UNSET;
    return new VideoProgressUpdate(contentPositionMs, contentDurationMs);
  }

  private VideoProgressUpdate getAdVideoProgressUpdate() {
    if (player == null) {
      return lastAdProgress;
    } else if (imaAdState != IMA_AD_STATE_NONE && playingAd) {
      long adDuration = player.getDuration();
      return adDuration == C.TIME_UNSET
          ? VideoProgressUpdate.VIDEO_TIME_NOT_READY
          : new VideoProgressUpdate(player.getCurrentPosition(), adDuration);
    } else {
      return VideoProgressUpdate.VIDEO_TIME_NOT_READY;
    }
  }

  private void updateAdProgress() {
    VideoProgressUpdate videoProgressUpdate = getAdVideoProgressUpdate();
    if (configuration.debugModeEnabled) {
      Log.d(TAG, ""Ad progress: "" + ImaUtil.getStringForVideoProgressUpdate(videoProgressUpdate));
    }

    AdMediaInfo adMediaInfo = checkNotNull(imaAdMediaInfo);
    for (int i = 0; i < adCallbacks.size(); i++) {
      adCallbacks.get(i).onAdProgress(adMediaInfo, videoProgressUpdate);
    }
    handler.removeCallbacks(updateAdProgressRunnable);
    handler.postDelayed(updateAdProgressRunnable, AD_PROGRESS_UPDATE_INTERVAL_MS);
  }

  private void stopUpdatingAdProgress() {
    handler.removeCallbacks(updateAdProgressRunnable);
  }

  private int getPlayerVolumePercent() {
    @Nullable Player player = this.player;
    if (player == null) {
      return lastVolumePercent;
    }

    if (player.isCommandAvailable(COMMAND_GET_VOLUME)) {
      return (int) (player.getVolume() * 100);
    }

    // Check for a selected track using an audio renderer.
    return player.getCurrentTracks().isTypeSelected(C.TRACK_TYPE_AUDIO) ? 100 : 0;
  }

  private void handleAdEvent(AdEvent adEvent) {
    if (adsManager == null) {
      // Drop events after release.
      return;
    }
    switch (adEvent.getType()) {
      case AD_BREAK_FETCH_ERROR:
        String  [MASK] String = checkNotNull(adEvent.getAdData().get(""adBreakTime""));
        if (configuration.debugModeEnabled) {
          Log.d(TAG, ""Fetch error for ad at "" +  [MASK] String + "" seconds"");
        }
        double  [MASK]  = Double.parseDouble( [MASK] String);
        int adGroupIndex =
             [MASK]  == -1.0
                ? adPlaybackState.adGroupCount - 1
                : getAdGroupIndexForCuePointTimeSeconds( [MASK] );
        markAdGroupInErrorStateAndClearPendingContentPosition(adGroupIndex);
        break;
      case CONTENT_PAUSE_REQUESTED:
        // After CONTENT_PAUSE_REQUESTED, IMA will playAd/pauseAd/stopAd to show one or more ads
        // before sending CONTENT_RESUME_REQUESTED.
        imaPausedContent = true;
        pauseContentInternal();
        break;
      case TAPPED:
        for (int i = 0; i < eventListeners.size(); i++) {
          eventListeners.get(i).onAdTapped();
        }
        break;
      case CLICKED:
        for (int i = 0; i < eventListeners.size(); i++) {
          eventListeners.get(i).onAdClicked();
        }
        break;
      case CONTENT_RESUME_REQUESTED:
        imaPausedContent = false;
        resumeContentInternal();
        break;
      case LOG:
        Map<String, String> adData = adEvent.getAdData();
        String message = ""AdEvent: "" + adData;
        Log.i(TAG, message);
        break;
      default:
        break;
    }
  }

  private void pauseContentInternal() {
    imaAdState = IMA_AD_STATE_NONE;
    if (sentPendingContentPositionMs) {
      pendingContentPositionMs = C.TIME_UNSET;
      sentPendingContentPositionMs = false;
    }
  }

  private void resumeContentInternal() {
    if (imaAdInfo != null) {
      adPlaybackState = adPlaybackState.withSkippedAdGroup(imaAdInfo.adGroupIndex);
      updateAdPlaybackState();
    }
  }

  /**
   * Returns whether this instance is expecting the first ad in an the upcoming ad group to load
   * within the {@link ImaUtil.Configuration#adPreloadTimeoutMs preload timeout}.
   */
  private boolean isWaitingForFirstAdToPreload() {
    @Nullable Player player = this.player;
    if (player == null) {
      return false;
    }
    int adGroupIndex = getLoadingAdGroupIndex();
    if (adGroupIndex == C.INDEX_UNSET) {
      return false;
    }
    AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(adGroupIndex);
    if (adGroup.count != C.LENGTH_UNSET
        && adGroup.count != 0
        && adGroup.states[0] != AdPlaybackState.AD_STATE_UNAVAILABLE) {
      // An ad is available already.
      return false;
    }
    long adGroupTimeMs = Util.usToMs(adGroup.timeUs);
    long contentPositionMs = getContentPeriodPositionMs(player, timeline, period);
    long timeUntilAdMs = adGroupTimeMs - contentPositionMs;
    return timeUntilAdMs < configuration.adPreloadTimeoutMs;
  }

  private boolean isWaitingForCurrentAdToLoad() {
    @Nullable Player player = this.player;
    if (player == null) {
      return false;
    }
    int adGroupIndex = player.getCurrentAdGroupIndex();
    if (adGroupIndex == C.INDEX_UNSET) {
      return false;
    }
    AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(adGroupIndex);
    int adIndexInAdGroup = player.getCurrentAdIndexInAdGroup();
    if (adGroup.count == C.LENGTH_UNSET || adGroup.count <= adIndexInAdGroup) {
      return true;
    }
    return adGroup.states[adIndexInAdGroup] == AdPlaybackState.AD_STATE_UNAVAILABLE;
  }

  private void handlePlayerStateChanged(boolean playWhenReady, @Player.State int playbackState) {
    if (playingAd && imaAdState == IMA_AD_STATE_PLAYING) {
      if (!bufferingAd && playbackState == Player.STATE_BUFFERING) {
        bufferingAd = true;
        AdMediaInfo adMediaInfo = checkNotNull(imaAdMediaInfo);
        for (int i = 0; i < adCallbacks.size(); i++) {
          adCallbacks.get(i).onBuffering(adMediaInfo);
        }
        stopUpdatingAdProgress();
      } else if (bufferingAd && playbackState == Player.STATE_READY) {
        bufferingAd = false;
        updateAdProgress();
      }
    }

    if (imaAdState == IMA_AD_STATE_NONE
        && playbackState == Player.STATE_BUFFERING
        && playWhenReady) {
      ensureSentContentCompleteIfAtEndOfStream();
    } else if (imaAdState != IMA_AD_STATE_NONE && playbackState == Player.STATE_ENDED) {
      @Nullable AdMediaInfo adMediaInfo = imaAdMediaInfo;
      if (adMediaInfo == null) {
        Log.w(TAG, ""onEnded without ad media info"");
      } else {
        for (int i = 0; i < adCallbacks.size(); i++) {
          adCallbacks.get(i).onEnded(adMediaInfo);
        }
      }
      if (configuration.debugModeEnabled) {
        Log.d(TAG, ""VideoAdPlayerCallback.onEnded in onPlaybackStateChanged"");
      }
    }
  }

  private void handleTimelineOrPositionChanged() {
    @Nullable Player player = this.player;
    if (adsManager == null || player == null) {
      return;
    }
    if (!playingAd && !player.isPlayingAd()) {
      ensureSentContentCompleteIfAtEndOfStream();
      if (!sentContentComplete && !timeline.isEmpty()) {
        long positionMs = getContentPeriodPositionMs(player, timeline, period);
        timeline.getPeriod(player.getCurrentPeriodIndex(), period);
        int newAdGroupIndex = period.getAdGroupIndexForPositionUs(msToUs(positionMs));
        if (newAdGroupIndex != C.INDEX_UNSET) {
          sentPendingContentPositionMs = false;
          pendingContentPositionMs = positionMs;
        }
      }
    }

    boolean wasPlayingAd = playingAd;
    int oldPlayingAdIndexInAdGroup = playingAdIndexInAdGroup;
    playingAd = player.isPlayingAd();
    playingAdIndexInAdGroup = playingAd ? player.getCurrentAdIndexInAdGroup() : C.INDEX_UNSET;
    boolean adFinished = wasPlayingAd && playingAdIndexInAdGroup != oldPlayingAdIndexInAdGroup;
    if (adFinished) {
      // IMA is waiting for the ad playback to finish so invoke the callback now.
      // Either CONTENT_RESUME_REQUESTED will be passed next, or playAd will be called again.
      @Nullable AdMediaInfo adMediaInfo = imaAdMediaInfo;
      if (adMediaInfo == null) {
        Log.w(TAG, ""onEnded without ad media info"");
      } else {
        @Nullable AdInfo adInfo = adInfoByAdMediaInfo.get(adMediaInfo);
        if (playingAdIndexInAdGroup == C.INDEX_UNSET
            || (adInfo != null && adInfo.adIndexInAdGroup < playingAdIndexInAdGroup)) {
          for (int i = 0; i < adCallbacks.size(); i++) {
            adCallbacks.get(i).onEnded(adMediaInfo);
          }
          if (configuration.debugModeEnabled) {
            Log.d(
                TAG, ""VideoAdPlayerCallback.onEnded in onTimelineChanged/onPositionDiscontinuity"");
          }
        }
      }
    }
    if (!sentContentComplete && !wasPlayingAd && playingAd && imaAdState == IMA_AD_STATE_NONE) {
      AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(player.getCurrentAdGroupIndex());
      if (adGroup.timeUs == C.TIME_END_OF_SOURCE) {
        sendContentComplete();
      } else {
        // IMA hasn't called playAd yet, so fake the content position.
        fakeContentProgressElapsedRealtimeMs = SystemClock.elapsedRealtime();
        fakeContentProgressOffsetMs = Util.usToMs(adGroup.timeUs);
        if (fakeContentProgressOffsetMs == C.TIME_END_OF_SOURCE) {
          fakeContentProgressOffsetMs = contentDurationMs;
        }
      }
    }
    if (isWaitingForCurrentAdToLoad()) {
      handler.removeCallbacks(adLoadTimeoutRunnable);
      handler.postDelayed(adLoadTimeoutRunnable, configuration.adPreloadTimeoutMs);
    }
  }

  private void loadAdInternal(AdMediaInfo adMediaInfo, AdPodInfo adPodInfo) {
    if (adsManager == null) {
      // Drop events after release.
      if (configuration.debugModeEnabled) {
        Log.d(
            TAG,
            ""loadAd after release "" + getAdMediaInfoString(adMediaInfo) + "", ad pod "" + adPodInfo);
      }
      return;
    }

    int adGroupIndex = getAdGroupIndexForAdPod(adPodInfo);
    int adIndexInAdGroup = adPodInfo.getAdPosition() - 1;
    AdInfo adInfo = new AdInfo(adGroupIndex, adIndexInAdGroup);
    // The ad URI may already be known, so force put to update it if needed.
    adInfoByAdMediaInfo.forcePut(adMediaInfo, adInfo);
    if (configuration.debugModeEnabled) {
      Log.d(TAG, ""loadAd "" + getAdMediaInfoString(adMediaInfo));
    }
    if (adPlaybackState.isAdInErrorState(adGroupIndex, adIndexInAdGroup)) {
      // We have already marked this ad as having failed to load, so ignore the request. IMA will
      // timeout after its media load timeout.
      return;
    }
    if (player != null
        && player.getCurrentAdGroupIndex() == adGroupIndex
        && player.getCurrentAdIndexInAdGroup() == adIndexInAdGroup) {
      // Loaded ad info the player is currently waiting for.
      handler.removeCallbacks(adLoadTimeoutRunnable);
    }

    // The ad count may increase on successive loads of ads in the same ad pod, for example, due to
    // separate requests for ad tags with multiple ads within the ad pod completing after an earlier
    // ad has loaded. See also https://github.com/google/ExoPlayer/issues/7477.
    AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(adInfo.adGroupIndex);
    adPlaybackState =
        adPlaybackState.withAdCount(
            adInfo.adGroupIndex, max(adPodInfo.getTotalAds(), adGroup.states.length));
    adGroup = adPlaybackState.getAdGroup(adInfo.adGroupIndex);
    for (int i = 0; i < adIndexInAdGroup; i++) {
      // Any preceding ads that haven't loaded are not going to load.
      if (adGroup.states[i] == AdPlaybackState.AD_STATE_UNAVAILABLE) {
        adPlaybackState = adPlaybackState.withAdLoadError(adGroupIndex, /* adIndexInAdGroup= */ i);
      }
    }

    Uri adUri = Uri.parse(adMediaInfo.getUrl());
    adPlaybackState =
        adPlaybackState.withAvailableAdUri(adInfo.adGroupIndex, adInfo.adIndexInAdGroup, adUri);
    updateAdPlaybackState();
  }

  private void playAdInternal(AdMediaInfo adMediaInfo) {
    if (configuration.debugModeEnabled) {
      Log.d(TAG, ""playAd "" + getAdMediaInfoString(adMediaInfo));
    }
    if (adsManager == null) {
      // Drop events after release.
      return;
    }

    if (imaAdState == IMA_AD_STATE_PLAYING) {
      // IMA does not always call stopAd before resuming content.
      // See [Internal: b/38354028].
      Log.w(TAG, ""Unexpected playAd without stopAd"");
    }

    if (imaAdState == IMA_AD_STATE_NONE) {
      // IMA is requesting to play the ad, so stop faking the content position.
      fakeContentProgressElapsedRealtimeMs = C.TIME_UNSET;
      fakeContentProgressOffsetMs = C.TIME_UNSET;
      imaAdState = IMA_AD_STATE_PLAYING;
      imaAdMediaInfo = adMediaInfo;
      imaAdInfo = checkNotNull(adInfoByAdMediaInfo.get(adMediaInfo));
      for (int i = 0; i < adCallbacks.size(); i++) {
        adCallbacks.get(i).onPlay(adMediaInfo);
      }
      if (pendingAdPrepareErrorAdInfo != null && pendingAdPrepareErrorAdInfo.equals(imaAdInfo)) {
        pendingAdPrepareErrorAdInfo = null;
        for (int i = 0; i < adCallbacks.size(); i++) {
          adCallbacks.get(i).onError(adMediaInfo);
        }
      }
      updateAdProgress();
    } else {
      imaAdState = IMA_AD_STATE_PLAYING;
      checkState(adMediaInfo.equals(imaAdMediaInfo));
      for (int i = 0; i < adCallbacks.size(); i++) {
        adCallbacks.get(i).onResume(adMediaInfo);
      }
    }
    if (player == null || !player.getPlayWhenReady()) {
      // Either this loader hasn't been activated yet, or the player is paused now.
      checkNotNull(adsManager).pause();
    }
  }

  private void pauseAdInternal(AdMediaInfo adMediaInfo) {
    if (configuration.debugModeEnabled) {
      Log.d(TAG, ""pauseAd "" + getAdMediaInfoString(adMediaInfo));
    }
    if (adsManager == null) {
      // Drop event after release.
      return;
    }
    if (imaAdState == IMA_AD_STATE_NONE) {
      // This method is called if loadAd has been called but the loaded ad won't play due to a seek
      // to a different position, so drop the event. See also [Internal: b/159111848].
      return;
    }
    if (configuration.debugModeEnabled && !adMediaInfo.equals(imaAdMediaInfo)) {
      Log.w(
          TAG,
          ""Unexpected pauseAd for ""
              + getAdMediaInfoString(adMediaInfo)
              + "", expected ""
              + getAdMediaInfoString(imaAdMediaInfo));
    }
    imaAdState = IMA_AD_STATE_PAUSED;
    for (int i = 0; i < adCallbacks.size(); i++) {
      adCallbacks.get(i).onPause(adMediaInfo);
    }
  }

  private void stopAdInternal(AdMediaInfo adMediaInfo) {
    if (configuration.debugModeEnabled) {
      Log.d(TAG, ""stopAd "" + getAdMediaInfoString(adMediaInfo));
    }
    if (adsManager == null) {
      // Drop event after release.
      return;
    }
    if (imaAdState == IMA_AD_STATE_NONE) {
      // This method is called if loadAd has been called but the preloaded ad won't play due to a
      // seek to a different position, so drop the event and discard the ad. See also [Internal:
      // b/159111848].
      @Nullable AdInfo adInfo = adInfoByAdMediaInfo.get(adMediaInfo);
      if (adInfo != null) {
        adPlaybackState =
            adPlaybackState.withSkippedAd(adInfo.adGroupIndex, adInfo.adIndexInAdGroup);
        updateAdPlaybackState();
      }
      return;
    }
    imaAdState = IMA_AD_STATE_NONE;
    stopUpdatingAdProgress();
    // TODO: Handle the skipped event so the ad can be marked as skipped rather than played.
    checkNotNull(imaAdInfo);
    int adGroupIndex = imaAdInfo.adGroupIndex;
    int adIndexInAdGroup = imaAdInfo.adIndexInAdGroup;
    if (adPlaybackState.isAdInErrorState(adGroupIndex, adIndexInAdGroup)) {
      // We have already marked this ad as having failed to load, so ignore the request.
      return;
    }
    adPlaybackState =
        adPlaybackState.withPlayedAd(adGroupIndex, adIndexInAdGroup).withAdResumePositionUs(0);
    updateAdPlaybackState();
    if (!playingAd) {
      imaAdMediaInfo = null;
      imaAdInfo = null;
    }
  }

  private void handleAdGroupLoadError(Exception error) {
    int adGroupIndex = getLoadingAdGroupIndex();
    if (adGroupIndex == C.INDEX_UNSET) {
      Log.w(TAG, ""Unable to determine ad group index for ad group load error"", error);
      return;
    }
    markAdGroupInErrorStateAndClearPendingContentPosition(adGroupIndex);
    if (pendingAdLoadError == null) {
      pendingAdLoadError = AdLoadException.createForAdGroup(error, adGroupIndex);
    }
  }

  private void handleAdLoadTimeout() {
    // IMA got stuck and didn't load an ad in time, so skip the entire group.
    handleAdGroupLoadError(new IOException(""Ad loading timed out""));
    maybeNotifyPendingAdLoadError();
  }

  private void markAdGroupInErrorStateAndClearPendingContentPosition(int adGroupIndex) {
    // Update the ad playback state so all ads in the ad group are in the error state.
    AdPlaybackState.AdGroup adGroup = adPlaybackState.getAdGroup(adGroupIndex);
    if (adGroup.count == C.LENGTH_UNSET) {
      adPlaybackState = adPlaybackState.withAdCount(adGroupIndex, max(1, adGroup.states.length));
      adGroup = adPlaybackState.getAdGroup(adGroupIndex);
    }
    for (int i = 0; i < adGroup.count; i++) {
      if (adGroup.states[i] == AdPlaybackState.AD_STATE_UNAVAILABLE) {
        if (configuration.debugModeEnabled) {
          Log.d(TAG, ""Removing ad "" + i + "" in ad group "" + adGroupIndex);
        }
        adPlaybackState = adPlaybackState.withAdLoadError(adGroupIndex, i);
      }
    }
    updateAdPlaybackState();
    // Clear any pending content position that triggered attempting to load the ad group.
    pendingContentPositionMs = C.TIME_UNSET;
    fakeContentProgressElapsedRealtimeMs = C.TIME_UNSET;
  }

  private void handleAdPrepareError(int adGroupIndex, int adIndexInAdGroup, Exception exception) {
    if (configuration.debugModeEnabled) {
      Log.d(
          TAG, ""Prepare error for ad "" + adIndexInAdGroup + "" in group "" + adGroupIndex, exception);
    }
    if (adsManager == null) {
      Log.w(TAG, ""Ignoring ad prepare error after release"");
      return;
    }
    if (imaAdState == IMA_AD_STATE_NONE) {
      // Send IMA a content position at the ad group so that it will try to play it, at which point
      // we can notify that it failed to load.
      fakeContentProgressElapsedRealtimeMs = SystemClock.elapsedRealtime();
      fakeContentProgressOffsetMs = Util.usToMs(adPlaybackState.getAdGroup(adGroupIndex).timeUs);
      if (fakeContentProgressOffsetMs == C.TIME_END_OF_SOURCE) {
        fakeContentProgressOffsetMs = contentDurationMs;
      }
      pendingAdPrepareErrorAdInfo = new AdInfo(adGroupIndex, adIndexInAdGroup);
    } else {
      AdMediaInfo adMediaInfo = checkNotNull(imaAdMediaInfo);
      // We're already playing an ad.
      if (adIndexInAdGroup > playingAdIndexInAdGroup) {
        // Mark the playing ad as ended so we can notify the error on the next ad and remove it,
        // which means that the ad after will load (if any).
        for (int i = 0; i < adCallbacks.size(); i++) {
          adCallbacks.get(i).onEnded(adMediaInfo);
        }
      }
      playingAdIndexInAdGroup = adPlaybackState.getAdGroup(adGroupIndex).getFirstAdIndexToPlay();
      for (int i = 0; i < adCallbacks.size(); i++) {
        adCallbacks.get(i).onError(checkNotNull(adMediaInfo));
      }
    }
    adPlaybackState = adPlaybackState.withAdLoadError(adGroupIndex, adIndexInAdGroup);
    updateAdPlaybackState();
  }

  private void ensureSentContentCompleteIfAtEndOfStream() {
    if (sentContentComplete
        || contentDurationMs == C.TIME_UNSET
        || pendingContentPositionMs != C.TIME_UNSET) {
      return;
    }
    long contentPeriodPositionMs =
        getContentPeriodPositionMs(checkNotNull(player), timeline, period);
    if (contentPeriodPositionMs + THRESHOLD_END_OF_CONTENT_MS < contentDurationMs) {
      return;
    }
    int pendingAdGroupIndex =
        adPlaybackState.getAdGroupIndexForPositionUs(
            msToUs(contentPeriodPositionMs), msToUs(contentDurationMs));
    if (pendingAdGroupIndex != C.INDEX_UNSET
        && adPlaybackState.getAdGroup(pendingAdGroupIndex).timeUs != C.TIME_END_OF_SOURCE
        && adPlaybackState.getAdGroup(pendingAdGroupIndex).shouldPlayAdGroup()) {
      // Pending mid-roll ad that needs to be played before marking the content complete.
      return;
    }
    sendContentComplete();
  }

  private void sendContentComplete() {
    for (int i = 0; i < adCallbacks.size(); i++) {
      adCallbacks.get(i).onContentComplete();
    }
    sentContentComplete = true;
    if (configuration.debugModeEnabled) {
      Log.d(TAG, ""adsLoader.contentComplete"");
    }
    for (int i = 0; i < adPlaybackState.adGroupCount; i++) {
      if (adPlaybackState.getAdGroup(i).timeUs != C.TIME_END_OF_SOURCE) {
        adPlaybackState = adPlaybackState.withSkippedAdGroup(/* adGroupIndex= */ i);
      }
    }
    updateAdPlaybackState();
  }

  private void updateAdPlaybackState() {
    for (int i = 0; i < eventListeners.size(); i++) {
      eventListeners.get(i).onAdPlaybackState(adPlaybackState);
    }
  }

  private void maybeNotifyPendingAdLoadError() {
    if (pendingAdLoadError != null) {
      for (int i = 0; i < eventListeners.size(); i++) {
        eventListeners.get(i).onAdLoadError(pendingAdLoadError, adTagDataSpec);
      }
      pendingAdLoadError = null;
    }
  }

  private void maybeNotifyInternalError(String name, Exception cause) {
    String message = ""Internal error in "" + name;
    Log.e(TAG, message, cause);
    // We can't recover from an unexpected error in general, so skip all remaining ads.
    for (int i = 0; i < adPlaybackState.adGroupCount; i++) {
      adPlaybackState = adPlaybackState.withSkippedAdGroup(i);
    }
    updateAdPlaybackState();
    for (int i = 0; i < eventListeners.size(); i++) {
      eventListeners
          .get(i)
          .onAdLoadError(
              AdLoadException.createForUnexpected(new RuntimeException(message, cause)),
              adTagDataSpec);
    }
  }

  private int getAdGroupIndexForAdPod(AdPodInfo adPodInfo) {
    if (adPodInfo.getPodIndex() == -1) {
      // This is a postroll ad.
      return adPlaybackState.adGroupCount - 1;
    }

    // adPodInfo.podIndex may be 0-based or 1-based, so for now look up the cue point instead.
    return getAdGroupIndexForCuePointTimeSeconds(adPodInfo.getTimeOffset());
  }

  /**
   * Returns the index of the ad group that will preload next, or {@link C#INDEX_UNSET} if there is
   * no such ad group.
   */
  private int getLoadingAdGroupIndex() {
    if (player == null) {
      return C.INDEX_UNSET;
    }
    long playerPositionUs = msToUs(getContentPeriodPositionMs(player, timeline, period));
    int adGroupIndex =
        adPlaybackState.getAdGroupIndexForPositionUs(playerPositionUs, msToUs(contentDurationMs));
    if (adGroupIndex == C.INDEX_UNSET) {
      adGroupIndex =
          adPlaybackState.getAdGroupIndexAfterPositionUs(
              playerPositionUs, msToUs(contentDurationMs));
    }
    return adGroupIndex;
  }

  private int getAdGroupIndexForCuePointTimeSeconds(double cuePointTimeSeconds) {
    // We receive initial cue points from IMA SDK as floats. This code replicates the same
    // calculation used to populate adGroupTimesUs (having truncated input back to float, to avoid
    // failures if the behavior of the IMA SDK changes to provide greater precision).
    float cuePointTimeSecondsFloat = (float) cuePointTimeSeconds;
    long adPodTimeUs = Math.round((double) cuePointTimeSecondsFloat * C.MICROS_PER_SECOND);
    for (int adGroupIndex = 0; adGroupIndex < adPlaybackState.adGroupCount; adGroupIndex++) {
      long adGroupTimeUs = adPlaybackState.getAdGroup(adGroupIndex).timeUs;
      if (adGroupTimeUs != C.TIME_END_OF_SOURCE
          && Math.abs(adGroupTimeUs - adPodTimeUs) < THRESHOLD_AD_MATCH_US) {
        return adGroupIndex;
      }
    }
    throw new IllegalStateException(""Failed to find cue point"");
  }

  private String getAdMediaInfoString(@Nullable AdMediaInfo adMediaInfo) {
    @Nullable AdInfo adInfo = adInfoByAdMediaInfo.get(adMediaInfo);
    return ""AdMediaInfo[""
        + (adMediaInfo == null ? ""null"" : adMediaInfo.getUrl())
        + "", ""
        + adInfo
        + ""]"";
  }

  private static long getContentPeriodPositionMs(
      Player player, Timeline timeline, Timeline.Period period) {
    long contentWindowPositionMs = player.getContentPosition();
    if (timeline.isEmpty()) {
      return contentWindowPositionMs;
    } else {
      return contentWindowPositionMs
          - timeline.getPeriod(player.getCurrentPeriodIndex(), period).getPositionInWindowMs();
    }
  }

  private static boolean hasMidrollAdGroups(AdPlaybackState adPlaybackState) {
    int count = adPlaybackState.adGroupCount;
    if (count == 1) {
      long adGroupTimeUs = adPlaybackState.getAdGroup(0).timeUs;
      return adGroupTimeUs != 0 && adGroupTimeUs != C.TIME_END_OF_SOURCE;
    } else if (count == 2) {
      return adPlaybackState.getAdGroup(0).timeUs != 0
          || adPlaybackState.getAdGroup(1).timeUs != C.TIME_END_OF_SOURCE;
    } else {
      // There's at least one midroll ad group, as adPlaybackState is never empty.
      return true;
    }
  }

  private void destroyAdsManager() {
    if (adsManager != null) {
      adsManager.removeAdErrorListener(componentListener);
      if (configuration.applicationAdErrorListener != null) {
        adsManager.removeAdErrorListener(configuration.applicationAdErrorListener);
      }
      adsManager.removeAdEventListener(componentListener);
      if (configuration.applicationAdEventListener != null) {
        adsManager.removeAdEventListener(configuration.applicationAdEventListener);
      }
      adsManager.destroy();
      adsManager = null;
    }
  }

  private final class ComponentListener
      implements AdsLoadedListener,
          ContentProgressProvider,
          AdEventListener,
          AdErrorListener,
          VideoAdPlayer {

    // AdsLoader.AdsLoadedListener implementation.

    @Override
    public void onAdsManagerLoaded(AdsManagerLoadedEvent adsManagerLoadedEvent) {
      AdsManager adsManager = adsManagerLoadedEvent.getAdsManager();
      if (!Util.areEqual(pendingAdRequestContext, adsManagerLoadedEvent.getUserRequestContext())) {
        adsManager.destroy();
        return;
      }
      pendingAdRequestContext = null;
      AdTagLoader.this.adsManager = adsManager;
      adsManager.addAdErrorListener(this);
      if (configuration.applicationAdErrorListener != null) {
        adsManager.addAdErrorListener(configuration.applicationAdErrorListener);
      }
      adsManager.addAdEventListener(this);
      if (configuration.applicationAdEventListener != null) {
        adsManager.addAdEventListener(configuration.applicationAdEventListener);
      }
      try {
        adPlaybackState =
            new AdPlaybackState(adsId, getAdGroupTimesUsForCuePoints(adsManager.getAdCuePoints()));
        updateAdPlaybackState();
      } catch (RuntimeException e) {
        maybeNotifyInternalError(""onAdsManagerLoaded"", e);
      }
    }

    // ContentProgressProvider implementation.

    @Override
    public VideoProgressUpdate getContentProgress() {
      VideoProgressUpdate videoProgressUpdate = getContentVideoProgressUpdate();
      if (configuration.debugModeEnabled) {
        Log.d(
            TAG,
            ""Content progress: "" + ImaUtil.getStringForVideoProgressUpdate(videoProgressUpdate));
      }

      if (waitingForPreloadElapsedRealtimeMs != C.TIME_UNSET) {
        // IMA is polling the player position but we are buffering for an ad to preload, so playback
        // may be stuck. Detect this case and signal an error if applicable.
        long stuckElapsedRealtimeMs =
            SystemClock.elapsedRealtime() - waitingForPreloadElapsedRealtimeMs;
        if (stuckElapsedRealtimeMs >= THRESHOLD_AD_PRELOAD_MS) {
          waitingForPreloadElapsedRealtimeMs = C.TIME_UNSET;
          handleAdGroupLoadError(new IOException(""Ad preloading timed out""));
          maybeNotifyPendingAdLoadError();
        }
      } else if (pendingContentPositionMs != C.TIME_UNSET
          && player != null
          && player.getPlaybackState() == Player.STATE_BUFFERING
          && isWaitingForFirstAdToPreload()) {
        // Prepare to timeout the load of an ad for the pending seek operation.
        waitingForPreloadElapsedRealtimeMs = SystemClock.elapsedRealtime();
      }

      return videoProgressUpdate;
    }

    // AdEvent.AdEventListener implementation.

    @Override
    public void onAdEvent(AdEvent adEvent) {
      AdEventType adEventType = adEvent.getType();
      if (configuration.debugModeEnabled && adEventType != AdEventType.AD_PROGRESS) {
        Log.d(TAG, ""onAdEvent: "" + adEventType);
      }
      try {
        handleAdEvent(adEvent);
      } catch (RuntimeException e) {
        maybeNotifyInternalError(""onAdEvent"", e);
      }
    }

    // AdErrorEvent.AdErrorListener implementation.

    @Override
    public void onAdError(AdErrorEvent adErrorEvent) {
      AdError error = adErrorEvent.getError();
      if (configuration.debugModeEnabled) {
        Log.d(TAG, ""onAdError"", error);
      }
      if (adsManager == null) {
        // No ads were loaded, so allow playback to start without any ads.
        pendingAdRequestContext = null;
        adPlaybackState = new AdPlaybackState(adsId);
        updateAdPlaybackState();
      } else if (ImaUtil.isAdGroupLoadError(error)) {
        try {
          handleAdGroupLoadError(error);
        } catch (RuntimeException e) {
          maybeNotifyInternalError(""onAdError"", e);
        }
      }
      if (pendingAdLoadError == null) {
        pendingAdLoadError = AdLoadException.createForAllAds(error);
      }
      maybeNotifyPendingAdLoadError();
    }

    // VideoAdPlayer implementation.

    @Override
    public void addCallback(VideoAdPlayerCallback videoAdPlayerCallback) {
      adCallbacks.add(videoAdPlayerCallback);
    }

    @Override
    public void removeCallback(VideoAdPlayerCallback videoAdPlayerCallback) {
      adCallbacks.remove(videoAdPlayerCallback);
    }

    @Override
    public VideoProgressUpdate getAdProgress() {
      throw new IllegalStateException(""Unexpected call to getAdProgress when using preloading"");
    }

    @Override
    public int getVolume() {
      return getPlayerVolumePercent();
    }

    @Override
    public void loadAd(AdMediaInfo adMediaInfo, AdPodInfo adPodInfo) {
      try {
        loadAdInternal(adMediaInfo, adPodInfo);
      } catch (RuntimeException e) {
        maybeNotifyInternalError(""loadAd"", e);
      }
    }

    @Override
    public void playAd(AdMediaInfo adMediaInfo) {
      try {
        playAdInternal(adMediaInfo);
      } catch (RuntimeException e) {
        maybeNotifyInternalError(""playAd"", e);
      }
    }

    @Override
    public void pauseAd(AdMediaInfo adMediaInfo) {
      try {
        pauseAdInternal(adMediaInfo);
      } catch (RuntimeException e) {
        maybeNotifyInternalError(""pauseAd"", e);
      }
    }

    @Override
    public void stopAd(AdMediaInfo adMediaInfo) {
      try {
        stopAdInternal(adMediaInfo);
      } catch (RuntimeException e) {
        maybeNotifyInternalError(""stopAd"", e);
      }
    }

    @Override
    public void release() {
      // Do nothing.
    }
  }

  // TODO: Consider moving this into AdPlaybackState.
  private static final class AdInfo {

    public final int adGroupIndex;
    public final int adIndexInAdGroup;

    public AdInfo(int adGroupIndex, int adIndexInAdGroup) {
      this.adGroupIndex = adGroupIndex;
      this.adIndexInAdGroup = adIndexInAdGroup;
    }

    @Override
    public boolean equals(@Nullable Object o) {
      if (this == o) {
        return true;
      }
      if (o == null || getClass() != o.getClass()) {
        return false;
      }
      AdInfo adInfo = (AdInfo) o;
      if (adGroupIndex != adInfo.adGroupIndex) {
        return false;
      }
      return adIndexInAdGroup == adInfo.adIndexInAdGroup;
    }

    @Override
    public int hashCode() {
      int result = adGroupIndex;
      result = 31 * result + adIndexInAdGroup;
      return result;
    }

    @Override
    public String toString() {
      return ""("" + adGroupIndex + "", "" + adIndexInAdGroup + ')';
    }
  }
}
","adGroupTimeSeconds
"
"/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.audio;

import static java.lang.annotation.ElementType.TYPE_USE;

import android.media.AudioDeviceInfo;
import android.media.AudioTrack;
import androidx.annotation.IntDef;
import androidx.annotation.Nullable;
import androidx.annotation.RequiresApi;
import com.google.android.exoplayer2.C;
import com.google.android.exoplayer2.ExoPlaybackException;
import com.google.android.exoplayer2.Format;
import com.google.android.exoplayer2.PlaybackException;
import com.google.android.exoplayer2.PlaybackParameters;
import com.google.android.exoplayer2.Player;
import com.google.android.exoplayer2.analytics.PlayerId;
import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.nio.ByteBuffer;

/**
 * A sink that consumes audio data.
 *
 * <p>Before starting playback, specify the input audio format by calling {@link #configure(Format,
 * int, int[])}.
 *
 * <p>Call {@link #handleBuffer(ByteBuffer, long, int)} to write data, and {@link
 * #handleDiscontinuity()} when the data being fed is discontinuous. Call {@link #play()} to start
 * playing the written data.
 *
 * <p>Call {@link #configure(Format, int, int[])} whenever the input format changes. The sink will
 * be reinitialized on the next call to {@link #handleBuffer(ByteBuffer, long, int)}.
 *
 * <p>Call {@link #flush()} to prepare the sink to receive audio data from a new playback position.
 *
 * <p>Call {@link #playToEndOfStream()} repeatedly to play out all data when no more input buffers
 * will be provided via {@link #handleBuffer(ByteBuffer, long, int)} until the next {@link
 * #flush()}. Call {@link #reset()} when the instance is no longer required.
 *
 * <p>The implementation may be backed by a platform {@link AudioTrack}. In this case, {@link
 * #setAudioSessionId(int)}, {@link #setAudioAttributes(AudioAttributes)}, {@link
 * #enableTunnelingV21()} and {@link #disableTunneling()} may be called before writing data to the
 * sink. These methods may also be called after writing data to the sink, in which case it will be
 * reinitialized as required. For implementations that are not based on platform {@link
 * AudioTrack}s, calling methods relating to audio sessions, audio attributes, and tunneling may
 * have no effect.
 *
 * @deprecated com.google.android.exoplayer2 is deprecated. Please migrate to androidx.media3 (which
 *     contains the same ExoPlayer code). See <a
 *     href=""https://developer.android.com/guide/topics/media/media3/getting-started/migration-guide"">the
 *     migration guide</a> for more details, including a script to help with the migration.
 */
@Deprecated
public interface AudioSink {

  /** Listener for audio sink events. */
  interface Listener {

    /**
     * Called when the audio sink handles a buffer whose timestamp is discontinuous with the last
     * buffer handled since it was reset.
     */
    void onPositionDiscontinuity();

    /**
     * Called when the audio sink's position has increased for the first time since it was last
     * paused or flushed.
     *
     * @param playoutStartSystemTimeMs The approximate derived {@link System#currentTimeMillis()} at
     *     which playout started. Only valid if the audio track has not underrun.
     */
    default void onPositionAdvancing(long playoutStartSystemTimeMs) {}

    /**
     * Called when the audio sink runs out of data.
     *
     * <p>An audio sink implementation may never call this method (for example, if audio data is
     * consumed in batches rather than based on the sink's own clock).
     *
     * @param bufferSize The size of the sink's buffer, in bytes.
     * @param bufferSizeMs The size of the sink's buffer, in milliseconds, if it is configured for
     *     PCM output. {@link C#TIME_UNSET} if it is configured for encoded audio output, as the
     *     buffered media can have a variable bitrate so the duration may be unknown.
     * @param elapsedSinceLastFeedMs The time since the sink was last fed data, in milliseconds.
     */
    void onUnderrun(int bufferSize, long bufferSizeMs, long elapsedSinceLastFeedMs);

    /**
     * Called when skipping silences is enabled or disabled.
     *
     * @param  [MASK]  Whether skipping silences is enabled.
     */
    void onSkipSilenceEnabledChanged(boolean  [MASK] );

    /** Called when the offload buffer has been partially emptied. */
    default void onOffloadBufferEmptying() {}

    /** Called when the offload buffer has been filled completely. */
    default void onOffloadBufferFull() {}

    /**
     * Called when {@link AudioSink} has encountered an error.
     *
     * <p>If the sink writes to a platform {@link AudioTrack}, this will called for all {@link
     * AudioTrack} errors.
     *
     * <p>This method being called does not indicate that playback has failed, or that it will fail.
     * The player may be able to recover from the error (for example by recreating the AudioTrack,
     * possibly with different settings) and continue. Hence applications should <em>not</em>
     * implement this method to display a user visible error or initiate an application level retry
     * ({@link Player.Listener#onPlayerError} is the appropriate place to implement such behavior).
     * This method is called to provide the application with an opportunity to log the error if it
     * wishes to do so.
     *
     * <p>Fatal errors that cannot be recovered will be reported wrapped in a {@link
     * ExoPlaybackException} by {@link Player.Listener#onPlayerError(PlaybackException)}.
     *
     * @param audioSinkError The error that occurred. Typically an {@link InitializationException},
     *     a {@link WriteException}, or an {@link UnexpectedDiscontinuityException}.
     */
    default void onAudioSinkError(Exception audioSinkError) {}

    /** Called when audio capabilities changed. */
    default void onAudioCapabilitiesChanged() {}
  }

  /** Thrown when a failure occurs configuring the sink. */
  final class ConfigurationException extends Exception {

    /** Input {@link Format} of the sink when the configuration failure occurs. */
    public final Format format;

    /** Creates a new configuration exception with the specified {@code cause} and no message. */
    public ConfigurationException(Throwable cause, Format format) {
      super(cause);
      this.format = format;
    }

    /** Creates a new configuration exception with the specified {@code message} and no cause. */
    public ConfigurationException(String message, Format format) {
      super(message);
      this.format = format;
    }
  }

  /** Thrown when a failure occurs initializing the sink. */
  final class InitializationException extends Exception {

    /** The underlying {@link AudioTrack}'s state. */
    public final int audioTrackState;
    /** If the exception can be recovered by recreating the sink. */
    public final boolean isRecoverable;
    /** The input {@link Format} of the sink when the error occurs. */
    public final Format format;

    /**
     * Creates a new instance.
     *
     * @param audioTrackState The underlying {@link AudioTrack}'s state.
     * @param sampleRate The requested sample rate in Hz.
     * @param channelConfig The requested channel configuration.
     * @param bufferSize The requested buffer size in bytes.
     * @param format The input format of the sink when the error occurs.
     * @param isRecoverable Whether the exception can be recovered by recreating the sink.
     * @param audioTrackException Exception thrown during the creation of the {@link AudioTrack}.
     */
    public InitializationException(
        int audioTrackState,
        int sampleRate,
        int channelConfig,
        int bufferSize,
        Format format,
        boolean isRecoverable,
        @Nullable Exception audioTrackException) {
      super(
          ""AudioTrack init failed ""
              + audioTrackState
              + "" ""
              + (""Config("" + sampleRate + "", "" + channelConfig + "", "" + bufferSize + "")"")
              + "" ""
              + format
              + (isRecoverable ? "" (recoverable)"" : """"),
          audioTrackException);
      this.audioTrackState = audioTrackState;
      this.isRecoverable = isRecoverable;
      this.format = format;
    }
  }

  /** Thrown when a failure occurs writing to the sink. */
  final class WriteException extends Exception {

    /**
     * The error value returned from the sink implementation. If the sink writes to a platform
     * {@link AudioTrack}, this will be the error value returned from {@link
     * AudioTrack#write(byte[], int, int)} or {@link AudioTrack#write(ByteBuffer, int, int)}.
     * Otherwise, the meaning of the error code depends on the sink implementation.
     */
    public final int errorCode;
    /** If the exception can be recovered by recreating the sink. */
    public final boolean isRecoverable;
    /** The input {@link Format} of the sink when the error occurs. */
    public final Format format;

    /**
     * Creates an instance.
     *
     * @param errorCode The error value returned from the sink implementation.
     * @param format The input format of the sink when the error occurs.
     * @param isRecoverable Whether the exception can be recovered by recreating the sink.
     */
    public WriteException(int errorCode, Format format, boolean isRecoverable) {
      super(""AudioTrack write failed: "" + errorCode);
      this.isRecoverable = isRecoverable;
      this.errorCode = errorCode;
      this.format = format;
    }
  }

  /** Thrown when the sink encounters an unexpected timestamp discontinuity. */
  final class UnexpectedDiscontinuityException extends Exception {
    /** The actual presentation time of a sample, in microseconds. */
    public final long actualPresentationTimeUs;
    /** The expected presentation time of a sample, in microseconds. */
    public final long expectedPresentationTimeUs;

    /**
     * Creates an instance.
     *
     * @param actualPresentationTimeUs The actual presentation time of a sample, in microseconds.
     * @param expectedPresentationTimeUs The expected presentation time of a sample, in
     *     microseconds.
     */
    public UnexpectedDiscontinuityException(
        long actualPresentationTimeUs, long expectedPresentationTimeUs) {
      super(
          ""Unexpected audio track timestamp discontinuity: expected ""
              + expectedPresentationTimeUs
              + "", got ""
              + actualPresentationTimeUs);
      this.actualPresentationTimeUs = actualPresentationTimeUs;
      this.expectedPresentationTimeUs = expectedPresentationTimeUs;
    }
  }

  /**
   * The level of support the sink provides for a format. One of {@link
   * #SINK_FORMAT_SUPPORTED_DIRECTLY}, {@link #SINK_FORMAT_SUPPORTED_WITH_TRANSCODING} or {@link
   * #SINK_FORMAT_UNSUPPORTED}.
   */
  @Documented
  @Retention(RetentionPolicy.SOURCE)
  @Target(TYPE_USE)
  @IntDef({
    SINK_FORMAT_SUPPORTED_DIRECTLY,
    SINK_FORMAT_SUPPORTED_WITH_TRANSCODING,
    SINK_FORMAT_UNSUPPORTED
  })
  @interface SinkFormatSupport {}
  /** The sink supports the format directly, without the need for internal transcoding. */
  int SINK_FORMAT_SUPPORTED_DIRECTLY = 2;
  /**
   * The sink supports the format, but needs to transcode it internally to do so. Internal
   * transcoding may result in lower quality and higher CPU load in some cases.
   */
  int SINK_FORMAT_SUPPORTED_WITH_TRANSCODING = 1;
  /** The sink does not support the format. */
  int SINK_FORMAT_UNSUPPORTED = 0;

  /** Returned by {@link #getCurrentPositionUs(boolean)} when the position is not set. */
  long CURRENT_POSITION_NOT_SET = Long.MIN_VALUE;

  /**
   * Sets the listener for sink events, which should be the audio renderer.
   *
   * @param listener The listener for sink events, which should be the audio renderer.
   */
  void setListener(Listener listener);

  /**
   * Sets the {@link PlayerId} of the player using this audio sink.
   *
   * @param playerId The {@link PlayerId}, or null to clear a previously set id.
   */
  default void setPlayerId(@Nullable PlayerId playerId) {}

  /**
   * Returns whether the sink supports a given {@link Format}.
   *
   * @param format The format.
   * @return Whether the sink supports the format.
   */
  boolean supportsFormat(Format format);

  /**
   * Returns the level of support that the sink provides for a given {@link Format}.
   *
   * @param format The format.
   * @return The level of support provided.
   */
  @SinkFormatSupport
  int getFormatSupport(Format format);

  /**
   * Returns the playback position in the stream starting at zero, in microseconds, or {@link
   * #CURRENT_POSITION_NOT_SET} if it is not yet available.
   *
   * @param sourceEnded Specify {@code true} if no more input buffers will be provided.
   * @return The playback position relative to the start of playback, in microseconds.
   */
  long getCurrentPositionUs(boolean sourceEnded);

  /**
   * Configures (or reconfigures) the sink.
   *
   * @param inputFormat The format of audio data provided in the input buffers.
   * @param specifiedBufferSize A specific size for the playback buffer in bytes, or 0 to infer a
   *     suitable buffer size.
   * @param outputChannels A mapping from input to output channels that is applied to this sink's
   *     input as a preprocessing step, if handling PCM input. Specify {@code null} to leave the
   *     input unchanged. Otherwise, the element at index {@code i} specifies index of the input
   *     channel to map to output channel {@code i} when preprocessing input buffers. After the map
   *     is applied the audio data will have {@code outputChannels.length} channels.
   * @throws ConfigurationException If an error occurs configuring the sink.
   */
  void configure(Format inputFormat, int specifiedBufferSize, @Nullable int[] outputChannels)
      throws ConfigurationException;

  /** Starts or resumes consuming audio if initialized. */
  void play();

  /** Signals to the sink that the next buffer may be discontinuous with the previous buffer. */
  void handleDiscontinuity();

  /**
   * Attempts to process data from a {@link ByteBuffer}, starting from its current position and
   * ending at its limit (exclusive). The position of the {@link ByteBuffer} is advanced by the
   * number of bytes that were handled. {@link Listener#onPositionDiscontinuity()} will be called if
   * {@code presentationTimeUs} is discontinuous with the last buffer handled since the last reset.
   *
   * <p>Returns whether the data was handled in full. If the data was not handled in full then the
   * same {@link ByteBuffer} must be provided to subsequent calls until it has been fully consumed,
   * except in the case of an intervening call to {@link #flush()} (or to {@link #configure(Format,
   * int, int[])} that causes the sink to be flushed).
   *
   * @param buffer The buffer containing audio data.
   * @param presentationTimeUs The presentation timestamp of the buffer in microseconds.
   * @param encodedAccessUnitCount The number of encoded access units in the buffer, or 1 if the
   *     buffer contains PCM audio. This allows batching multiple encoded access units in one
   *     buffer.
   * @return Whether the buffer was handled fully.
   * @throws InitializationException If an error occurs initializing the sink.
   * @throws WriteException If an error occurs writing the audio data.
   */
  boolean handleBuffer(ByteBuffer buffer, long presentationTimeUs, int encodedAccessUnitCount)
      throws InitializationException, WriteException;

  /**
   * Processes any remaining data. {@link #isEnded()} will return {@code true} when no data remains.
   *
   * @throws WriteException If an error occurs draining data to the sink.
   */
  void playToEndOfStream() throws WriteException;

  /**
   * Returns whether {@link #playToEndOfStream} has been called and all buffers have been processed.
   */
  boolean isEnded();

  /** Returns whether the sink has data pending that has not been consumed yet. */
  boolean hasPendingData();

  /**
   * Attempts to set the playback parameters. The audio sink may override these parameters if they
   * are not supported.
   *
   * @param playbackParameters The new playback parameters to attempt to set.
   */
  void setPlaybackParameters(PlaybackParameters playbackParameters);

  /** Returns the active {@link PlaybackParameters}. */
  PlaybackParameters getPlaybackParameters();

  /** Sets whether silences should be skipped in the audio stream. */
  void setSkipSilenceEnabled(boolean  [MASK] );

  /** Returns whether silences are skipped in the audio stream. */
  boolean getSkipSilenceEnabled();

  /**
   * Sets attributes for audio playback. If the attributes have changed and if the sink is not
   * configured for use with tunneling, then it is reset and the audio session id is cleared.
   *
   * <p>If the sink is configured for use with tunneling then the audio attributes are ignored. The
   * sink is not reset and the audio session id is not cleared. The passed attributes will be used
   * if the sink is later re-configured into non-tunneled mode.
   *
   * @param audioAttributes The attributes for audio playback.
   */
  void setAudioAttributes(AudioAttributes audioAttributes);

  /**
   * Returns the audio attributes used for audio playback, or {@code null} if the sink does not use
   * audio attributes.
   */
  @Nullable
  AudioAttributes getAudioAttributes();

  /** Sets the audio session id. */
  void setAudioSessionId(int audioSessionId);

  /** Sets the auxiliary effect. */
  void setAuxEffectInfo(AuxEffectInfo auxEffectInfo);

  /**
   * Sets the preferred audio device.
   *
   * @param audioDeviceInfo The preferred {@linkplain AudioDeviceInfo audio device}, or null to
   *     restore the default.
   */
  @RequiresApi(23)
  default void setPreferredDevice(@Nullable AudioDeviceInfo audioDeviceInfo) {}

  /**
   * Sets the offset that is added to the media timestamp before it is passed as {@code
   * presentationTimeUs} in {@link #handleBuffer(ByteBuffer, long, int)}.
   *
   * @param outputStreamOffsetUs The output stream offset in microseconds.
   */
  default void setOutputStreamOffsetUs(long outputStreamOffsetUs) {}

  /**
   * Enables tunneling, if possible. The sink is reset if tunneling was previously disabled.
   * Enabling tunneling is only possible if the sink is based on a platform {@link AudioTrack}, and
   * requires platform API version 21 onwards.
   *
   * @throws IllegalStateException Thrown if enabling tunneling on platform API version &lt; 21.
   */
  void enableTunnelingV21();

  /**
   * Disables tunneling. If tunneling was previously enabled then the sink is reset and any audio
   * session id is cleared.
   */
  void disableTunneling();

  /**
   * Sets the playback volume.
   *
   * @param volume Linear output gain to apply to all channels. Should be in the range [0.0, 1.0].
   */
  void setVolume(float volume);

  /** Pauses playback. */
  void pause();

  /**
   * Flushes the sink, after which it is ready to receive buffers from a new playback position.
   *
   * <p>The audio session may remain active until {@link #reset()} is called.
   */
  void flush();

  /**
   * Flushes the sink, after which it is ready to receive buffers from a new playback position.
   *
   * <p>Does not release the {@link AudioTrack} held by the sink.
   *
   * <p>This method is experimental, and will be renamed or removed in a future release.
   *
   * <p>Only for experimental use as part of {@link
   * MediaCodecAudioRenderer#experimentalSetEnableKeepAudioTrackOnSeek(boolean)}.
   */
  void experimentalFlushWithoutAudioTrackRelease();

  /** Resets the sink, releasing any resources that it currently holds. */
  void reset();

  /** Releases the audio sink. */
  default void release() {}
}
","skipSilenceEnabled
"
"/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.handler.codec.http.multipart;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.CompositeByteBuf;
import io.netty.handler.codec.http.HttpConstants;
import io.netty.util.internal.ObjectUtil;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.Charset;

import static io.netty.buffer.Unpooled.EMPTY_BUFFER;
import static io.netty.buffer.Unpooled.buffer;
import static io.netty.buffer.Unpooled.compositeBuffer;
import static io.netty.buffer.Unpooled.wrappedBuffer;

/**
 * Abstract Memory HttpData implementation
 */
public abstract class AbstractMemoryHttpData extends AbstractHttpData {

    private ByteBuf byteBuf;
    private int chunkPosition;

    protected AbstractMemoryHttpData(String name, Charset charset, long size) {
        super(name, charset, size);
        byteBuf = EMPTY_BUFFER;
    }

    @Override
    public void setContent(ByteBuf buffer) throws IOException {
        ObjectUtil.checkNotNull(buffer, ""buffer"");
        long localsize = buffer.readableBytes();
        try {
            checkSize(localsize);
        } catch (IOException e) {
            buffer.release();
            throw e;
        }
        if (definedSize > 0 && definedSize < localsize) {
            buffer.release();
            throw new IOException(""Out of size: "" + localsize + "" > "" +
                    definedSize);
        }
        if (byteBuf != null) {
            byteBuf.release();
        }
        byteBuf = buffer;
        size = localsize;
        setCompleted();
    }

    @Override
    public void setContent(InputStream inputStream) throws IOException {
        ObjectUtil.checkNotNull(inputStream, ""inputStream"");

        byte[] bytes = new byte[4096 * 4];
        ByteBuf buffer = buffer();
        int written = 0;
        try {
            int read = inputStream.read(bytes);
            while (read > 0) {
                buffer.writeBytes(bytes, 0, read);
                written += read;
                checkSize(written);
                read = inputStream.read(bytes);
            }
        } catch (IOException e) {
            buffer.release();
            throw e;
        }
        size = written;
        if (definedSize > 0 && definedSize < size) {
            buffer.release();
            throw new IOException(""Out of size: "" + size + "" > "" + definedSize);
        }
        if (byteBuf != null) {
            byteBuf.release();
        }
        byteBuf = buffer;
        setCompleted();
    }

    @Override
    public void addContent(ByteBuf buffer, boolean last)
            throws IOException {
        if (buffer != null) {
            long localsize = buffer.readableBytes();
            try {
                checkSize(size + localsize);
            } catch (IOException e) {
                buffer.release();
                throw e;
            }
            if (definedSize > 0 && definedSize < size + localsize) {
                buffer.release();
                throw new IOException(""Out of size: "" + (size + localsize) +
                        "" > "" + definedSize);
            }
            size += localsize;
            if (byteBuf == null) {
                byteBuf = buffer;
            } else if (localsize == 0) {
                // Nothing to add and byteBuf already exists
                buffer.release();
            } else if (byteBuf.readableBytes() == 0) {
                // Previous buffer is empty, so just replace it
                byteBuf.release();
                byteBuf = buffer;
            } else if (byteBuf instanceof CompositeByteBuf) {
                CompositeByteBuf cbb = (CompositeByteBuf) byteBuf;
                cbb.addComponent(true, buffer);
            } else {
                CompositeByteBuf cbb = compositeBuffer(Integer.MAX_VALUE);
                cbb.addComponents(true, byteBuf, buffer);
                byteBuf = cbb;
            }
        }
        if (last) {
            setCompleted();
        } else {
            ObjectUtil.checkNotNull(buffer, ""buffer"");
        }
    }

    @Override
    public void setContent(File file) throws IOException {
        ObjectUtil.checkNotNull(file, ""file"");

        long newsize = file.length();
        if (newsize > Integer.MAX_VALUE) {
            throw new IllegalArgumentException(""File too big to be loaded in memory"");
        }
        checkSize(newsize);
        RandomAccessFile  [MASK]  = new RandomAccessFile(file, ""r"");
        ByteBuffer byteBuffer;
        try {
            FileChannel fileChannel =  [MASK] .getChannel();
            try {
                byte[] array = new byte[(int) newsize];
                byteBuffer = ByteBuffer.wrap(array);
                int read = 0;
                while (read < newsize) {
                    read += fileChannel.read(byteBuffer);
                }
            } finally {
                fileChannel.close();
            }
        } finally {
             [MASK] .close();
        }
        byteBuffer.flip();
        if (byteBuf != null) {
            byteBuf.release();
        }
        byteBuf = wrappedBuffer(Integer.MAX_VALUE, byteBuffer);
        size = newsize;
        setCompleted();
    }

    @Override
    public void delete() {
        if (byteBuf != null) {
            byteBuf.release();
            byteBuf = null;
        }
    }

    @Override
    public byte[] get() {
        if (byteBuf == null) {
            return EMPTY_BUFFER.array();
        }
        byte[] array = new byte[byteBuf.readableBytes()];
        byteBuf.getBytes(byteBuf.readerIndex(), array);
        return array;
    }

    @Override
    public String getString() {
        return getString(HttpConstants.DEFAULT_CHARSET);
    }

    @Override
    public String getString(Charset encoding) {
        if (byteBuf == null) {
            return """";
        }
        if (encoding == null) {
            encoding = HttpConstants.DEFAULT_CHARSET;
        }
        return byteBuf.toString(encoding);
    }

    /**
     * Utility to go from a In Memory FileUpload
     * to a Disk (or another implementation) FileUpload
     * @return the attached ByteBuf containing the actual bytes
     */
    @Override
    public ByteBuf getByteBuf() {
        return byteBuf;
    }

    @Override
    public ByteBuf getChunk(int length) throws IOException {
        if (byteBuf == null || length == 0 || byteBuf.readableBytes() == 0) {
            chunkPosition = 0;
            return EMPTY_BUFFER;
        }
        int sizeLeft = byteBuf.readableBytes() - chunkPosition;
        if (sizeLeft == 0) {
            chunkPosition = 0;
            return EMPTY_BUFFER;
        }
        int sliceLength = length;
        if (sizeLeft < length) {
            sliceLength = sizeLeft;
        }
        ByteBuf chunk = byteBuf.retainedSlice(chunkPosition, sliceLength);
        chunkPosition += sliceLength;
        return chunk;
    }

    @Override
    public boolean isInMemory() {
        return true;
    }

    @Override
    public boolean renameTo(File dest) throws IOException {
        ObjectUtil.checkNotNull(dest, ""dest"");
        if (byteBuf == null) {
            // empty file
            if (!dest.createNewFile()) {
                throw new IOException(""file exists already: "" + dest);
            }
            return true;
        }
        int length = byteBuf.readableBytes();
        long written = 0;
        RandomAccessFile  [MASK]  = new RandomAccessFile(dest, ""rw"");
        try {
            FileChannel fileChannel =  [MASK] .getChannel();
            try {
                if (byteBuf.nioBufferCount() == 1) {
                    ByteBuffer byteBuffer = byteBuf.nioBuffer();
                    while (written < length) {
                        written += fileChannel.write(byteBuffer);
                    }
                } else {
                    ByteBuffer[] byteBuffers = byteBuf.nioBuffers();
                    while (written < length) {
                        written += fileChannel.write(byteBuffers);
                    }
                }
                fileChannel.force(false);
            } finally {
                fileChannel.close();
            }
        } finally {
             [MASK] .close();
        }
        return written == length;
    }

    @Override
    public File getFile() throws IOException {
        throw new IOException(""Not represented by a file"");
    }

    @Override
    public HttpData touch() {
        return touch(null);
    }

    @Override
    public HttpData touch(Object hint) {
        if (byteBuf != null) {
            byteBuf.touch(hint);
        }
        return this;
    }
}
","accessFile
"
"/*
 * Copyright 2012 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.handler.codec.compression;

import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;

import io.netty. [MASK] .ByteBuf;
import io.netty. [MASK] .ByteBufAllocator;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.ByteToMessageDecoder;

/**
 * Decompresses a {@link ByteBuf} using the deflate algorithm.
 */
public abstract class ZlibDecoder extends ByteToMessageDecoder {

    /**
     * Maximum allowed size of the decompression  [MASK] .
     */
    protected final int maxAllocation;

    /**
     * Same as {@link #ZlibDecoder(int)} with maxAllocation = 0.
     */
    public ZlibDecoder() {
        this(0);
    }

    /**
     * Construct a new ZlibDecoder.
     * @param maxAllocation
     *          Maximum size of the decompression  [MASK] . Must be &gt;= 0.
     *          If zero, maximum size is decided by the {@link ByteBufAllocator}.
     */
    public ZlibDecoder(int maxAllocation) {
        this.maxAllocation = checkPositiveOrZero(maxAllocation, ""maxAllocation"");
    }

    /**
     * Returns {@code true} if and only if the end of the compressed stream
     * has been reached.
     */
    public abstract boolean isClosed();

    /**
     * Allocate or expand the decompression  [MASK] , without exceeding the maximum allocation.
     * Calls {@link #decompressionBufferExhausted(ByteBuf)} if the  [MASK]  is full and cannot be expanded further.
     */
    protected ByteBuf prepareDecompressBuffer(ChannelHandlerContext ctx, ByteBuf  [MASK] , int preferredSize) {
        if ( [MASK]  == null) {
            if (maxAllocation == 0) {
                return ctx.alloc().heapBuffer(preferredSize);
            }

            return ctx.alloc().heapBuffer(Math.min(preferredSize, maxAllocation), maxAllocation);
        }

        // this always expands the  [MASK]  if possible, even if the expansion is less than preferredSize
        // we throw the exception only if the  [MASK]  could not be expanded at all
        // this means that one final attempt to deserialize will always be made with the  [MASK]  at maxAllocation
        if ( [MASK] .ensureWritable(preferredSize, true) == 1) {
            //  [MASK]  must be consumed so subclasses don't add it to output
            // we therefore duplicate it when calling decompressionBufferExhausted() to guarantee non-interference
            // but wait until after to consume it so the subclass can tell how much output is really in the  [MASK] 
            decompressionBufferExhausted( [MASK] .duplicate());
             [MASK] .skipBytes( [MASK] .readableBytes());
            throw new DecompressionException(""Decompression  [MASK]  has reached maximum size: "" +  [MASK] .maxCapacity());
        }

        return  [MASK] ;
    }

    /**
     * Called when the decompression  [MASK]  cannot be expanded further.
     * Default implementation is a no-op, but subclasses can override in case they want to
     * do something before the {@link DecompressionException} is thrown, such as log the
     * data that was decompressed so far.
     */
    protected void decompressionBufferExhausted(ByteBuf  [MASK] ) {
    }

}
","buffer
"
"// Copyright 2014 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package com.google.devtools.build.lib.rules.java;

import static com.google.common.base.StandardSystemProperty.JAVA_SPECIFICATION_VERSION;
import static com.google.devtools.build.lib.rules.java.JavaStarlarkCommon.checkPrivateAccess;

import com.google.auto.value.AutoValue;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.devtools.build.lib.actions.Artifact;
import com.google.devtools.build.lib.analysis.FilesToRunProvider;
import com.google.devtools.build.lib.analysis.PackageSpecificationProvider;
import com.google.devtools.build.lib.analysis.ProviderCollection;
import com.google.devtools.build.lib.analysis.RuleContext;
import com.google.devtools.build.lib.analysis.RuleErrorConsumer;
import com.google.devtools.build.lib.analysis.platform.ToolchainInfo;
import com.google.devtools.build.lib.cmdline.Label;
import com.google.devtools.build.lib.collect.nestedset.Depset;
import com.google.devtools.build.lib.collect.nestedset.NestedSet;
import com.google.devtools.build.lib.collect.nestedset.NestedSetBuilder;
import com.google.devtools.build.lib.collect.nestedset.Order;
import com.google.devtools.build.lib.concurrent.ThreadSafety.Immutable;
import com.google.devtools.build.lib.packages.BuiltinProvider;
import com.google.devtools.build.lib.packages.NativeInfo;
import com.google.devtools.build.lib.packages.PackageSpecification.PackageGroupContents;
import com.google.devtools.build.lib.packages.Provider;
import com.google.devtools.build.lib.rules.java.JavaPluginInfo.JavaPluginData;
import com.google.devtools.build.lib.starlarkbuildapi.java.JavaToolchainStarlarkApiProviderApi;
import java.util.Iterator;
import javax.annotation.Nullable;
import net.starlark.java.eval.EvalException;
import net.starlark.java.eval.StarlarkList;
import net.starlark.java.eval.StarlarkThread;

/** Information about the JDK used by the <code>java_*</code> rules. */
@Immutable
public final class JavaToolchainProvider extends NativeInfo
    implements JavaToolchainStarlarkApiProviderApi {

  public static final BuiltinProvider<JavaToolchainProvider> PROVIDER =
      new BuiltinProvider<JavaToolchainProvider>(
          ""JavaToolchainInfo"", JavaToolchainProvider.class) {};

  /** Returns the Java Toolchain associated with the rule being analyzed or {@code null}. */
  public static JavaToolchainProvider from(RuleContext ruleContext) {
    ToolchainInfo toolchainInfo =
        ruleContext.getToolchainInfo(
            ruleContext
                .getPrerequisite(JavaRuleClasses.JAVA_TOOLCHAIN_TYPE_ATTRIBUTE_NAME)
                .getLabel());
    return from(toolchainInfo, ruleContext);
  }

  @VisibleForTesting
  public static JavaToolchainProvider from(ProviderCollection collection) {
    ToolchainInfo toolchainInfo = collection.get(ToolchainInfo.PROVIDER);
    return from(toolchainInfo, null);
  }

  @Nullable
  private static JavaToolchainProvider from(
      ToolchainInfo toolchainInfo, @Nullable RuleErrorConsumer errorConsumer) {
    if (toolchainInfo != null) {
      try {
        JavaToolchainProvider provider = (JavaToolchainProvider) toolchainInfo.getValue(""java"");
        if (provider != null) {
          return provider;
        }
      } catch (EvalException e) {
        if (errorConsumer != null) {
          errorConsumer.ruleError(
              String.format(""There was an error reading the Java toolchain: %s"", e));
        }
      }
    }
    if (errorConsumer != null) {
      errorConsumer.ruleError(""The selected Java toolchain is not a JavaToolchainProvider"");
    }
    return null;
  }

  public static JavaToolchainProvider create(
      Label label,
      ImmutableList<String> javacOptions,
      NestedSet<String>  [MASK] ,
      boolean javacSupportsWorkers,
      boolean javacSupportsMultiplexWorkers,
      boolean javacSupportsWorkerCancellation,
      BootClassPathInfo bootclasspath,
      NestedSet<Artifact> tools,
      JavaToolchainTool javaBuilder,
      @Nullable JavaToolchainTool headerCompiler,
      @Nullable JavaToolchainTool headerCompilerDirect,
      @Nullable AndroidLintTool androidLint,
      JspecifyInfo jspecifyInfo,
      @Nullable JavaToolchainTool bytecodeOptimizer,
      ImmutableList<Artifact> localJavaOptimizationConfiguration,
      ImmutableSet<String> headerCompilerBuiltinProcessors,
      ImmutableSet<String> reducedClasspathIncompatibleProcessors,
      boolean forciblyDisableHeaderCompilation,
      FilesToRunProvider singleJar,
      @Nullable FilesToRunProvider oneVersion,
      @Nullable Artifact oneVersionAllowlist,
      @Nullable Artifact oneVersionAllowlistForTests,
      Artifact genClass,
      @Nullable Artifact depsChecker,
      @Nullable Artifact timezoneData,
      FilesToRunProvider ijar,
      ImmutableListMultimap<String, String> compatibleJavacOptions,
      ImmutableList<JavaPackageConfigurationProvider> packageConfiguration,
      FilesToRunProvider jacocoRunner,
      FilesToRunProvider proguardAllowlister,
      JavaSemantics javaSemantics,
      JavaRuntimeInfo javaRuntime) {
    return new JavaToolchainProvider(
        label,
        bootclasspath,
        tools,
        javaBuilder,
        headerCompiler,
        headerCompilerDirect,
        androidLint,
        jspecifyInfo,
        bytecodeOptimizer,
        localJavaOptimizationConfiguration,
        headerCompilerBuiltinProcessors,
        reducedClasspathIncompatibleProcessors,
        forciblyDisableHeaderCompilation,
        singleJar,
        oneVersion,
        oneVersionAllowlist,
        oneVersionAllowlistForTests,
        genClass,
        depsChecker,
        timezoneData,
        ijar,
        compatibleJavacOptions,
        javacOptions,
         [MASK] ,
        javacSupportsWorkers,
        javacSupportsMultiplexWorkers,
        javacSupportsWorkerCancellation,
        packageConfiguration,
        jacocoRunner,
        proguardAllowlister,
        javaSemantics,
        javaRuntime);
  }

  private final Label label;
  private final BootClassPathInfo bootclasspath;
  private final NestedSet<Artifact> tools;
  private final JavaToolchainTool javaBuilder;
  @Nullable private final JavaToolchainTool headerCompiler;
  @Nullable private final JavaToolchainTool headerCompilerDirect;
  @Nullable private final AndroidLintTool androidLint;
  @Nullable private final JspecifyInfo jspecifyInfo;
  @Nullable private final JavaToolchainTool bytecodeOptimizer;
  private final ImmutableList<Artifact> localJavaOptimizationConfiguration;
  private final ImmutableSet<String> headerCompilerBuiltinProcessors;
  private final ImmutableSet<String> reducedClasspathIncompatibleProcessors;
  private final boolean forciblyDisableHeaderCompilation;
  private final FilesToRunProvider singleJar;
  @Nullable private final FilesToRunProvider oneVersion;
  @Nullable private final Artifact oneVersionAllowlist;
  @Nullable private final Artifact oneVersionAllowlistForTests;
  private final Artifact genClass;
  @Nullable private final Artifact depsChecker;
  @Nullable private final Artifact timezoneData;
  private final FilesToRunProvider ijar;
  private final ImmutableMap<String, NestedSet<String>> compatibleJavacOptions;
  private final NestedSet<String> javacOptions;
  private final String sourceVersion;
  private final String targetVersion;
  private final NestedSet<String>  [MASK] ;
  private final boolean javacSupportsWorkers;
  private final boolean javacSupportsMultiplexWorkers;
  private final boolean javacSupportsWorkerCancellation;
  private final ImmutableList<JavaPackageConfigurationProvider> packageConfiguration;
  private final FilesToRunProvider jacocoRunner;
  private final FilesToRunProvider proguardAllowlister;
  private final JavaSemantics javaSemantics;
  private final JavaRuntimeInfo javaRuntime;

  private JavaToolchainProvider(
      Label label,
      BootClassPathInfo bootclasspath,
      NestedSet<Artifact> tools,
      JavaToolchainTool javaBuilder,
      @Nullable JavaToolchainTool headerCompiler,
      @Nullable JavaToolchainTool headerCompilerDirect,
      @Nullable AndroidLintTool androidLint,
      @Nullable JspecifyInfo jspecifyInfo,
      @Nullable JavaToolchainTool bytecodeOptimizer,
      ImmutableList<Artifact> localJavaOptimizationConfiguration,
      ImmutableSet<String> headerCompilerBuiltinProcessors,
      ImmutableSet<String> reducedClasspathIncompatibleProcessors,
      boolean forciblyDisableHeaderCompilation,
      FilesToRunProvider singleJar,
      @Nullable FilesToRunProvider oneVersion,
      @Nullable Artifact oneVersionAllowlist,
      @Nullable Artifact oneVersionAllowlistForTests,
      Artifact genClass,
      @Nullable Artifact depsChecker,
      @Nullable Artifact timezoneData,
      FilesToRunProvider ijar,
      ImmutableListMultimap<String, String> compatibleJavacOptions,
      ImmutableList<String> javacOptions,
      NestedSet<String>  [MASK] ,
      boolean javacSupportsWorkers,
      boolean javacSupportsMultiplexWorkers,
      boolean javacSupportsWorkerCancellation,
      ImmutableList<JavaPackageConfigurationProvider> packageConfiguration,
      FilesToRunProvider jacocoRunner,
      FilesToRunProvider proguardAllowlister,
      JavaSemantics javaSemantics,
      JavaRuntimeInfo javaRuntime) {

    this.label = label;
    this.bootclasspath = bootclasspath;
    this.tools = tools;
    this.javaBuilder = javaBuilder;
    this.headerCompiler = headerCompiler;
    this.headerCompilerDirect = headerCompilerDirect;
    this.androidLint = androidLint;
    this.jspecifyInfo = jspecifyInfo;
    this.bytecodeOptimizer = bytecodeOptimizer;
    this.localJavaOptimizationConfiguration = localJavaOptimizationConfiguration;
    this.headerCompilerBuiltinProcessors = headerCompilerBuiltinProcessors;
    this.reducedClasspathIncompatibleProcessors = reducedClasspathIncompatibleProcessors;
    this.forciblyDisableHeaderCompilation = forciblyDisableHeaderCompilation;
    this.singleJar = singleJar;
    this.oneVersion = oneVersion;
    this.oneVersionAllowlist = oneVersionAllowlist;
    this.oneVersionAllowlistForTests = oneVersionAllowlistForTests;
    this.genClass = genClass;
    this.depsChecker = depsChecker;
    this.timezoneData = timezoneData;
    this.ijar = ijar;
    this.compatibleJavacOptions =
        ImmutableMap.copyOf(
            Maps.transformValues(
                compatibleJavacOptions.asMap(), JavaHelper::detokenizeJavaOptions));
    this.javacOptions = JavaHelper.detokenizeJavaOptions(javacOptions);
    this.sourceVersion = findSourceVersion(javacOptions);
    this.targetVersion = findTargetVersion(javacOptions);
    this. [MASK]  =  [MASK] ;
    this.javacSupportsWorkers = javacSupportsWorkers;
    this.javacSupportsMultiplexWorkers = javacSupportsMultiplexWorkers;
    this.javacSupportsWorkerCancellation = javacSupportsWorkerCancellation;
    this.packageConfiguration = packageConfiguration;
    this.jacocoRunner = jacocoRunner;
    this.proguardAllowlister = proguardAllowlister;
    this.javaSemantics = javaSemantics;
    this.javaRuntime = javaRuntime;
  }

  /** Returns the label for this {@code java_toolchain}. */
  @Override
  public Label getToolchainLabel() {
    return label;
  }

  /** Returns the target Java bootclasspath. */
  public BootClassPathInfo getBootclasspath() {
    return bootclasspath;
  }

  /** Returns the {@link Artifact}s of compilation tools. */
  public NestedSet<Artifact> getTools() {
    return tools;
  }

  /** Returns the {@link JavaToolchainTool} for JavaBuilder */
  public JavaToolchainTool getJavaBuilder() {
    return javaBuilder;
  }

  /** Returns the {@link JavaToolchainTool} for the header compiler */
  @Nullable
  public JavaToolchainTool getHeaderCompiler() {
    return headerCompiler;
  }

  /**
   * Returns the {@link FilesToRunProvider} of the Header Compiler deploy jar for direct-classpath,
   * non-annotation processing actions.
   */
  @Nullable
  public JavaToolchainTool getHeaderCompilerDirect() {
    return headerCompilerDirect;
  }

  @Nullable
  public AndroidLintTool getAndroidLint() {
    return androidLint;
  }

  @Nullable
  public JspecifyInfo jspecifyInfo() {
    return jspecifyInfo;
  }

  @Nullable
  public JavaToolchainTool getBytecodeOptimizer() {
    return bytecodeOptimizer;
  }

  public ImmutableList<Artifact> getLocalJavaOptimizationConfiguration() {
    return localJavaOptimizationConfiguration;
  }

  /** Returns class names of annotation processors that are built in to the header compiler. */
  public ImmutableSet<String> getHeaderCompilerBuiltinProcessors() {
    return headerCompilerBuiltinProcessors;
  }

  public ImmutableSet<String> getReducedClasspathIncompatibleProcessors() {
    return reducedClasspathIncompatibleProcessors;
  }

  /**
   * Returns {@code true} if header compilation should be forcibly disabled, overriding
   * --java_header_compilation.
   */
  public boolean getForciblyDisableHeaderCompilation() {
    return forciblyDisableHeaderCompilation;
  }

  @Override
  public boolean getForciblyDisableHeaderCompilationStarlark(StarlarkThread thread)
      throws EvalException {
    checkPrivateAccess(thread);
    return getForciblyDisableHeaderCompilation();
  }

  @Override
  public boolean hasHeaderCompiler(StarlarkThread thread) throws EvalException {
    checkPrivateAccess(thread);
    return getHeaderCompiler() != null;
  }

  @Override
  public boolean hasHeaderCompilerDirect(StarlarkThread thread) throws EvalException {
    checkPrivateAccess(thread);
    return getHeaderCompilerDirect() != null;
  }

  /** Returns the {@link FilesToRunProvider} of the SingleJar tool. */
  @Override
  public FilesToRunProvider getSingleJar() {
    return singleJar;
  }

  /**
   * Return the {@link FilesToRunProvider} of the tool that enforces one-version compliance of Java
   * binaries.
   */
  @Override
  @Nullable
  public FilesToRunProvider getOneVersionBinary() {
    return oneVersion;
  }

  /** Return the {@link Artifact} of the allowlist used by the one-version compliance checker. */
  @Nullable
  @Override
  public Artifact getOneVersionAllowlist() {
    return oneVersionAllowlist;
  }

  /**
   * Return the {@link Artifact} of the one-version allowlist for tests used by the one-version
   * compliance checker.
   */
  @Nullable
  public Artifact oneVersionAllowlistForTests() {
    return oneVersionAllowlistForTests;
  }

  @Override
  @Nullable
  public Artifact getOneVersionAllowlistForTests(StarlarkThread thread) throws EvalException {
    checkPrivateAccess(thread);
    return oneVersionAllowlistForTests();
  }

  /** Returns the {@link Artifact} of the GenClass deploy jar */
  public Artifact getGenClass() {
    return genClass;
  }

  /** Returns the {@link Artifact} of the ImportDepsChecker deploy jar */
  @Nullable
  public Artifact depsChecker() {
    return depsChecker;
  }

  @Override
  public Artifact getDepsCheckerForStarlark(StarlarkThread thread) throws EvalException {
    checkPrivateAccess(thread);
    return depsChecker();
  }

  /**
   * Returns the {@link Artifact} of the latest timezone data resource jar that can be loaded by
   * Java 8 binaries.
   */
  @Nullable
  public Artifact getTimezoneData() {
    return timezoneData;
  }

  /** Returns the ijar executable */
  @Override
  public FilesToRunProvider getIjar() {
    return ijar;
  }

  /** Returns the map of target environment-specific javacopts. */
  public NestedSet<String> getCompatibleJavacOptions(String key) {
    return compatibleJavacOptions.getOrDefault(
        key, NestedSetBuilder.emptySet(Order.NAIVE_LINK_ORDER));
  }

  public ImmutableList<String> getCompatibleJavacOptionsAsList(String key) {
    return JavaHelper.tokenizeJavaOptions(getCompatibleJavacOptions(key));
  }

  /** Returns the list of default options for the java compiler. */
  public NestedSet<String> getJavacOptions(RuleContext ruleContext) {
    NestedSetBuilder<String> result = NestedSetBuilder.naiveLinkOrder();
    result.addTransitive(javacOptions);
    if (ruleContext != null) {
      // TODO(b/78512644): require ruleContext to be non-null after java_common.default_javac_opts
      // is turned down
      result.addTransitive(ruleContext.getFragment(JavaConfiguration.class).getDefaultJavacFlags());
    }
    return result.build();
  }

  public ImmutableList<String> getJavacOptionsAsList(RuleContext ruleContext) {
    ImmutableList.Builder<String> result =
        ImmutableList.<String>builder().addAll(JavaHelper.tokenizeJavaOptions(javacOptions));
    if (ruleContext != null) {
      // TODO(b/78512644): require ruleContext to be non-null after java_common.default_javac_opts
      // is turned down
      result.addAll(
          ruleContext.getFragment(JavaConfiguration.class).getDefaultJavacFlagsForStarlarkAsList());
    }
    return result.build();
  }

  /**
   * Returns the NestedSet of default options for the JVM running the java compiler and associated
   * tools.
   */
  public NestedSet<String> getJvmOptions() {
    return  [MASK] ;
  }

  /** Returns whether JavaBuilders supports running as a persistent worker or not. */
  public boolean getJavacSupportsWorkers() {
    return javacSupportsWorkers;
  }

  /** Returns whether JavaBuilders supports running persistent workers in multiplex mode */
  public boolean getJavacSupportsMultiplexWorkers() {
    return javacSupportsMultiplexWorkers;
  }

  /** Returns whether JavaBuilders supports running persistent workers with cancellation */
  public boolean getJavacSupportsWorkerCancellation() {
    return javacSupportsWorkerCancellation;
  }

  /** Returns the global {@code java_package_configuration} data. */
  public ImmutableList<JavaPackageConfigurationProvider> packageConfiguration() {
    return packageConfiguration;
  }

  @Override
  public FilesToRunProvider getJacocoRunner() {
    return jacocoRunner;
  }

  @Override
  public FilesToRunProvider getProguardAllowlister() {
    return proguardAllowlister;
  }

  @Override
  public StarlarkList<JavaPackageConfigurationProvider> getPackageConfigurationStarlark(
      StarlarkThread thread) throws EvalException {
    checkPrivateAccess(thread);
    return StarlarkList.immutableCopyOf(packageConfiguration);
  }

  public JavaSemantics getJavaSemantics() {
    return javaSemantics;
  }

  @Override
  public JavaRuntimeInfo getJavaRuntime() {
    return javaRuntime;
  }

  @Override
  @Nullable
  public AndroidLintTool stalarkAndroidLinter(StarlarkThread thread) throws EvalException {
    checkPrivateAccess(thread);
    return getAndroidLint();
  }

  /** Returns the input Java language level */
  // TODO(cushon): remove this API; it bakes a deprecated detail of the javac API into Bazel
  @Override
  public String getSourceVersion() {
    return sourceVersion;
  }

  private static String findSourceVersion(ImmutableList<String> javacOptions) {
    Iterator<String> it = javacOptions.iterator();
    while (it.hasNext()) {
      if (it.next().equals(""-source"") && it.hasNext()) {
        return it.next();
      }
    }
    return JAVA_SPECIFICATION_VERSION.value();
  }

  /** Returns the target Java language level */
  // TODO(cushon): remove this API; it bakes a deprecated detail of the javac API into Bazel
  @Override
  public String getTargetVersion() {
    return targetVersion;
  }

  private static String findTargetVersion(ImmutableList<String> javacOptions) {
    Iterator<String> it = javacOptions.iterator();
    while (it.hasNext()) {
      if (it.next().equals(""-target"") && it.hasNext()) {
        return it.next();
      }
    }
    return JAVA_SPECIFICATION_VERSION.value();
  }

  @Override
  public Depset getStarlarkBootclasspath() {
    return Depset.of(Artifact.class, getBootclasspath().bootclasspath());
  }

  @Override
  public Depset getStarlarkJvmOptions() {
    return Depset.of(String.class, getJvmOptions());
  }

  @Override
  public Depset getStarlarkTools() {
    return Depset.of(Artifact.class, getTools());
  }

  @Override
  public Provider getProvider() {
    return PROVIDER;
  }

  @Nullable
  @Override
  public Artifact getTimezoneDataForStarlark(StarlarkThread thread) throws EvalException {
    checkPrivateAccess(thread);
    return getTimezoneData();
  }

  @Override
  public Object getCompatibleJavacOptionsForStarlark(
      String key, boolean asDepset, StarlarkThread thread) throws EvalException {
    checkPrivateAccess(thread);
    if (asDepset) {
      return Depset.of(String.class, getCompatibleJavacOptions(key));
    } else {
      return getCompatibleJavacOptionsAsList(key);
    }
  }

  @AutoValue
  abstract static class JspecifyInfo {

    abstract JavaPluginData jspecifyProcessor();

    abstract NestedSet<Artifact> jspecifyImplicitDeps();

    abstract ImmutableList<String> jspecifyJavacopts();

    abstract ImmutableList<PackageSpecificationProvider> jspecifyPackages();

    boolean matches(Label label) {
      for (PackageSpecificationProvider provider : jspecifyPackages()) {
        for (PackageGroupContents specifications : provider.getPackageSpecifications().toList()) {
          if (specifications.containsPackage(label.getPackageIdentifier())) {
            return true;
          }
        }
      }
      return false;
    }

    static JspecifyInfo create(
        JavaPluginData jspecifyProcessor,
        NestedSet<Artifact> jspecifyImplicitDeps,
        ImmutableList<String> jspecifyJavacopts,
        ImmutableList<PackageSpecificationProvider> jspecifyPackages) {
      return new AutoValue_JavaToolchainProvider_JspecifyInfo(
          jspecifyProcessor, jspecifyImplicitDeps, jspecifyJavacopts, jspecifyPackages);
    }
  }
}
","jvmOptions
"
"// Copyright 2021 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.devtools.build.lib.collect.nestedset;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.util.concurrent.Futures.immediateVoidFuture;
import static com.google.common.util.concurrent.MoreExecutors.directExecutor;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.google.auto.value.AutoValue;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.SettableFuture;
import com.google.devtools.build.lib.bugreport.BugReporter;
import com.google.devtools.build.lib.collect.nestedset.NestedSetStore.FingerprintComputationResult;
import com.google.devtools.build.lib.skyframe.serialization.SerializationConstants;
import com.google.protobuf.ByteString;
import javax.annotation.Nullable;

/**
 * A bidirectional, in-memory, weak cache for fingerprint ⟺ {@link NestedSet} associations.
 *
 * <p>For use by {@link NestedSetStore} to minimize work during {@link NestedSet} (de)serialization.
 *
 * <p>The cache supports the possibility of semantically different arrays having the same serialized
 * representation. For this reason, a  [MASK]  object is included in the key for the fingerprint ⟹
 * array mapping. This object should encapsulate all additional  [MASK]  necessary to deserialize a
 * {@link NestedSet} element. The array ⟹ fingerprint mapping, on the other hand, is expected to be
 * deterministic.
 */
class NestedSetSerializationCache {

  /**
   * Fingerprint to array cache.
   *
   * <p>The values in this cache are always {@code Object[]} or {@code ListenableFuture<Object[]>}.
   * We avoid a common wrapper object both for memory efficiency and because our cache eviction
   * policy is based on value GC, and wrapper objects would defeat that.
   *
   * <p>While a fetch for the contents is outstanding, the value in the cache will be a {@link
   * ListenableFuture}. When it is resolved, it is replaced with the unwrapped {@code Object[]}.
   * This is done because if the array is a transitive member, its future may be GC'd, and we want
   * entries to stay in this cache while the contents are still live.
   */
  private final Cache<FingerprintKey, Object> fingerprintToContents =
      Caffeine.newBuilder()
          .initialCapacity(SerializationConstants.DESERIALIZATION_POOL_SIZE)
          .weakValues()
          .build();

  /** {@code Object[]} contents to fingerprint. Maintained for fast fingerprinting. */
  private final Cache<Object[], FingerprintComputationResult> contentsToFingerprint =
      Caffeine.newBuilder()
          .initialCapacity(SerializationConstants.DESERIALIZATION_POOL_SIZE)
          .weakKeys()
          .build();

  private final BugReporter bugReporter;

  NestedSetSerializationCache(BugReporter bugReporter) {
    this.bugReporter = bugReporter;
  }

  /**
   * Returns contents (an {@code Object[]} or a {@code ListenableFuture<Object[]>}) for the {@link
   * NestedSet} associated with the given fingerprint if there was already one. Otherwise associates
   * {@code future} with {@code fingerprint} and returns {@code null}.
   *
   * <p>Upon a {@code null} return, the caller should ensure that the given future is eventually set
   * with the fetched contents.
   *
   * <p>Upon a non-{@code null} return, the caller should discard the given future in favor of the
   * returned contents, blocking for them if the return value is itself a future.
   *
   * @param fingerprint the fingerprint of the desired {@link NestedSet} contents
   * @param  [MASK]  the  [MASK]  needed to deterministically deserialize the contents associated with
   *     {@code fingerprint}
   * @param future a freshly created {@link SettableFuture}
   */
  @Nullable
  Object putFutureIfAbsent(
      ByteString fingerprint, SettableFuture<Object[]> future, Object  [MASK] ) {
    checkArgument(!future.isDone(), ""Must pass a fresh future: %s"", future);
    Object existing =
        fingerprintToContents.asMap().putIfAbsent(FingerprintKey.of(fingerprint,  [MASK] ), future);
    if (existing != null) {
      return existing;
    }
    // This is the first request of this fingerprint.
    unwrapWhenDone(fingerprint, future,  [MASK] );
    return null;
  }

  /**
   * Registers a {@link FutureCallback} that associates the provided fingerprint and the contents of
   * the future, when it completes.
   */
  private void unwrapWhenDone(
      ByteString fingerprint, ListenableFuture<Object[]> futureContents, Object  [MASK] ) {
    Futures.addCallback(
        futureContents,
        new FutureCallback<Object[]>() {
          @Override
          public void onSuccess(Object[] contents) {
            // Store a FingerprintComputationResult so that we can skip fingerprinting this array
            // and writing it to storage (it's already there - we just fetched it). Also replace the
            // cached future with the unwrapped contents, since the future may be GC'd. If there was
            // a call to putIfAbsent with this fingerprint while the future was pending, we may
            // overwrite a fingerprint ⟹ array mapping, but this is fine since both arrays have
            // the same contents. In this case, it would be nice to also complete the other array's
            // write future, but the semantics of SettableFuture makes this difficult (set after
            // setFuture has no effect).
            putIfAbsent(
                contents,
                FingerprintComputationResult.create(fingerprint, immediateVoidFuture()),
                 [MASK] );
          }

          @Override
          public void onFailure(Throwable t) {
            // Failure to fetch the NestedSet contents is unexpected, but the failed future can be
            // stored as the NestedSet children. This way the exception is only propagated if the
            // NestedSet is consumed (unrolled).
            bugReporter.sendNonFatalBugReport(t);
          }
        },
        directExecutor());
  }

  /**
   * Retrieves the fingerprint associated with the given {@link NestedSet} contents, or {@code null}
   * if the given contents are not known.
   */
  @Nullable
  FingerprintComputationResult fingerprintForContents(Object[] contents) {
    return contentsToFingerprint.getIfPresent(contents);
  }

  /**
   * Ensures that a fingerprint ⟺ contents association is cached in both directions.
   *
   * <p>If the given fingerprint and array are already <em>fully<em> cached, returns the existing
   * {@link FingerprintComputationResult}. Otherwise returns {@code null}.
   *
   * <p>If the given fingerprint is only <em>partially</em> cached (meaning that {@link
   * #putFutureIfAbsent} has been called but the associated future has not yet completed), then the
   * cached future is overwritten in favor of the actual contents.
   */
  @Nullable
  FingerprintComputationResult putIfAbsent(
      Object[] contents, FingerprintComputationResult result, Object  [MASK] ) {
    FingerprintComputationResult existingResult =
        contentsToFingerprint.asMap().putIfAbsent(contents, result);
    if (existingResult != null) {
      return existingResult;
    }
    fingerprintToContents.put(FingerprintKey.of(result.fingerprint(),  [MASK] ), contents);
    return null;
  }

  @AutoValue
  abstract static class FingerprintKey {
    abstract ByteString fingerprint();

    abstract Object  [MASK] ();

    static FingerprintKey of(ByteString fingerprint, Object  [MASK] ) {
      return new AutoValue_NestedSetSerializationCache_FingerprintKey(fingerprint,  [MASK] );
    }
  }
}
","context
"
"/*
 * Copyright 2023 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.exoplayer2.muxer;

import static com.google.android.exoplayer2.util.Assertions.checkNotNull;

import android.content.Context;
import android.media.MediaCodec;
import android.media.MediaExtractor;
import androidx.test.core.app.ApplicationProvider;
import com.google.android.exoplayer2.extractor.mp4.Mp4Extractor;
import com.google.android.exoplayer2.testutil.DumpFileAsserts;
import com.google.android.exoplayer2.testutil.FakeExtractorOutput;
import com.google.android.exoplayer2.testutil.TestUtil;
import com.google.android.exoplayer2.util.MediaFormatUtil;
import com.google.common.collect.ImmutableList;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;

/** End to end instrumentation tests for {@link Mp4Muxer}. */
@RunWith(Parameterized.class)
public class Mp4MuxerEndToEndTest {
  private static final String H264_MP4 = ""sample.mp4"";
  private static final String H265_HDR10_MP4 = ""hdr10-720p.mp4"";
  private static final String H265_WITH_METADATA_TRACK_MP4 = ""h265_with_metadata_track.mp4"";
  private static final String AV1_MP4 = ""sample_av1.mp4"";

  @Parameters(name = ""{0}"")
  public static ImmutableList<String> mediaSamples() {
    return ImmutableList.of(H264_MP4, H265_HDR10_MP4, H265_WITH_METADATA_TRACK_MP4, AV1_MP4);
  }

  @Parameter public @MonotonicNonNull String inputFile;
  @Rule public final TemporaryFolder temporaryFolder = new TemporaryFolder();

  private static final String MP4_FILE_ASSET_DIRECTORY = ""media/mp4/"";
  private final Context context = ApplicationProvider.getApplicationContext();
  private @MonotonicNonNull String outputPath;
  private @MonotonicNonNull FileOutputStream outputStream;

  @Before
  public void setUp() throws Exception {
    outputPath = temporaryFolder.newFile(""muxeroutput.mp4"").getPath();
    outputStream = new FileOutputStream(outputPath);
  }

  @After
  public void tearDown() throws IOException {
    checkNotNull(outputStream).close();
  }

  @Test
  public void createMp4File_fromInputFileSampleData_matchesExpected() throws IOException {
    Mp4Muxer mp4Muxer = null;

    try {
      mp4Muxer = new Mp4Muxer.Builder(checkNotNull(outputStream)).build();
      mp4Muxer.setModificationTime(/* timestampMs= */ 500_000_000L);
      feedInputDataToMuxer(mp4Muxer, checkNotNull(inputFile));
    } finally {
      if (mp4Muxer != null) {
        mp4Muxer.close();
      }
    }

    FakeExtractorOutput fakeExtractorOutput =
        TestUtil.extractAllSamplesFromFilePath(new Mp4Extractor(), checkNotNull(outputPath));
    DumpFileAsserts.assertOutput(
        context, fakeExtractorOutput, AndroidMuxerTestUtil.getExpectedDumpFilePath(inputFile));
  }

  @Test
  public void createMp4File_muxerNotClosed_createsPartiallyWrittenValidFile() throws IOException {
    Mp4Muxer mp4Muxer = new Mp4Muxer.Builder(checkNotNull(outputStream)).build();
    mp4Muxer.setModificationTime(/* timestampMs= */ 500_000_000L);
    feedInputDataToMuxer(mp4Muxer, H265_HDR10_MP4);

    // Muxer not closed.

    // Audio sample written = 192 out of 195.
    // Video sample written = 94 out of 127.
    // Output is still a valid MP4 file.
    FakeExtractorOutput fakeExtractorOutput =
        TestUtil.extractAllSamplesFromFilePath(new Mp4Extractor(), checkNotNull(outputPath));
    DumpFileAsserts.assertOutput(
        context,
        fakeExtractorOutput,
        AndroidMuxerTestUtil.getExpectedDumpFilePath(""partial_"" + H265_HDR10_MP4));
  }

  private void feedInputDataToMuxer(Mp4Muxer mp4Muxer, String inputFileName) throws IOException {
    MediaExtractor extractor = new MediaExtractor();
    extractor.setDataSource(
        context.getResources().getAssets().openFd(MP4_FILE_ASSET_DIRECTORY + inputFileName));

    List<Mp4Muxer.TrackToken> addedTracks = new ArrayList<>();
    int sortKey = 0;
    for (int i = 0; i < extractor.getTrackCount(); i++) {
      Mp4Muxer.TrackToken trackToken =
          mp4Muxer.addTrack(
              sortKey++, MediaFormatUtil.createFormatFromMediaFormat(extractor.getTrackFormat(i)));
      addedTracks.add(trackToken);
      extractor.selectTrack(i);
    }

    do {
      MediaCodec.BufferInfo bufferInfo = new MediaCodec.BufferInfo();
      bufferInfo.flags = extractor.getSampleFlags();
      bufferInfo.offset = 0;
      bufferInfo.presentationTimeUs = extractor.getSampleTime();
      int  [MASK]  = (int) extractor.getSampleSize();
      bufferInfo.size =  [MASK] ;

      ByteBuffer sampleBuffer = ByteBuffer.allocateDirect( [MASK] );
      extractor.readSampleData(sampleBuffer, /* offset= */ 0);

      sampleBuffer.rewind();

      mp4Muxer.writeSampleData(
          addedTracks.get(extractor.getSampleTrackIndex()), sampleBuffer, bufferInfo);
    } while (extractor.advance());

    extractor.release();
  }
}
","sampleSize
"
"/*
 * Copyright 2015 The Netty Project
 *
 * The Netty Project licenses this file to you under the Apache License,
 * version 2.0 (the ""License""); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
package io.netty.handler.codec.http;

import io.netty.handler.codec.http.HttpHeadersTestUtils.HeaderValue;
import io.netty.util.AsciiString;
import io.netty.util.internal.EmptyArrays;
import io.netty.util.internal.StringUtil;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;

import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import static io.netty.handler.codec.http.HttpHeaderNames.ACCEPT;
import static io.netty.handler.codec.http.HttpHeaderNames.CONNECTION;
import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;
import static io.netty.handler.codec.http.HttpHeaderValues.APPLICATION_JSON;
import static io.netty.handler.codec.http.HttpHeaderValues.CLOSE;
import static io.netty.handler.codec.http.HttpHeaderValues.ZERO;
import static io.netty.handler.codec.http.HttpHeadersTestUtils.of;
import static io.netty.util.AsciiString.contentEquals;
import static java.util.Arrays.asList;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

public class DefaultHttpHeadersTest {
    private static final CharSequence HEADER_NAME = ""testHeader"";
    private static final CharSequence ILLEGAL_VALUE = ""testHeader\r\nContent-Length:45\r\n\r\n"";

    @Test
    public void nullHeaderNameNotAllowed() {
        assertThrows(IllegalArgumentException.class, new Executable() {
            @Override
            public void execute() {
                new DefaultHttpHeaders().add(null, ""foo"");
            }
        });
    }

    @Test
    public void emptyHeaderNameNotAllowed() {
        assertThrows(IllegalArgumentException.class, new Executable() {
            @Override
            public void execute() {
                new DefaultHttpHeaders().add(StringUtil.EMPTY_STRING, ""foo"");
            }
        });
    }

    @Test
    public void keysShouldBeCaseInsensitive() {
        DefaultHttpHeaders headers = new DefaultHttpHeaders();
        headers.add(of(""Name""), of(""value1""));
        headers.add(of(""name""), of(""value2""));
        headers.add(of(""NAME""), of(""value3""));
        assertEquals(3, headers.size());

        List<String> values = asList(""value1"", ""value2"", ""value3"");

        assertEquals(values, headers.getAll(of(""NAME"")));
        assertEquals(values, headers.getAll(of(""name"")));
        assertEquals(values, headers.getAll(of(""Name"")));
        assertEquals(values, headers.getAll(of(""nAmE"")));
    }

    @Test
    public void keysShouldBeCaseInsensitiveInHeadersEquals() {
        DefaultHttpHeaders headers1 = new DefaultHttpHeaders();
        headers1.add(of(""name1""), asList(""value1"", ""value2"", ""value3""));
        headers1.add(of(""nAmE2""), of(""value4""));

        DefaultHttpHeaders headers2 = new DefaultHttpHeaders();
        headers2.add(of(""naMe1""), asList(""value1"", ""value2"", ""value3""));
        headers2.add(of(""NAME2""), of(""value4""));

        assertEquals(headers1, headers1);
        assertEquals(headers2, headers2);
        assertEquals(headers1, headers2);
        assertEquals(headers2, headers1);
        assertEquals(headers1.hashCode(), headers2.hashCode());
    }

    @Test
    public void testStringKeyRetrievedAsAsciiString() {
        final HttpHeaders headers = new DefaultHttpHeaders(false);

        // Test adding String key and retrieving it using a AsciiString key
        final String connection = ""keep-alive"";
        headers.add(of(""Connection""), connection);

        // Passes
        final String value = headers.getAsString(HttpHeaderNames.CONNECTION.toString());
        assertNotNull(value);
        assertEquals(connection, value);

        // Passes
        final String value2 = headers.getAsString(HttpHeaderNames.CONNECTION);
        assertNotNull(value2);
        assertEquals(connection, value2);
    }

    @Test
    public void testAsciiStringKeyRetrievedAsString() {
        final HttpHeaders headers = new DefaultHttpHeaders(false);

        // Test adding AsciiString key and retrieving it using a String key
        final String cacheControl = ""no-cache"";
        headers.add(HttpHeaderNames.CACHE_CONTROL, cacheControl);

        final String value = headers.getAsString(HttpHeaderNames.CACHE_CONTROL);
        assertNotNull(value);
        assertEquals(cacheControl, value);

        final String value2 = headers.getAsString(HttpHeaderNames.CACHE_CONTROL.toString());
        assertNotNull(value2);
        assertEquals(cacheControl, value2);
    }

    @Test
    public void testRemoveTransferEncodingIgnoreCase() {
        HttpMessage  [MASK]  = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
         [MASK] .headers().set(HttpHeaderNames.TRANSFER_ENCODING, ""Chunked"");
        assertFalse( [MASK] .headers().isEmpty());
        HttpUtil.setTransferEncodingChunked( [MASK] , false);
        assertTrue( [MASK] .headers().isEmpty());
    }

    // Test for https://github.com/netty/netty/issues/1690
    @Test
    public void testGetOperations() {
        HttpHeaders headers = new DefaultHttpHeaders();
        headers.add(of(""Foo""), of(""1""));
        headers.add(of(""Foo""), of(""2""));

        assertEquals(""1"", headers.get(of(""Foo"")));

        List<String> values = headers.getAll(of(""Foo""));
        assertEquals(2, values.size());
        assertEquals(""1"", values.get(0));
        assertEquals(""2"", values.get(1));
    }

    @Test
    public void testEqualsIgnoreCase() {
        assertThat(AsciiString.contentEqualsIgnoreCase(null, null), is(true));
        assertThat(AsciiString.contentEqualsIgnoreCase(null, ""foo""), is(false));
        assertThat(AsciiString.contentEqualsIgnoreCase(""bar"", null), is(false));
        assertThat(AsciiString.contentEqualsIgnoreCase(""FoO"", ""fOo""), is(true));
    }

    @Test
    public void testSetNullHeaderValueValidate() {
        final HttpHeaders headers = new DefaultHttpHeaders(true);
        assertThrows(NullPointerException.class, new Executable() {
            @Override
            public void execute() {
                headers.set(of(""test""), (CharSequence) null);
            }
        });
    }

    @Test
    public void testSetNullHeaderValueNotValidate() {
        final HttpHeaders headers = new DefaultHttpHeaders(false);
        assertThrows(NullPointerException.class, new Executable() {
            @Override
            public void execute() {
                headers.set(of(""test""), (CharSequence) null);
            }
        });
    }

    @Test
    public void addCharSequences() {
        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();
        headers.add(HEADER_NAME, HeaderValue.THREE.asList());
        assertDefaultValues(headers, HeaderValue.THREE);
    }

    @Test
    public void addIterable() {
        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();
        headers.add(HEADER_NAME, HeaderValue.THREE.asList());
        assertDefaultValues(headers, HeaderValue.THREE);
    }

    @Test
    public void addObjects() {
        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();
        headers.add(HEADER_NAME, HeaderValue.THREE.asList());
        assertDefaultValues(headers, HeaderValue.THREE);
    }

    @Test
    public void setCharSequences() {
        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();
        headers.set(HEADER_NAME, HeaderValue.THREE.asList());
        assertDefaultValues(headers, HeaderValue.THREE);
    }

    @Test
    public void setIterable() {
        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();
        headers.set(HEADER_NAME, HeaderValue.THREE.asList());
        assertDefaultValues(headers, HeaderValue.THREE);
    }

    @Test
    public void setObjectObjects() {
        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();
        headers.set(HEADER_NAME, HeaderValue.THREE.asList());
        assertDefaultValues(headers, HeaderValue.THREE);
    }

    @Test
    public void setObjectIterable() {
        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();
        headers.set(HEADER_NAME, HeaderValue.THREE.asList());
        assertDefaultValues(headers, HeaderValue.THREE);
    }

    @Test
    public void setCharSequenceValidatesValue() {
        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                headers.set(HEADER_NAME, ILLEGAL_VALUE);
            }
        });
        assertTrue(exception.getMessage().contains(HEADER_NAME));
    }

    @Test
    public void setIterableValidatesValue() {
        final DefaultHttpHeaders headers = newDefaultDefaultHttpHeaders();
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, new Executable() {
            @Override
            public void execute() throws Throwable {
                headers.set(HEADER_NAME, Collections.singleton(ILLEGAL_VALUE));
            }
        });
        assertTrue(exception.getMessage().contains(HEADER_NAME));
    }

    @Test
    public void toStringOnEmptyHeaders() {
        assertEquals(""DefaultHttpHeaders[]"", newDefaultDefaultHttpHeaders().toString());
    }

    @Test
    public void toStringOnSingleHeader() {
        assertEquals(""DefaultHttpHeaders[foo: bar]"", newDefaultDefaultHttpHeaders()
                .add(""foo"", ""bar"")
                .toString());
    }

    @Test
    public void toStringOnMultipleHeaders() {
        assertEquals(""DefaultHttpHeaders[foo: bar, baz: qix]"", newDefaultDefaultHttpHeaders()
                .add(""foo"", ""bar"")
                .add(""baz"", ""qix"")
                .toString());
    }

    @Test
    public void providesHeaderNamesAsArray() throws Exception {
        Set<String> nettyHeaders = new DefaultHttpHeaders()
                .add(HttpHeaderNames.CONTENT_LENGTH, 10)
                .names();

        String[] namesArray = nettyHeaders.toArray(EmptyArrays.EMPTY_STRINGS);
        assertArrayEquals(namesArray, new String[] { HttpHeaderNames.CONTENT_LENGTH.toString() });
    }

    @Test
    public void names() {
        HttpHeaders headers = new DefaultHttpHeaders(true)
                .add(ACCEPT, APPLICATION_JSON)
                .add(CONTENT_LENGTH, ZERO)
                .add(CONNECTION, CLOSE);
        assertFalse(headers.isEmpty());
        assertEquals(3, headers.size());
        Set<String> names = headers.names();
        assertEquals(3, names.size());
        assertTrue(names.contains(ACCEPT.toString()));
        assertTrue(names.contains(CONTENT_LENGTH.toString()));
        assertTrue(names.contains(CONNECTION.toString()));
    }

    @Test
    public void testContainsName() {
        HttpHeaders headers = new DefaultHttpHeaders(true)
                .add(CONTENT_LENGTH, ""36"");
        assertTrue(headers.contains(""Content-Length""));
        assertTrue(headers.contains(""content-length""));
        assertTrue(headers.contains(CONTENT_LENGTH));
        headers.remove(CONTENT_LENGTH);
        assertFalse(headers.contains(""Content-Length""));
        assertFalse(headers.contains(""content-length""));
        assertFalse(headers.contains(CONTENT_LENGTH));

        assertFalse(headers.contains(""non-existent-name""));
        assertFalse(headers.contains(new AsciiString(""non-existent-name"")));
    }

    private static void assertDefaultValues(final DefaultHttpHeaders headers, final HeaderValue headerValue) {
        assertTrue(contentEquals(headerValue.asList().get(0), headers.get(HEADER_NAME)));
        List<CharSequence> expected = headerValue.asList();
        List<String> actual = headers.getAll(HEADER_NAME);
        assertEquals(expected.size(), actual.size());
        Iterator<CharSequence> eItr = expected.iterator();
        Iterator<String> aItr = actual.iterator();
        while (eItr.hasNext()) {
            assertTrue(contentEquals(eItr.next(), aItr.next()));
        }
    }

    private static DefaultHttpHeaders newDefaultDefaultHttpHeaders() {
        return new DefaultHttpHeaders(true);
    }
}
","message
"
"/*
 * ProGuard -- shrinking, optimization, obfuscation, and preverification
 *             of Java bytecode.
 *
 * Copyright (c) 2002-2019 Guardsquare NV
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
package proguard.preverify;

import proguard.classfile.*;
import proguard.classfile.attribute.*;
import proguard.classfile.attribute.visitor.*;
import proguard.classfile.editor.CodeAttributeComposer;
import proguard.classfile.instruction.*;
import proguard.classfile.instruction.visitor.InstructionVisitor;
import proguard.classfile.util.SimplifiedVisitor;
import proguard.classfile.visitor.*;
import proguard.optimize.peephole.BranchTargetFinder;

/**
 * This AttributeVisitor inlines local subroutines (jsr/ret) in the code
 * attributes that it visits.
 *
 * @author Eric Lafortune
 */
public class CodeSubroutineInliner
extends      SimplifiedVisitor
implements   AttributeVisitor,
             InstructionVisitor,
             ExceptionInfoVisitor
{
    //*
    private static final boolean DEBUG = false;
    /*/
    private static       boolean DEBUG = System.getProperty(""csi"") != null;
    //*/

    private final BranchTargetFinder    branchTargetFinder    = new BranchTargetFinder();
    private final CodeAttributeComposer codeAttributeComposer = new CodeAttributeComposer(true, true, true);

    private ExceptionInfoVisitor subroutineExceptionInliner = this;
    private int                  clipStart                  = 0;
    private int                  clipEnd                    = Integer.MAX_VALUE;


    // Implementations for AttributeVisitor.

    public void visitAnyAttribute(Clazz clazz, Attribute attribute) {}


    public void visitCodeAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute)
    {
//        DEBUG =
//            clazz.getName().equals(""abc/Def"") &&
//            method.getName(clazz).equals(""abc"");
//        CodeAttributeComposer.DEBUG = DEBUG;

        // TODO: Remove this when the subroutine inliner has stabilized.
        // Catch any unexpected exceptions from the actual visiting method.
        try
        {
            // Process the code.
            visitCodeAttribute0(clazz, method, codeAttribute);
        }
        catch (RuntimeException ex)
        {
            System.err.println(""Unexpected error while inlining subroutines:"");
            System.err.println(""  Class       = [""+clazz.getName()+""]"");
            System.err.println(""  Method      = [""+method.getName(clazz)+method.getDescriptor(clazz)+""]"");
            System.err.println(""  Exception   = [""+ex.getClass().getName()+""] (""+ex.getMessage()+"")"");

            if (DEBUG)
            {
                method.accept(clazz, new ClassPrinter());
            }

            throw ex;
        }
    }


    public void visitCodeAttribute0(Clazz clazz, Method method, CodeAttribute codeAttribute)
    {
        branchTargetFinder.visitCodeAttribute(clazz, method, codeAttribute);

        // Don't bother if there aren't any subroutines anyway.
        if (!branchTargetFinder.containsSubroutines())
        {
            return;
        }

        if (DEBUG)
        {
            System.out.println(""SubroutineInliner: processing [""+clazz.getName()+"".""+method.getName(clazz)+method.getDescriptor(clazz)+""]"");
        }

        // Append the body of the code.
        codeAttributeComposer.reset();
        codeAttributeComposer.beginCodeFragment(codeAttribute.u4codeLength);

        // Copy the non-subroutine instructions.
        int  [MASK]   = 0;
        while ( [MASK]  < codeAttribute.u4codeLength)
        {
            Instruction instruction = InstructionFactory.create(codeAttribute.code,  [MASK] );
            int instructionLength = instruction.length( [MASK] );

            // Is this a returning subroutine?
            if (branchTargetFinder.isSubroutine( [MASK] ) &&
                branchTargetFinder.isSubroutineReturning( [MASK] ))
            {
                // Skip the subroutine.
                if (DEBUG)
                {
                    System.out.println(""  Skipping original subroutine instruction ""+instruction.toString( [MASK] ));
                }

                // Append a label at this  [MASK]  instead.
                codeAttributeComposer.appendLabel( [MASK] );
            }
            else
            {
                // Copy the instruction, inlining any subroutine call recursively.
                instruction.accept(clazz, method, codeAttribute,  [MASK] , this);
            }

             [MASK]  += instructionLength;
        }

        // Copy the exceptions. Note that exceptions with empty try blocks
        // are automatically removed.
        codeAttribute.exceptionsAccept(clazz,
                                       method,
                                       subroutineExceptionInliner);

        if (DEBUG)
        {
            System.out.println(""  Appending label after code at [""+ [MASK] +""]"");
        }

        // Append a label just after the code.
        codeAttributeComposer.appendLabel(codeAttribute.u4codeLength);

        // End and update the code attribute.
        codeAttributeComposer.endCodeFragment();
        codeAttributeComposer.visitCodeAttribute(clazz, method, codeAttribute);
    }


    /**
     * Appends the specified subroutine.
     */
    private void inlineSubroutine(Clazz         clazz,
                                  Method        method,
                                  CodeAttribute codeAttribute,
                                  int           subroutineInvocationOffset,
                                  int           subroutineStart)
    {
        int subroutineEnd = branchTargetFinder.subroutineEnd(subroutineStart);

        if (DEBUG)
        {
            System.out.println(""  Inlining subroutine [""+subroutineStart+"" -> ""+subroutineEnd+""] at [""+subroutineInvocationOffset+""]"");
        }

        // Don't go inlining exceptions that are already applicable to this
        // subroutine invocation.
        ExceptionInfoVisitor oldSubroutineExceptionInliner = subroutineExceptionInliner;
        int                  oldClipStart                  = clipStart;
        int                  oldClipEnd                    = clipEnd;

        subroutineExceptionInliner =
            new ExceptionExcludedOffsetFilter(subroutineInvocationOffset,
                                              subroutineExceptionInliner);
        clipStart = subroutineStart;
        clipEnd   = subroutineEnd;

        codeAttributeComposer.beginCodeFragment(codeAttribute.u4codeLength);

        // Copy the subroutine instructions, inlining any subroutine calls
        // recursively.
        codeAttribute.instructionsAccept(clazz,
                                         method,
                                         subroutineStart,
                                         subroutineEnd,
                                         this);

        if (DEBUG)
        {
            System.out.println(""    Appending label after inlined subroutine at [""+subroutineEnd+""]"");
        }

        // Append a label just after the code.
        codeAttributeComposer.appendLabel(subroutineEnd);

        // Inline the subroutine exceptions.
        codeAttribute.exceptionsAccept(clazz,
                                       method,
                                       subroutineStart,
                                       subroutineEnd,
                                       subroutineExceptionInliner);

        // We can again inline exceptions that are applicable to this
        // subroutine invocation.
        subroutineExceptionInliner = oldSubroutineExceptionInliner;
        clipStart                  = oldClipStart;
        clipEnd                    = oldClipEnd;

        codeAttributeComposer.endCodeFragment();
    }


    // Implementations for InstructionVisitor.

    public void visitAnyInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int  [MASK] , Instruction instruction)
    {
        if (branchTargetFinder.isSubroutineStart( [MASK] ))
        {
            if (DEBUG)
            {
                System.out.println(""    Replacing first subroutine instruction ""+instruction.toString( [MASK] )+"" by a label"");
            }

            // Append a label at this  [MASK]  instead of saving the subroutine
            // return address.
            codeAttributeComposer.appendLabel( [MASK] );
        }
        else
        {
            // Append the instruction.
            codeAttributeComposer.appendInstruction( [MASK] , instruction);
        }
    }


    public void visitVariableInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int  [MASK] , VariableInstruction variableInstruction)
    {
        byte opcode = variableInstruction.opcode;
        if (opcode == InstructionConstants.OP_RET)
        {
            // Is the return instruction the last instruction of the subroutine?
            if (branchTargetFinder.subroutineEnd( [MASK] ) ==  [MASK]  + variableInstruction.length( [MASK] ))
            {
                if (DEBUG)
                {
                    System.out.println(""    Replacing subroutine return at [""+ [MASK] +""] by a label"");
                }

                // Append a label at this  [MASK]  instead of the subroutine return.
                codeAttributeComposer.appendLabel( [MASK] );
            }
            else
            {
                if (DEBUG)
                {
                    System.out.println(""    Replacing subroutine return at [""+ [MASK] +""] by a simple branch"");
                }

                // Replace the instruction by a branch.
                Instruction replacementInstruction =
                    new BranchInstruction(InstructionConstants.OP_GOTO,
                                          branchTargetFinder.subroutineEnd( [MASK] ) -  [MASK] );

                codeAttributeComposer.appendInstruction( [MASK] , replacementInstruction);
            }
        }
        else if (branchTargetFinder.isSubroutineStart( [MASK] ))
        {
            if (DEBUG)
            {
                System.out.println(""    Replacing first subroutine instruction ""+variableInstruction.toString( [MASK] )+"" by a label"");
            }

            // Append a label at this  [MASK]  instead of saving the subroutine
            // return address.
            codeAttributeComposer.appendLabel( [MASK] );
        }
        else
        {
            // Append the instruction.
            codeAttributeComposer.appendInstruction( [MASK] , variableInstruction);
        }
    }


    public void visitBranchInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int  [MASK] , BranchInstruction branchInstruction)
    {
        byte opcode = branchInstruction.opcode;
        if (opcode == InstructionConstants.OP_JSR ||
            opcode == InstructionConstants.OP_JSR_W)
        {
            int branchOffset = branchInstruction.branchOffset;
            int branchTarget =  [MASK]  + branchOffset;

            // Is the subroutine ever returning?
            if (branchTargetFinder.isSubroutineReturning(branchTarget))
            {
                // Append a label at this  [MASK]  instead of the subroutine invocation.
                codeAttributeComposer.appendLabel( [MASK] );

                // Inline the invoked subroutine.
                inlineSubroutine(clazz,
                                 method,
                                 codeAttribute,
                                  [MASK] ,
                                 branchTarget);
            }
            else
            {
                if (DEBUG)
                {
                    System.out.println(""Replacing subroutine invocation at [""+ [MASK] +""] by a simple branch"");
                }

                // Replace the subroutine invocation by a simple branch.
                Instruction replacementInstruction =
                    new BranchInstruction(InstructionConstants.OP_GOTO,
                                          branchOffset);

                codeAttributeComposer.appendInstruction( [MASK] , replacementInstruction);
            }
        }
        else
        {
            // Append the instruction.
            codeAttributeComposer.appendInstruction( [MASK] , branchInstruction);
        }
    }


    // Implementations for ExceptionInfoVisitor.

    public void visitExceptionInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, ExceptionInfo exceptionInfo)
    {
        int startPC   = Math.max(exceptionInfo.u2startPC, clipStart);
        int endPC     = Math.min(exceptionInfo.u2endPC,   clipEnd);
        int handlerPC = exceptionInfo.u2handlerPC;
        int catchType = exceptionInfo.u2catchType;

        // Exclude any subroutine invocations that jump out of the try block,
        // by adding a try block before (and later on, after) each invocation.
        for (int  [MASK]  = startPC;  [MASK]  < endPC;  [MASK] ++)
        {
            if (branchTargetFinder.isSubroutineInvocation( [MASK] ))
            {
                Instruction instruction = InstructionFactory.create(codeAttribute.code,  [MASK] );
                int instructionLength = instruction.length( [MASK] );

                // Is it a subroutine invocation?
                if (!exceptionInfo.isApplicable( [MASK]  + ((BranchInstruction)instruction).branchOffset))
                {
                    if (DEBUG)
                    {
                        System.out.println(""  Appending extra exception [""+startPC+"" -> ""+ [MASK] +""] -> ""+handlerPC);
                    }

                    // Append a try block that ends before the subroutine invocation.
                    codeAttributeComposer.appendException(new ExceptionInfo(startPC,
                                                                             [MASK] ,
                                                                            handlerPC,
                                                                            catchType));

                    // The next try block will start after the subroutine invocation.
                    startPC =  [MASK]  + instructionLength;
                }
            }
        }

        if (DEBUG)
        {
            if (startPC == exceptionInfo.u2startPC &&
                endPC   == exceptionInfo.u2endPC)
            {
                System.out.println(""  Appending exception [""+startPC+"" -> ""+endPC+""] -> ""+handlerPC);
            }
            else
            {
                System.out.println(""  Appending clipped exception [""+exceptionInfo.u2startPC+"" -> ""+exceptionInfo.u2endPC+""] ~> [""+startPC+"" -> ""+endPC+""] -> ""+handlerPC);
            }
        }

        // Append the exception. Note that exceptions with empty try blocks
        // are automatically ignored.
        codeAttributeComposer.appendException(new ExceptionInfo(startPC,
                                                                endPC,
                                                                handlerPC,
                                                                catchType));
    }
}
","offset
"
"/*

Copyright 2010, Google Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above
copyright notice, this list of conditions and the following disclaimer
in the documentation and/or other materials provided with the
distribution.
    * Neither the name of Google Inc. nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,           
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY           
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

package com.google.refine;

import java.awt.Desktop;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.net.BindException;
import java.net.URI;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import javax.swing.JFrame;

import org.apache.commons.lang.SystemUtils;
import org.apache.log4j.Level;
import org.eclipse.jetty.server.HttpConfiguration;
import org.eclipse.jetty.server.HttpConnectionFactory;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.ServerConnector;
import org.eclipse.jetty.server.handler.StatisticsHandler;
import org.eclipse.jetty.servlet.ServletHolder;
import org.eclipse.jetty.webapp.WebAppContext;
import org.eclipse.jetty.util.Scanner;
import org.eclipse.jetty.util.thread.ThreadPool;
import com.google.util.threads.ThreadPoolExecutorAdapter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Main class for Refine server application. Starts an instance of the Jetty HTTP server / servlet container (inner
 * class Refine Server).
 */
public class Refine {

    static private final String DEFAULT_IFACE = ""127.0.0.1"";
    static private final int DEFAULT_PORT = 3333;

    static private int port;
    static private String host;
    static private String iface;

    final static Logger logger = LoggerFactory.getLogger(""refine"");

    public static void main(String[] args) throws Exception {

        // tell jetty to use SLF4J for logging instead of its own stuff
        System.setProperty(""VERBOSE"", ""false"");
        System.setProperty(""org.eclipse.jetty.log.class"", ""org.eclipse.jetty.util.log.Slf4jLog"");

        // tell macosx to keep the menu associated with the screen and what the app title is
        System.setProperty(""apple.laf.useScreenMenuBar"", ""true"");
        System.setProperty(""com.apple.eawt.CocoaComponent.CompatibilityMode"", ""false"");
        System.setProperty(""com.apple.mrj.application.apple.menu.about.name"", ""OpenRefine"");

        // tell the signpost library to log
        // System.setProperty(""debug"",""true"");

        // set the log verbosity level
        org.apache.log4j.Logger.getRootLogger().setLevel(Level.toLevel(Configurations.get(""refine.verbosity"", ""info"")));

        port = Configurations.getInteger(""refine.port"", DEFAULT_PORT);
        iface = Configurations.get(""refine.interface"", DEFAULT_IFACE);
        host = Configurations.get(""refine.host"", iface);
        if (""0.0.0.0"".equals(host)) {
            host = ""*"";
        }

        System.setProperty(""refine.display.new.version.notice"", Configurations.get(""refine.display.new.version.notice"", ""true""));
        Refine refine = new Refine();

        refine.init(args);
    }

    public void init(String[] args) throws Exception {

        RefineServer server = new RefineServer();
        server.init(iface, port, host);

        boolean headless = Configurations.getBoolean(""refine.headless"", false);
        if (headless) {
            System.setProperty(""java.awt.headless"", ""true"");
            logger.info(""Running in headless mode"");
        } else {
            try {
                RefineClient client = new RefineClient();
                if (""*"".equals(host)) {
                    if (""0.0.0.0"".equals(iface)) {
                        logger.warn(""No refine.host specified while binding to interface 0.0.0.0, guessing localhost."");
                        client.init(""localhost"", port);
                    } else {
                        client.init(iface, port);
                    }
                } else {
                    client.init(host, port);
                }
            } catch (Exception e) {
                logger.warn(""Sorry, some error prevented us from launching the browser for you.\n\n Point your browser to http://"" + host
                        + "":"" + port + ""/ to start using Refine."");
            }
        }

        // hook up the signal handlers
        Runtime.getRuntime().addShutdownHook(
                new Thread(new ShutdownSignalHandler(server)));

        server.join();
    }
}

/* -------------- Refine Server ----------------- */

class RefineServer extends Server {

    final static Logger logger = LoggerFactory.getLogger(""refine_server"");

    public RefineServer() {
        super(createThreadPool());
    }

    private static ThreadPool createThreadPool() {
        int maxThreads = Configurations.getInteger(""refine.queue.size"", 30);
        int maxQueue = Configurations.getInteger(""refine.queue.max_size"", 300);
        long keepAliveTime = Configurations.getInteger(""refine.queue.idle_time"", 60);
        LinkedBlockingQueue<Runnable> queue = new LinkedBlockingQueue<Runnable>(maxQueue);
        return new ThreadPoolExecutorAdapter(new ThreadPoolExecutor(maxThreads, maxQueue, keepAliveTime, TimeUnit.SECONDS, queue));
    }

    private ThreadPoolExecutor threadPool;

    public void init(String iface, int port, String host) throws Exception {
        logger.info(""Starting Server bound to '"" + iface + "":"" + port + ""'"");

        String memory = Configurations.get(""refine.memory"");
        if (memory != null) {
            logger.info(""refine.memory size: "" + memory + "" JVM Max heap: "" + Runtime.getRuntime().maxMemory() + "" bytes"");
        }

        HttpConfiguration httpConfig = new HttpConfiguration();
        httpConfig.setSendServerVersion(false);
        HttpConnectionFactory httpFactory = new HttpConnectionFactory(httpConfig);
        ServerConnector connector = new ServerConnector(this, httpFactory);
        connector.setPort(port);
        connector.setHost(iface);
        connector.setIdleTimeout(Configurations.getInteger(""server.connection.max_idle_time"", 60000));
        this.addConnector(connector);

        File webapp = new File(Configurations.get(""refine.webapp"", ""main/webapp""));

        if (!isWebapp(webapp)) {
            webapp = new File(""main/webapp"");
            if (!isWebapp(webapp)) {
                webapp = new File(""webapp"");
                if (!isWebapp(webapp)) {
                    logger.warn(""Warning: Failed to find web application at '"" + webapp.getAbsolutePath() + ""'"");
                    System.exit(-1);
                }
            }
        }

        final String contextPath = Configurations.get(""refine.context_path"", ""/"");
        final int maxFormContentSize = Configurations.getInteger(""refine.max_form_content_size"", 64 * 1048576); // 64MB

        logger.info(""Initializing context: '"" + contextPath + ""' from '"" + webapp.getAbsolutePath() + ""'"");
        WebAppContext context = new WebAppContext(webapp.getAbsolutePath(), contextPath);
        context.setMaxFormContentSize(maxFormContentSize);

        if (""*"".equals(host)) {
            this.setHandler(context);
        } else {
            ValidateHostHandler wrapper = new ValidateHostHandler(host);
            wrapper.setHandler(context);
            this.setHandler(wrapper);
        }

        this.setStopAtShutdown(true);
        StatisticsHandler handler = new StatisticsHandler();
        handler.setServer(this);
        handler.setHandler(this.getHandler());
        this.addBean(handler);
        // Tell the server we want to try and shutdown gracefully
        // this means that the server will stop accepting new connections
        // right away but it will continue to process the ones that
        // are in execution for the given timeout before attempting to stop
        // NOTE: this is *not* a blocking method, it just sets a parameter
        // that _server.stop() will rely on
        this.setStopTimeout(30000);

        // Enable context autoreloading
        if (Configurations.getBoolean(""refine.autoreload"", false)) {
            scanForUpdates(webapp, context);
        }

        // start the server
        try {
            this.start();
        } catch (BindException e) {
            logger.error(""Failed to start server - is there another copy running already on this port/address?"");
            throw e;
        }

        configure(context);
    }

    @Override
    protected void doStop() throws Exception {
        try {
            // shutdown our scheduled tasks first, if any
            if (threadPool != null) {
                threadPool.shutdown();
            }
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            // stop current thread
            Thread.currentThread().interrupt();
        }
        // then let the parent stop
        super.doStop();
    }

    static private boolean isWebapp(File dir) {
        if (dir == null) {
            return false;
        }
        if (!dir.exists() || !dir.canRead()) {
            return false;
        }
        File webXml = new File(dir, ""WEB-INF/web.xml"");
        return webXml.exists() && webXml.canRead();
    }

    static private void scanForUpdates(final File contextRoot, final WebAppContext context) {
        List<File> scanList = new ArrayList<File>();

        scanList.add(new File(contextRoot, ""WEB-INF/web.xml""));
        findFiles("".class"", new File(contextRoot, ""WEB-INF/classes""), scanList);
        findFiles("".jar"", new File(contextRoot, ""WEB-INF/lib""), scanList);

        logger.info(""Starting autoreloading scanner... "");

        Scanner scanner = new Scanner();
        scanner.setScanInterval(Configurations.getInteger(""refine.scanner.period"", 1));
        scanner.setScanDirs(scanList);
        scanner.setReportExistingFilesOnStartup(false);

        scanner.addListener(new Scanner.BulkListener() {

            @Override
            public void filesChanged(@SuppressWarnings(""rawtypes"") List changedFiles) {
                try {
                    logger.info(""Stopping context: "" + contextRoot.getAbsolutePath());
                    context.stop();

                    logger.info(""Starting context: "" + contextRoot.getAbsolutePath());
                    context.start();

                    configure(context);
                } catch (Exception ex) {
                    throw new RuntimeException(ex);
                }
            }
        });

        try {
            scanner.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    static private void findFiles(final String extension, File baseDir, final Collection<File> found) {
        baseDir.listFiles(new FileFilter() {

            @Override
            public boolean accept(File pathname) {
                if (pathname.isDirectory()) {
                    findFiles(extension, pathname, found);
                } else if (pathname.getName().endsWith(extension)) {
                    found.add(pathname);
                }
                return false;
            }
        });
    }

    // inject configuration parameters in the servlets
    // NOTE: this is done *after* starting the server because jetty might override the init
    // parameters if we set them in the webapp context upon reading the web.xml file

    static private void configure(WebAppContext context) throws Exception {
        ServletHolder servlet = context.getServletHandler().getServlet(""refine"");
        if (servlet != null) {
            servlet.setInitParameter(""refine.data"", getDataDir());
            servlet.setInitParameter(""butterfly.modules.path"", getDataDir() + ""/extensions"");
            servlet.setInitParameter(""refine.autosave"", Configurations.get(""refine.autosave"", ""5"")); // default: 5
                                                                                                     // minutes
            servlet.setInitOrder(1);
            servlet.doStart();
        }
    }

    static private String getDataDir() {
        String data_dir = Configurations.get(""refine.data_dir"");
        if (data_dir != null) {
            return data_dir;
        }

        File dataDir = null;
        File grefineDir = null;
        File gridworksDir = null;

        String os = System.getProperty(""os.name"").toLowerCase();
        if (os.contains(""windows"")) {
            File parentDir = null;
            String appData = System.getenv(""APPDATA"");
            if (appData != null && appData.length() > 0) {
                // e.g., C:\Users\[userid]\AppData\Roaming
                parentDir = new File(appData);
            } else {
                // TODO migrate to System.getProperty(""user.home"")?
                String userProfile = System.getProperty(""user.home"");
                if (userProfile != null && userProfile.length() > 0) {
                    // e.g., C:\Users\[userid]
                    parentDir = new File(userProfile);
                }
            }

            if (parentDir == null) {
                parentDir = new File(""."");
            }

            dataDir = new File(parentDir, ""OpenRefine"");
            grefineDir = new File(new File(parentDir, ""Google""), ""Refine"");
            gridworksDir = new File(parentDir, ""Gridworks"");
        } else if (os.contains(""os x"")) {
            // on macosx, use ""~/Library/Application Support""
            String home = System.getProperty(""user.home"");

            String  [MASK]  = (home != null) ? home + ""/Library/Application Support/OpenRefine"" : "".openrefine"";
            dataDir = new File( [MASK] );

            String grefine_home = (home != null) ? home + ""/Library/Application Support/Google/Refine"" : "".google-refine"";
            grefineDir = new File(grefine_home);

            String gridworks_home = (home != null) ? home + ""/Library/Application Support/Gridworks"" : "".gridworks"";
            gridworksDir = new File(gridworks_home);
        } else { // most likely a UNIX flavor
            // start with the XDG environment
            // see http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
            String  [MASK]  = System.getenv(""XDG_DATA_HOME"");
            if ( [MASK]  == null) { // if not found, default back to ~/.local/share
                String home = System.getProperty(""user.home"");
                if (home == null) {
                    home = ""."";
                }
                 [MASK]  = home + ""/.local/share"";
            }

            dataDir = new File( [MASK]  + ""/openrefine"");
            grefineDir = new File( [MASK]  + ""/google/refine"");
            gridworksDir = new File( [MASK]  + ""/gridworks"");
        }

        // If refine data dir doesn't exist, try to find and move Google Refine or Gridworks data dir over
        if (!dataDir.exists()) {
            if (grefineDir.exists()) {
                if (gridworksDir.exists()) {
                    logger.warn(""Found both Gridworks: "" + gridworksDir
                            + "" & Googld Refine dirs "" + grefineDir);
                }
                if (grefineDir.renameTo(dataDir)) {
                    logger.info(""Renamed Google Refine directory "" + grefineDir
                            + "" to "" + dataDir);
                } else {
                    logger.error(""FAILED to rename Google Refine directory ""
                            + grefineDir
                            + "" to "" + dataDir);
                }
            } else if (gridworksDir.exists()) {
                if (gridworksDir.renameTo(dataDir)) {
                    logger.info(""Renamed Gridworks directory "" + gridworksDir
                            + "" to "" + dataDir);
                } else {
                    logger.error(""FAILED to rename Gridworks directory ""
                            + gridworksDir
                            + "" to "" + dataDir);
                }
            }
        }

        // Either rename failed or nothing to rename - create a new one
        if (!dataDir.exists()) {
            logger.info(""Creating new workspace directory "" + dataDir);
            if (!dataDir.mkdirs()) {
                logger.error(""FAILED to create new workspace directory "" + dataDir);
            }
        }

        return dataDir.getAbsolutePath();
    }

    /**
     * For Windows file paths that contain user IDs with non ASCII characters, those characters might get replaced with
     * ?. We need to use the environment APPDATA value to substitute back the original user ID.
     */
    static private String fixWindowsUnicodePath(String path) {
        int q = path.indexOf('?');
        if (q < 0) {
            return path;
        }
        int pathSep = path.indexOf(File.separatorChar, q);

        String goodPath = System.getenv(""APPDATA"");
        if (goodPath == null || goodPath.length() == 0) {
            goodPath = System.getenv(""USERPROFILE"");
            if (!goodPath.endsWith(File.separator)) {
                goodPath = goodPath + File.separator;
            }
        }

        int goodPathSep = goodPath.indexOf(File.separatorChar, q);

        return path.substring(0, q) + goodPath.substring(q, goodPathSep) + path.substring(pathSep);
    }

}

/* -------------- Refine Client ----------------- */

class RefineClient extends JFrame implements ActionListener {

    private static final long serialVersionUID = 7886547342175227132L;

    final static Logger logger = LoggerFactory.getLogger(""refine-client"");

    private URI uri;

    public void init(String host, int port) throws Exception {
        uri = new URI(""http://"" + host + "":"" + port + ""/"");
        openBrowser();
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        String item = e.getActionCommand();
        if (item.startsWith(""Open"")) {
            openBrowser();
        }
    }

    private void openBrowser() {
        if (!Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
            try {
                openBrowserFallback();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        } else {
            try {
                Desktop.getDesktop().browse(uri);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }

    private void openBrowserFallback() throws IOException {
        Runtime rt = Runtime.getRuntime();

        if (SystemUtils.IS_OS_WINDOWS) {
            rt.exec(new String[] { ""rundll32 "", ""url.dll,FileProtocolHandler "", String.valueOf(uri) });
        } else if (SystemUtils.IS_OS_MAC_OSX) {
            rt.exec(new String[] { ""open "", String.valueOf(uri) });
        } else if (SystemUtils.IS_OS_LINUX) {
            rt.exec(new String[] { ""xdg-open"", String.valueOf(uri) });
        } else {
            logger.warn(""Java Desktop class not supported on this platform. Please open %s in your browser"", uri.toString());
        }
    }
}

class ShutdownSignalHandler implements Runnable {

    private Server _server;

    public ShutdownSignalHandler(Server server) {
        this._server = server;
    }

    @Override
    public void run() {

        try {
            _server.stop();
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(1);
        }
    }

}
","data_home
"
"/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.tools.particleeditor;

import java.awt.FileDialog;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.File;

import javax.swing.ButtonGroup;
import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.ListSelectionModel;

import com.badlogic.gdx.graphics.g2d.ParticleEmitter;
import com.badlogic.gdx.graphics.g2d.ParticleEmitter.SpriteMode;
import com.badlogic.gdx.utils.Array;

class ImagePanel extends EditorPanel {
	JPanel imagesPanel;
	JList imageList;
	DefaultListModel<String> imageListModel;
	String lastDir;

	public ImagePanel (final ParticleEditor editor, String name, String description) {
		super(null, name, description);
		JPanel contentPanel = getContentPanel();
		{
			JPanel buttonsPanel = new JPanel(new GridLayout(3, 1));
			contentPanel.add(buttonsPanel, new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST,
				GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
			JButton addButton = new JButton(""Add"");
			buttonsPanel.add(addButton);
			addButton.addActionListener(new ActionListener() {
				public void actionPerformed (ActionEvent event) {
					FileDialog dialog = new FileDialog(editor, ""Open Image"", FileDialog.LOAD);
					if (lastDir != null) dialog.setDirectory(lastDir);
					dialog.setMultipleMode(true);
					dialog.setVisible(true);
					final File[] files = dialog.getFiles();
					final String dir = dialog.getDirectory();
					if (dir == null || files == null) return;
					lastDir = dir;
					final ParticleEmitter emitter = editor.getEmitter();
					for (File file : files) {
						emitter.getImagePaths().add(file.getAbsolutePath());
					}
					emitter.getSprites().clear();
					updateImageList(emitter.getImagePaths());
				}
			});
			JButton defaultButton = new JButton(""Default"");
			buttonsPanel.add(defaultButton);
			defaultButton.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed (ActionEvent e) {
					final ParticleEmitter emitter = editor.getEmitter();
					emitter.setImagePaths(new Array<String>(new String[] {ParticleEditor.DEFAULT_PARTICLE}));
					emitter.getSprites().clear();
					updateImageList(emitter.getImagePaths());
				}
			});
			JButton defaultPremultButton = new JButton(""Default (Premultiplied Alpha)"");
			buttonsPanel.add(defaultPremultButton);
			defaultPremultButton.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed (ActionEvent e) {
					final ParticleEmitter emitter = editor.getEmitter();
					emitter.setImagePaths(new Array<String>(new String[] {ParticleEditor.DEFAULT_PREMULT_PARTICLE}));
					emitter.getSprites().clear();
					updateImageList(emitter.getImagePaths());
				}
			});
		}
		{
			JPanel modesPanel = new JPanel(new GridLayout(4, 1));
			contentPanel.add(modesPanel, new GridBagConstraints(1, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST,
				GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
			JLabel label = new JLabel(""Sprite mode:"");
			modesPanel.add(label);
			ButtonGroup checkboxGroup = new ButtonGroup();
			JRadioButton singleCheckbox = new JRadioButton(""Single"", editor.getEmitter().getSpriteMode() == SpriteMode.single);
			modesPanel.add(singleCheckbox);
			checkboxGroup.add(singleCheckbox);
			singleCheckbox.addItemListener(new ItemListener() {
				@Override
				public void itemStateChanged (ItemEvent e) {
					if (e.getStateChange() == ItemEvent.SELECTED) {
						editor.getEmitter().setSpriteMode(SpriteMode.single);
					}
				}
			});
			JRadioButton randomCheckbox = new JRadioButton(""Random"", editor.getEmitter().getSpriteMode() == SpriteMode.random);
			modesPanel.add(randomCheckbox);
			checkboxGroup.add(randomCheckbox);
			randomCheckbox.addItemListener(new ItemListener() {
				@Override
				public void itemStateChanged (ItemEvent e) {
					if (e.getStateChange() == ItemEvent.SELECTED) {
						editor.getEmitter().setSpriteMode(SpriteMode.random);
					}
				}
			});
			JRadioButton animatedCheckbox = new JRadioButton(""Animated"", editor.getEmitter().getSpriteMode() == SpriteMode.animated);
			modesPanel.add(animatedCheckbox);
			checkboxGroup.add(animatedCheckbox);
			animatedCheckbox.addItemListener(new ItemListener() {
				@Override
				public void itemStateChanged (ItemEvent e) {
					if (e.getStateChange() == ItemEvent.SELECTED) {
						editor.getEmitter().setSpriteMode(SpriteMode.animated);
					}
				}
			});
		}
		{
			imagesPanel = new JPanel(new GridBagLayout());
			contentPanel.add(imagesPanel, new GridBagConstraints(2, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST,
				GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
			imageListModel = new DefaultListModel<String>();
			imageList = new JList<String>(imageListModel);
			imageList.setFixedCellWidth(250);
			imageList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
			imagesPanel.add(imageList, new GridBagConstraints(0, 0, 1, 3, 0, 0, GridBagConstraints.NORTHWEST,
				GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
			JButton upButton = new JButton(""\u2191"");
			imagesPanel.add(upButton, new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE,
				new Insets(0, 0, 0, 0), 0, 0));
			upButton.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed (ActionEvent e) {
					int index = imageList.getSelectedIndex();
					if (index <= 0) return;
					final ParticleEmitter emitter = editor.getEmitter();
					String imagePath = emitter.getImagePaths().removeIndex(index);
					emitter.getImagePaths().insert(index - 1, imagePath);
					emitter.getSprites().clear();
					updateImageList(emitter.getImagePaths());
					imageList.setSelectedIndex(index - 1);
				}
			});
			JButton downButton = new JButton(""\u2193"");
			imagesPanel.add(downButton, new GridBagConstraints(1, 1, 1, 1, 0, 0, GridBagConstraints.NORTHWEST,
				GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
			downButton.addActionListener(new ActionListener() {
				@Override
				public void actionPerformed (ActionEvent e) {
					int index = imageList.getSelectedIndex();
					if (index < 0 || index >= imageList.getModel().getSize() - 1) return;
					final ParticleEmitter emitter = editor.getEmitter();
					String imagePath = emitter.getImagePaths().removeIndex(index);
					emitter.getImagePaths().insert(index + 1, imagePath);
					emitter.getSprites().clear();
					updateImageList(emitter.getImagePaths());
					imageList.setSelectedIndex(index + 1);
				}
			});
			JButton  [MASK]  = new JButton(""X"");
			imagesPanel.add( [MASK] , new GridBagConstraints(1, 2, 1, 1, 0, 0, GridBagConstraints.NORTHWEST,
				GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));
			 [MASK] .addActionListener(new ActionListener() {
				@Override
				public void actionPerformed (ActionEvent e) {
					int index = imageList.getSelectedIndex();
					if (index < 0) return;
					final ParticleEmitter emitter = editor.getEmitter();
					Array<String> imagePaths = emitter.getImagePaths();
					imagePaths.removeIndex(index);
					if (imagePaths.size == 0) imagePaths.add(ParticleEditor.DEFAULT_PARTICLE);
					emitter.getSprites().clear();
					updateImageList(imagePaths);
				}
			});
		}
		updateImageList(editor.getEmitter().getImagePaths());
	}

	public void updateImageList (Array<String> imagePaths) {
		if (imagePaths != null && imagePaths.size > 0) {
			imagesPanel.setVisible(true);
			imageListModel.removeAllElements();
			for (String imagePath : imagePaths) {
				imageListModel.addElement(new File(imagePath).getName());
			}
		} else {
			imagesPanel.setVisible(false);
		}
		revalidate();
	}
}
","removeButton
"
"/*
 * Copyright (c) 2016 Mockito contributors
 * This program is made available under the terms of the MIT License.
 */
package org.mockito.internal.creation.bytebuddy;

import static net.bytebuddy.matcher.ElementMatchers.isVisibleTo;
import static net.bytebuddy.matcher.ElementMatchers.isConstructor;
import static net.bytebuddy.matcher.ElementMatchers.isStatic;
import static net.bytebuddy.matcher.ElementMatchers.not;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.ref.SoftReference;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.concurrent.Callable;
import java.util.function.Predicate;

import net.bytebuddy.ClassFileVersion;
import net.bytebuddy.asm.Advice;
import net.bytebuddy.asm.AsmVisitorWrapper;
import net.bytebuddy.description.field.FieldDescription;
import net.bytebuddy.description.field.FieldList;
import net.bytebuddy.description.method.MethodDescription;
import net.bytebuddy.description.method.MethodList;
import net.bytebuddy.description.method.ParameterDescription;
import net.bytebuddy.description.type.TypeDefinition;
import net.bytebuddy.description.type.TypeDescription;
import net.bytebuddy.dynamic.scaffold.MethodGraph;
import net.bytebuddy.implementation.Implementation;
import net.bytebuddy.implementation.bind.annotation.Argument;
import net.bytebuddy.implementation.bind.annotation.This;
import net.bytebuddy.implementation.bytecode.StackSize;
import net.bytebuddy.implementation.bytecode.assign.Assigner;
import net.bytebuddy.jar.asm.Label;
import net.bytebuddy.jar.asm.MethodVisitor;
import net.bytebuddy.jar.asm.Opcodes;
import net.bytebuddy.jar.asm.Type;
import net.bytebuddy.pool.TypePool;
import net.bytebuddy.utility.OpenedClassReader;

import org.mockito.exceptions.base.MockitoException;
import org.mockito.internal.configuration.plugins.Plugins;
import org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher;
import org.mockito.internal.debugging.LocationFactory;
import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
import org.mockito.internal.invocation.RealMethod;
import org.mockito.internal.invocation.SerializableMethod;
import org.mockito.internal.invocation.mockref.MockReference;
import org.mockito.internal.invocation.mockref.MockWeakReference;
import org.mockito.internal.util.concurrent.DetachedThreadLocal;
import org.mockito.internal.util.concurrent.WeakConcurrentMap;
import org.mockito.plugins.MemberAccessor;

public class MockMethodAdvice extends MockMethodDispatcher {

    private final WeakConcurrentMap<Object, MockMethodInterceptor> interceptors;
    private final DetachedThreadLocal<Map<Class<?>, MockMethodInterceptor>> mockedStatics;

    private final String identifier;

    private final SelfCallInfo selfCallInfo = new SelfCallInfo();
    private final MethodGraph.Compiler compiler = MethodGraph.Compiler.Default.forJavaHierarchy();
    private final WeakConcurrentMap<Class<?>, SoftReference<MethodGraph>> graphs =
            new WeakConcurrentMap.WithInlinedExpunction<>();

    private final Predicate<Class<?>> isMockConstruction;
    private final ConstructionCallback onConstruction;

    public MockMethodAdvice(
            WeakConcurrentMap<Object, MockMethodInterceptor> interceptors,
            DetachedThreadLocal<Map<Class<?>, MockMethodInterceptor>> mockedStatics,
            String identifier,
            Predicate<Class<?>> isMockConstruction,
            ConstructionCallback onConstruction) {
        this.interceptors = interceptors;
        this.mockedStatics = mockedStatics;
        this.onConstruction = onConstruction;
        this.identifier = identifier;
        this.isMockConstruction = isMockConstruction;
    }

    @SuppressWarnings(""unused"")
    @Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)
    private static Callable<?> enter(
            @Identifier String identifier,
            @Advice.This Object mock,
            @Advice.Origin Method origin,
            @Advice.AllArguments Object[] arguments)
            throws Throwable {
        MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, mock);
        if (dispatcher == null
                || !dispatcher.isMocked(mock)
                || dispatcher.isOverridden(mock, origin)) {
            return null;
        } else {
            return dispatcher.handle(mock, origin, arguments);
        }
    }

    @SuppressWarnings({""unused"", ""UnusedAssignment""})
    @Advice.OnMethodExit
    private static void exit(
            @Advice.Return(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object  [MASK] ,
            @Advice.Enter Callable<?> mocked)
            throws Throwable {
        if (mocked != null) {
             [MASK]  = mocked.call();
        }
    }

    @Override
    public Callable<?> handle(Object instance, Method origin, Object[] arguments) throws Throwable {
        MockMethodInterceptor interceptor = interceptors.get(instance);
        if (interceptor == null) {
            return null;
        }
        RealMethod realMethod;
        if (instance instanceof Serializable) {
            realMethod = new SerializableRealMethodCall(identifier, origin, instance, arguments);
        } else {
            realMethod = new RealMethodCall(selfCallInfo, origin, instance, arguments);
        }
        return new ReturnValueWrapper(
                interceptor.doIntercept(
                        instance, origin, arguments, realMethod, LocationFactory.create(true)));
    }

    @Override
    public Callable<?> handleStatic(Class<?> type, Method origin, Object[] arguments)
            throws Throwable {
        Map<Class<?>, MockMethodInterceptor> interceptors = mockedStatics.get();
        if (interceptors == null || !interceptors.containsKey(type)) {
            return null;
        }
        return new ReturnValueWrapper(
                interceptors
                        .get(type)
                        .doIntercept(
                                type,
                                origin,
                                arguments,
                                new StaticMethodCall(selfCallInfo, type, origin, arguments),
                                LocationFactory.create(true)));
    }

    @Override
    public Object handleConstruction(
            Class<?> type, Object object, Object[] arguments, String[] parameterTypeNames) {
        return onConstruction.apply(type, object, arguments, parameterTypeNames);
    }

    @Override
    public boolean isMock(Object instance) {
        // We need to exclude 'interceptors.target' explicitly to avoid a recursive check on whether
        // the map is a mock object what requires reading from the map.
        return instance != interceptors.target && interceptors.containsKey(instance);
    }

    @Override
    public boolean isMocked(Object instance) {
        return isMock(instance) && selfCallInfo.checkSelfCall(instance);
    }

    @Override
    public boolean isMockedStatic(Class<?> type) {
        if (!selfCallInfo.checkSelfCall(type)) {
            return false;
        }
        Map<Class<?>, ?> interceptors = mockedStatics.get();
        return interceptors != null && interceptors.containsKey(type);
    }

    @Override
    public boolean isOverridden(Object instance, Method origin) {
        SoftReference<MethodGraph> reference = graphs.get(instance.getClass());
        MethodGraph methodGraph = reference == null ? null : reference.get();
        if (methodGraph == null) {
            methodGraph =
                    compiler.compile(
                            (TypeDefinition) TypeDescription.ForLoadedType.of(instance.getClass()));
            graphs.put(instance.getClass(), new SoftReference<>(methodGraph));
        }
        MethodGraph.Node node =
                methodGraph.locate(
                        new MethodDescription.ForLoadedMethod(origin).asSignatureToken());
        return !node.getSort().isResolved()
                || !node.getRepresentative()
                        .asDefined()
                        .getDeclaringType()
                        .represents(origin.getDeclaringClass());
    }

    @Override
    public boolean isConstructorMock(Class<?> type) {
        return isMockConstruction.test(type);
    }

    private static class RealMethodCall implements RealMethod {

        private final SelfCallInfo selfCallInfo;

        private final Method origin;

        private final MockWeakReference<Object> instanceRef;

        private final Object[] arguments;

        private RealMethodCall(
                SelfCallInfo selfCallInfo, Method origin, Object instance, Object[] arguments) {
            this.selfCallInfo = selfCallInfo;
            this.origin = origin;
            this.instanceRef = new MockWeakReference<>(instance);
            this.arguments = arguments;
        }

        @Override
        public boolean isInvokable() {
            return true;
        }

        @Override
        public Object invoke() throws Throwable {
            selfCallInfo.set(instanceRef.get());
            return tryInvoke(origin, instanceRef.get(), arguments);
        }
    }

    private static class SerializableRealMethodCall implements RealMethod {

        private final String identifier;

        private final SerializableMethod origin;

        private final MockReference<Object> instanceRef;

        private final Object[] arguments;

        private SerializableRealMethodCall(
                String identifier, Method origin, Object instance, Object[] arguments) {
            this.origin = new SerializableMethod(origin);
            this.identifier = identifier;
            this.instanceRef = new MockWeakReference<>(instance);
            this.arguments = arguments;
        }

        @Override
        public boolean isInvokable() {
            return true;
        }

        @Override
        public Object invoke() throws Throwable {
            Method method = origin.getJavaMethod();
            MockMethodDispatcher mockMethodDispatcher =
                    MockMethodDispatcher.get(identifier, instanceRef.get());
            if (!(mockMethodDispatcher instanceof MockMethodAdvice)) {
                throw new MockitoException(""Unexpected dispatcher for advice-based super call"");
            }
            Object previous =
                    ((MockMethodAdvice) mockMethodDispatcher)
                            .selfCallInfo.replace(instanceRef.get());
            try {
                return tryInvoke(method, instanceRef.get(), arguments);
            } finally {
                ((MockMethodAdvice) mockMethodDispatcher).selfCallInfo.set(previous);
            }
        }
    }

    private static class StaticMethodCall implements RealMethod {

        private final SelfCallInfo selfCallInfo;

        private final Class<?> type;

        private final Method origin;

        private final Object[] arguments;

        private StaticMethodCall(
                SelfCallInfo selfCallInfo, Class<?> type, Method origin, Object[] arguments) {
            this.selfCallInfo = selfCallInfo;
            this.type = type;
            this.origin = origin;
            this.arguments = arguments;
        }

        @Override
        public boolean isInvokable() {
            return true;
        }

        @Override
        public Object invoke() throws Throwable {
            selfCallInfo.set(type);
            return tryInvoke(origin, null, arguments);
        }
    }

    private static Object tryInvoke(Method origin, Object instance, Object[] arguments)
            throws Throwable {
        MemberAccessor accessor = Plugins.getMemberAccessor();
        try {
            return accessor.invoke(origin, instance, arguments);
        } catch (InvocationTargetException exception) {
            Throwable cause = exception.getCause();
            new ConditionalStackTraceFilter()
                    .filter(removeRecursiveCalls(cause, origin.getDeclaringClass()));
            throw cause;
        }
    }

    static Throwable removeRecursiveCalls(final Throwable cause, final Class<?> declaringClass) {
        final List<String> uniqueStackTraceItems = new ArrayList<>();
        final List<Integer> indexesToBeRemoved = new ArrayList<>();
        for (StackTraceElement element : cause.getStackTrace()) {
            final String key = element.getClassName() + element.getLineNumber();
            final int elementIndex = uniqueStackTraceItems.lastIndexOf(key);
            uniqueStackTraceItems.add(key);

            if (elementIndex > -1 && declaringClass.getName().equals(element.getClassName())) {
                indexesToBeRemoved.add(elementIndex);
            }
        }
        final List<StackTraceElement> adjustedList =
                new ArrayList<>(Arrays.asList(cause.getStackTrace()));
        indexesToBeRemoved.stream()
                .sorted(Comparator.reverseOrder())
                .mapToInt(Integer::intValue)
                .forEach(adjustedList::remove);
        cause.setStackTrace(adjustedList.toArray(new StackTraceElement[] {}));
        return cause;
    }

    private static class ReturnValueWrapper implements Callable<Object> {

        private final Object  [MASK] ;

        private ReturnValueWrapper(Object  [MASK] ) {
            this. [MASK]  =  [MASK] ;
        }

        @Override
        public Object call() {
            return  [MASK] ;
        }
    }

    private static class SelfCallInfo extends ThreadLocal<Object> {

        Object replace(Object value) {
            Object current = get();
            set(value);
            return current;
        }

        boolean checkSelfCall(Object value) {
            if (value == get()) {
                set(null);
                return false;
            } else {
                return true;
            }
        }
    }

    static class ConstructorShortcut
            implements AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper {

        private final String identifier;

        ConstructorShortcut(String identifier) {
            this.identifier = identifier;
        }

        @Override
        public MethodVisitor wrap(
                TypeDescription instrumentedType,
                MethodDescription instrumentedMethod,
                MethodVisitor methodVisitor,
                Implementation.Context implementationContext,
                TypePool typePool,
                int writerFlags,
                int readerFlags) {
            if (instrumentedMethod.isConstructor() && !instrumentedType.represents(Object.class)) {
                MethodList<MethodDescription.InDefinedShape> constructors =
                        instrumentedType
                                .getSuperClass()
                                .asErasure()
                                .getDeclaredMethods()
                                .filter(isConstructor().and(isVisibleTo(instrumentedType)));
                int arguments = Integer.MAX_VALUE;
                boolean packagePrivate = true;
                MethodDescription.InDefinedShape current = null;
                for (MethodDescription.InDefinedShape constructor : constructors) {
                    // We are choosing the shortest constructor with regards to arguments.
                    // Yet, we prefer a non-package-private constructor since they require
                    // the super class to be on the same class loader.
                    if (constructor.getParameters().size() < arguments
                            && (packagePrivate || !constructor.isPackagePrivate())) {
                        arguments = constructor.getParameters().size();
                        packagePrivate = constructor.isPackagePrivate();
                        current = constructor;
                    }
                }
                if (current != null) {
                    final MethodDescription.InDefinedShape selected = current;
                    return new MethodVisitor(OpenedClassReader.ASM_API, methodVisitor) {
                        @Override
                        public void visitCode() {
                            super.visitCode();
                            /*
                             * The byte code that is added to the start of the method is roughly equivalent to
                             * the following byte code for a hypothetical constructor of class Current:
                             *
                             * if (MockMethodDispatcher.isConstructorMock(<identifier>, Current.class) {
                             *   super(<default arguments>);
                             *   Current o = (Current) MockMethodDispatcher.handleConstruction(Current.class,
                             *       this,
                             *       new Object[] {argument1, argument2, ...},
                             *       new String[] {argumentType1, argumentType2, ...});
                             *   if (o != null) {
                             *     this.field = o.field; // for each declared field
                             *   }
                             *   return;
                             * }
                             *
                             * This avoids the invocation of the original constructor chain but fullfils the
                             * verifier requirement to invoke a super constructor.
                             */
                            Label label = new Label();
                            super.visitLdcInsn(identifier);
                            if (implementationContext
                                    .getClassFileVersion()
                                    .isAtLeast(ClassFileVersion.JAVA_V5)) {
                                super.visitLdcInsn(Type.getType(instrumentedType.getDescriptor()));
                            } else {
                                super.visitLdcInsn(instrumentedType.getName());
                                super.visitMethodInsn(
                                        Opcodes.INVOKESTATIC,
                                        Type.getInternalName(Class.class),
                                        ""forName"",
                                        Type.getMethodDescriptor(
                                                Type.getType(Class.class),
                                                Type.getType(String.class)),
                                        false);
                            }
                            super.visitMethodInsn(
                                    Opcodes.INVOKESTATIC,
                                    Type.getInternalName(MockMethodDispatcher.class),
                                    ""isConstructorMock"",
                                    Type.getMethodDescriptor(
                                            Type.BOOLEAN_TYPE,
                                            Type.getType(String.class),
                                            Type.getType(Class.class)),
                                    false);
                            super.visitInsn(Opcodes.ICONST_0);
                            super.visitJumpInsn(Opcodes.IF_ICMPEQ, label);
                            super.visitVarInsn(Opcodes.ALOAD, 0);
                            for (TypeDescription type :
                                    selected.getParameters().asTypeList().asErasures()) {
                                if (type.represents(boolean.class)
                                        || type.represents(byte.class)
                                        || type.represents(short.class)
                                        || type.represents(char.class)
                                        || type.represents(int.class)) {
                                    super.visitInsn(Opcodes.ICONST_0);
                                } else if (type.represents(long.class)) {
                                    super.visitInsn(Opcodes.LCONST_0);
                                } else if (type.represents(float.class)) {
                                    super.visitInsn(Opcodes.FCONST_0);
                                } else if (type.represents(double.class)) {
                                    super.visitInsn(Opcodes.DCONST_0);
                                } else {
                                    super.visitInsn(Opcodes.ACONST_NULL);
                                }
                            }
                            super.visitMethodInsn(
                                    Opcodes.INVOKESPECIAL,
                                    selected.getDeclaringType().getInternalName(),
                                    selected.getInternalName(),
                                    selected.getDescriptor(),
                                    false);
                            super.visitLdcInsn(identifier);
                            if (implementationContext
                                    .getClassFileVersion()
                                    .isAtLeast(ClassFileVersion.JAVA_V5)) {
                                super.visitLdcInsn(Type.getType(instrumentedType.getDescriptor()));
                            } else {
                                super.visitLdcInsn(instrumentedType.getName());
                                super.visitMethodInsn(
                                        Opcodes.INVOKESTATIC,
                                        Type.getInternalName(Class.class),
                                        ""forName"",
                                        Type.getMethodDescriptor(
                                                Type.getType(Class.class),
                                                Type.getType(String.class)),
                                        false);
                            }
                            super.visitVarInsn(Opcodes.ALOAD, 0);
                            super.visitLdcInsn(instrumentedMethod.getParameters().size());
                            super.visitTypeInsn(
                                    Opcodes.ANEWARRAY, Type.getInternalName(Object.class));
                            int index = 0;
                            for (ParameterDescription parameter :
                                    instrumentedMethod.getParameters()) {
                                super.visitInsn(Opcodes.DUP);
                                super.visitLdcInsn(index++);
                                Type type =
                                        Type.getType(
                                                parameter.getType().asErasure().getDescriptor());
                                super.visitVarInsn(
                                        type.getOpcode(Opcodes.ILOAD), parameter.getOffset());
                                if (parameter.getType().isPrimitive()) {
                                    Type wrapper =
                                            Type.getType(
                                                    parameter
                                                            .getType()
                                                            .asErasure()
                                                            .asBoxed()
                                                            .getDescriptor());
                                    super.visitMethodInsn(
                                            Opcodes.INVOKESTATIC,
                                            wrapper.getInternalName(),
                                            ""valueOf"",
                                            Type.getMethodDescriptor(wrapper, type),
                                            false);
                                }
                                super.visitInsn(Opcodes.AASTORE);
                            }
                            index = 0;
                            super.visitLdcInsn(instrumentedMethod.getParameters().size());
                            super.visitTypeInsn(
                                    Opcodes.ANEWARRAY, Type.getInternalName(String.class));
                            for (TypeDescription typeDescription :
                                    instrumentedMethod.getParameters().asTypeList().asErasures()) {
                                super.visitInsn(Opcodes.DUP);
                                super.visitLdcInsn(index++);
                                super.visitLdcInsn(typeDescription.getName());
                                super.visitInsn(Opcodes.AASTORE);
                            }
                            super.visitMethodInsn(
                                    Opcodes.INVOKESTATIC,
                                    Type.getInternalName(MockMethodDispatcher.class),
                                    ""handleConstruction"",
                                    Type.getMethodDescriptor(
                                            Type.getType(Object.class),
                                            Type.getType(String.class),
                                            Type.getType(Class.class),
                                            Type.getType(Object.class),
                                            Type.getType(Object[].class),
                                            Type.getType(String[].class)),
                                    false);
                            FieldList<FieldDescription.InDefinedShape> fields =
                                    instrumentedType.getDeclaredFields().filter(not(isStatic()));
                            super.visitTypeInsn(
                                    Opcodes.CHECKCAST, instrumentedType.getInternalName());
                            super.visitInsn(Opcodes.DUP);
                            Label noSpy = new Label();
                            super.visitJumpInsn(Opcodes.IFNULL, noSpy);
                            for (FieldDescription field : fields) {
                                super.visitInsn(Opcodes.DUP);
                                super.visitFieldInsn(
                                        Opcodes.GETFIELD,
                                        instrumentedType.getInternalName(),
                                        field.getInternalName(),
                                        field.getDescriptor());
                                super.visitVarInsn(Opcodes.ALOAD, 0);
                                super.visitInsn(
                                        field.getType().getStackSize() == StackSize.DOUBLE
                                                ? Opcodes.DUP_X2
                                                : Opcodes.DUP_X1);
                                super.visitInsn(Opcodes.POP);
                                super.visitFieldInsn(
                                        Opcodes.PUTFIELD,
                                        instrumentedType.getInternalName(),
                                        field.getInternalName(),
                                        field.getDescriptor());
                            }
                            super.visitLabel(noSpy);
                            if (implementationContext
                                    .getClassFileVersion()
                                    .isAtLeast(ClassFileVersion.JAVA_V6)) {
                                Object[] locals =
                                        toFrames(
                                                instrumentedType.getInternalName(),
                                                instrumentedMethod
                                                        .getParameters()
                                                        .asTypeList()
                                                        .asErasures());
                                super.visitFrame(
                                        Opcodes.F_FULL,
                                        locals.length,
                                        locals,
                                        1,
                                        new Object[] {instrumentedType.getInternalName()});
                            }
                            super.visitInsn(Opcodes.POP);
                            super.visitInsn(Opcodes.RETURN);
                            super.visitLabel(label);
                            if (implementationContext
                                    .getClassFileVersion()
                                    .isAtLeast(ClassFileVersion.JAVA_V6)) {
                                Object[] locals =
                                        toFrames(
                                                Opcodes.UNINITIALIZED_THIS,
                                                instrumentedMethod
                                                        .getParameters()
                                                        .asTypeList()
                                                        .asErasures());
                                super.visitFrame(
                                        Opcodes.F_FULL, locals.length, locals, 0, new Object[0]);
                            }
                        }

                        @Override
                        public void visitMaxs(int maxStack, int maxLocals) {
                            int prequel = Math.max(5, selected.getStackSize());
                            for (ParameterDescription parameter :
                                    instrumentedMethod.getParameters()) {
                                prequel =
                                        Math.max(
                                                prequel,
                                                6 + parameter.getType().getStackSize().getSize());
                                prequel = Math.max(prequel, 8);
                            }
                            super.visitMaxs(Math.max(maxStack, prequel), maxLocals);
                        }
                    };
                }
            }
            return methodVisitor;
        }

        private static Object[] toFrames(Object self, List<TypeDescription> types) {
            Object[] frames = new Object[1 + types.size()];
            frames[0] = self;
            int index = 0;
            for (TypeDescription type : types) {
                Object frame;
                if (type.represents(boolean.class)
                        || type.represents(byte.class)
                        || type.represents(short.class)
                        || type.represents(char.class)
                        || type.represents(int.class)) {
                    frame = Opcodes.INTEGER;
                } else if (type.represents(long.class)) {
                    frame = Opcodes.LONG;
                } else if (type.represents(float.class)) {
                    frame = Opcodes.FLOAT;
                } else if (type.represents(double.class)) {
                    frame = Opcodes.DOUBLE;
                } else {
                    frame = type.getInternalName();
                }
                frames[++index] = frame;
            }
            return frames;
        }
    }

    @Retention(RetentionPolicy.RUNTIME)
    @interface Identifier {}

    static class ForHashCode {

        @SuppressWarnings(""unused"")
        @Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)
        private static boolean enter(@Identifier String id, @Advice.This Object self) {
            MockMethodDispatcher dispatcher = MockMethodDispatcher.get(id, self);
            return dispatcher != null && dispatcher.isMock(self);
        }

        @SuppressWarnings({""unused"", ""UnusedAssignment""})
        @Advice.OnMethodExit
        private static void enter(
                @Advice.This Object self,
                @Advice.Return(readOnly = false) int hashCode,
                @Advice.Enter boolean skipped) {
            if (skipped) {
                hashCode = System.identityHashCode(self);
            }
        }
    }

    static class ForEquals {

        @SuppressWarnings(""unused"")
        @Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)
        private static boolean enter(@Identifier String identifier, @Advice.This Object self) {
            MockMethodDispatcher dispatcher = MockMethodDispatcher.get(identifier, self);
            return dispatcher != null && dispatcher.isMock(self);
        }

        @SuppressWarnings({""unused"", ""UnusedAssignment""})
        @Advice.OnMethodExit
        private static void enter(
                @Advice.This Object self,
                @Advice.Argument(0) Object other,
                @Advice.Return(readOnly = false) boolean equals,
                @Advice.Enter boolean skipped) {
            if (skipped) {
                equals = self == other;
            }
        }
    }

    static class ForStatic {

        @SuppressWarnings(""unused"")
        @Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)
        private static Callable<?> enter(
                @Identifier String identifier,
                @Advice.Origin Class<?> type,
                @Advice.Origin Method origin,
                @Advice.AllArguments Object[] arguments)
                throws Throwable {
            MockMethodDispatcher dispatcher = MockMethodDispatcher.getStatic(identifier, type);
            if (dispatcher == null || !dispatcher.isMockedStatic(type)) {
                return null;
            } else {
                return dispatcher.handleStatic(type, origin, arguments);
            }
        }

        @SuppressWarnings({""unused"", ""UnusedAssignment""})
        @Advice.OnMethodExit
        private static void exit(
                @Advice.Return(readOnly = false, typing = Assigner.Typing.DYNAMIC) Object  [MASK] ,
                @Advice.Enter Callable<?> mocked)
                throws Throwable {
            if (mocked != null) {
                 [MASK]  = mocked.call();
            }
        }
    }

    public static class ForReadObject {

        @SuppressWarnings({""unused"", ""BanSerializableRead""})
        public static void doReadObject(
                @Identifier String identifier,
                @This MockAccess thiz,
                @Argument(0) ObjectInputStream objectInputStream)
                throws IOException, ClassNotFoundException {
            objectInputStream.defaultReadObject();
            MockMethodAdvice mockMethodAdvice =
                    (MockMethodAdvice) MockMethodDispatcher.get(identifier, thiz);
            if (mockMethodAdvice != null) {
                mockMethodAdvice.interceptors.put(thiz, thiz.getMockitoInterceptor());
            }
        }
    }
}
","returned
"
"package com.blankj.utilcode.util;

import android.annotation.SuppressLint;
import android.os.Build;
import android.os.Environment;
import android.text.TextUtils;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.util.Properties;

/**
 * <pre>
 *     author: Blankj
 *     blog  : http://blankj.com
 *     time  : 2018/07/04
 *     desc  : utils about rom
 * </pre>
 */
public final class RomUtils {

    private static final String[] ROM_HUAWEI    = {""huawei""};
    private static final String[] ROM_VIVO      = {""vivo""};
    private static final String[] ROM_XIAOMI    = {""xiaomi""};
    private static final String[] ROM_OPPO      = {""oppo""};
    private static final String[] ROM_LEECO     = {""leeco"", ""letv""};
    private static final String[] ROM_360       = {""360"", ""qiku""};
    private static final String[] ROM_ZTE       = {""zte""};
    private static final String[] ROM_ONEPLUS   = {""oneplus""};
    private static final String[] ROM_NUBIA     = {""nubia""};
    private static final String[] ROM_COOLPAD   = {""coolpad"", ""yulong""};
    private static final String[] ROM_LG        = {""lg"", ""lge""};
    private static final String[] ROM_GOOGLE    = {""google""};
    private static final String[] ROM_SAMSUNG   = {""samsung""};
    private static final String[] ROM_MEIZU     = {""meizu""};
    private static final String[] ROM_LENOVO    = {""lenovo""};
    private static final String[] ROM_SMARTISAN = {""smartisan"", ""deltainno""};
    private static final String[] ROM_HTC       = {""htc""};
    private static final String[] ROM_SONY      = {""sony""};
    private static final String[] ROM_GIONEE    = {""gionee"", ""amigo""};
    private static final String[] ROM_MOTOROLA  = {""motorola""};

    private static final String VERSION_PROPERTY_HUAWEI  = ""ro.build.version.emui"";
    private static final String VERSION_PROPERTY_VIVO    = ""ro.vivo.os.build. [MASK] .id"";
    private static final String VERSION_PROPERTY_XIAOMI  = ""ro.build.version.incremental"";
    private static final String VERSION_PROPERTY_OPPO    = ""ro.build.version.opporom"";
    private static final String VERSION_PROPERTY_LEECO   = ""ro.letv.release.version"";
    private static final String VERSION_PROPERTY_360     = ""ro.build.uiversion"";
    private static final String VERSION_PROPERTY_ZTE     = ""ro.build.MiFavor_version"";
    private static final String VERSION_PROPERTY_ONEPLUS = ""ro.rom.version"";
    private static final String VERSION_PROPERTY_NUBIA   = ""ro.build.rom.id"";
    private final static String UNKNOWN                  = ""unknown"";

    private static RomInfo bean = null;

    private RomUtils() {
        throw new UnsupportedOperationException(""u can't instantiate me..."");
    }

    /**
     * Return whether the rom is made by huawei.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isHuawei() {
        return ROM_HUAWEI[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by vivo.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isVivo() {
        return ROM_VIVO[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by xiaomi.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isXiaomi() {
        return ROM_XIAOMI[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by oppo.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isOppo() {
        return ROM_OPPO[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by leeco.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isLeeco() {
        return ROM_LEECO[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by 360.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean is360() {
        return ROM_360[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by zte.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isZte() {
        return ROM_ZTE[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by oneplus.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isOneplus() {
        return ROM_ONEPLUS[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by nubia.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isNubia() {
        return ROM_NUBIA[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by coolpad.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isCoolpad() {
        return ROM_COOLPAD[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by lg.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isLg() {
        return ROM_LG[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by google.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isGoogle() {
        return ROM_GOOGLE[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by samsung.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isSamsung() {
        return ROM_SAMSUNG[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by meizu.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isMeizu() {
        return ROM_MEIZU[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by lenovo.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isLenovo() {
        return ROM_LENOVO[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by smartisan.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isSmartisan() {
        return ROM_SMARTISAN[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by htc.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isHtc() {
        return ROM_HTC[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by sony.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isSony() {
        return ROM_SONY[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by gionee.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isGionee() {
        return ROM_GIONEE[0].equals(getRomInfo().name);
    }

    /**
     * Return whether the rom is made by motorola.
     *
     * @return {@code true}: yes<br>{@code false}: no
     */
    public static boolean isMotorola() {
        return ROM_MOTOROLA[0].equals(getRomInfo().name);
    }

    /**
     * Return the rom's information.
     *
     * @return the rom's information
     */
    public static RomInfo getRomInfo() {
        if (bean != null) return bean;
        bean = new RomInfo();
        final String brand = getBrand();
        final String manufacturer = getManufacturer();
        if (isRightRom(brand, manufacturer, ROM_HUAWEI)) {
            bean.name = ROM_HUAWEI[0];
            String version = getRomVersion(VERSION_PROPERTY_HUAWEI);
            String[] temp = version.split(""_"");
            if (temp.length > 1) {
                bean.version = temp[1];
            } else {
                bean.version = version;
            }
            return bean;
        }
        if (isRightRom(brand, manufacturer, ROM_VIVO)) {
            bean.name = ROM_VIVO[0];
            bean.version = getRomVersion(VERSION_PROPERTY_VIVO);
            return bean;
        }
        if (isRightRom(brand, manufacturer, ROM_XIAOMI)) {
            bean.name = ROM_XIAOMI[0];
            bean.version = getRomVersion(VERSION_PROPERTY_XIAOMI);
            return bean;
        }
        if (isRightRom(brand, manufacturer, ROM_OPPO)) {
            bean.name = ROM_OPPO[0];
            bean.version = getRomVersion(VERSION_PROPERTY_OPPO);
            return bean;
        }
        if (isRightRom(brand, manufacturer, ROM_LEECO)) {
            bean.name = ROM_LEECO[0];
            bean.version = getRomVersion(VERSION_PROPERTY_LEECO);
            return bean;
        }

        if (isRightRom(brand, manufacturer, ROM_360)) {
            bean.name = ROM_360[0];
            bean.version = getRomVersion(VERSION_PROPERTY_360);
            return bean;
        }
        if (isRightRom(brand, manufacturer, ROM_ZTE)) {
            bean.name = ROM_ZTE[0];
            bean.version = getRomVersion(VERSION_PROPERTY_ZTE);
            return bean;
        }
        if (isRightRom(brand, manufacturer, ROM_ONEPLUS)) {
            bean.name = ROM_ONEPLUS[0];
            bean.version = getRomVersion(VERSION_PROPERTY_ONEPLUS);
            return bean;
        }
        if (isRightRom(brand, manufacturer, ROM_NUBIA)) {
            bean.name = ROM_NUBIA[0];
            bean.version = getRomVersion(VERSION_PROPERTY_NUBIA);
            return bean;
        }

        if (isRightRom(brand, manufacturer, ROM_COOLPAD)) {
            bean.name = ROM_COOLPAD[0];
        } else if (isRightRom(brand, manufacturer, ROM_LG)) {
            bean.name = ROM_LG[0];
        } else if (isRightRom(brand, manufacturer, ROM_GOOGLE)) {
            bean.name = ROM_GOOGLE[0];
        } else if (isRightRom(brand, manufacturer, ROM_SAMSUNG)) {
            bean.name = ROM_SAMSUNG[0];
        } else if (isRightRom(brand, manufacturer, ROM_MEIZU)) {
            bean.name = ROM_MEIZU[0];
        } else if (isRightRom(brand, manufacturer, ROM_LENOVO)) {
            bean.name = ROM_LENOVO[0];
        } else if (isRightRom(brand, manufacturer, ROM_SMARTISAN)) {
            bean.name = ROM_SMARTISAN[0];
        } else if (isRightRom(brand, manufacturer, ROM_HTC)) {
            bean.name = ROM_HTC[0];
        } else if (isRightRom(brand, manufacturer, ROM_SONY)) {
            bean.name = ROM_SONY[0];
        } else if (isRightRom(brand, manufacturer, ROM_GIONEE)) {
            bean.name = ROM_GIONEE[0];
        } else if (isRightRom(brand, manufacturer, ROM_MOTOROLA)) {
            bean.name = ROM_MOTOROLA[0];
        } else {
            bean.name = manufacturer;
        }
        bean.version = getRomVersion("""");
        return bean;
    }

    private static boolean isRightRom(final String brand, final String manufacturer, final String... names) {
        for (String name : names) {
            if (brand.contains(name) || manufacturer.contains(name)) {
                return true;
            }
        }
        return false;
    }

    private static String getManufacturer() {
        try {
            String manufacturer = Build.MANUFACTURER;
            if (!TextUtils.isEmpty(manufacturer)) {
                return manufacturer.toLowerCase();
            }
        } catch (Throwable ignore) {/**/}
        return UNKNOWN;
    }

    private static String getBrand() {
        try {
            String brand = Build.BRAND;
            if (!TextUtils.isEmpty(brand)) {
                return brand.toLowerCase();
            }
        } catch (Throwable ignore) {/**/}
        return UNKNOWN;
    }

    private static String getRomVersion(final String propertyName) {
        String ret = """";
        if (!TextUtils.isEmpty(propertyName)) {
            ret = getSystemProperty(propertyName);
        }
        if (TextUtils.isEmpty(ret) || ret.equals(UNKNOWN)) {
            try {
                String  [MASK]  = Build.DISPLAY;
                if (!TextUtils.isEmpty( [MASK] )) {
                    ret =  [MASK] .toLowerCase();
                }
            } catch (Throwable ignore) {/**/}
        }
        if (TextUtils.isEmpty(ret)) {
            return UNKNOWN;
        }
        return ret;
    }

    private static String getSystemProperty(final String name) {
        String prop = getSystemPropertyByShell(name);
        if (!TextUtils.isEmpty(prop)) return prop;
        prop = getSystemPropertyByStream(name);
        if (!TextUtils.isEmpty(prop)) return prop;
        if (Build.VERSION.SDK_INT < 28) {
            return getSystemPropertyByReflect(name);
        }
        return prop;
    }

    private static String getSystemPropertyByShell(final String propName) {
        String line;
        BufferedReader input = null;
        try {
            Process p = Runtime.getRuntime().exec(""getprop "" + propName);
            input = new BufferedReader(new InputStreamReader(p.getInputStream()), 1024);
            String ret = input.readLine();
            if (ret != null) {
                return ret;
            }
        } catch (IOException ignore) {
        } finally {
            if (input != null) {
                try {
                    input.close();
                } catch (IOException ignore) {/**/}
            }
        }
        return """";
    }

    private static String getSystemPropertyByStream(final String key) {
        try {
            Properties prop = new Properties();
            FileInputStream is = new FileInputStream(
                    new File(Environment.getRootDirectory(), ""build.prop"")
            );
            prop.load(is);
            return prop.getProperty(key, """");
        } catch (Exception ignore) {/**/}
        return """";
    }

    private static String getSystemPropertyByReflect(String key) {
        try {
            @SuppressLint(""PrivateApi"")
            Class<?> clz = Class.forName(""android.os.SystemProperties"");
            Method getMethod = clz.getMethod(""get"", String.class, String.class);
            return (String) getMethod.invoke(clz, key, """");
        } catch (Exception e) {/**/}
        return """";
    }

    public static class RomInfo {
        private String name;
        private String version;

        public String getName() {
            return name;
        }

        public String getVersion() {
            return version;
        }

        @Override
        public String toString() {
            return ""RomInfo{name="" + name +
                    "", version="" + version + ""}"";
        }
    }
}","display
"
"/*******************************************************************************
 * Copyright 2011 See AUTHORS file.
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

package com.badlogic.gdx.maps.tiled;

import com.badlogic.gdx.assets.AssetDescriptor;
import com.badlogic.gdx.assets.AssetLoaderParameters;
import com.badlogic.gdx.assets.AssetManager;
import com.badlogic.gdx.assets.loaders.FileHandleResolver;
import com.badlogic.gdx.assets.loaders.SynchronousAssetLoader;
import com.badlogic.gdx.assets.loaders.resolvers.InternalFileHandleResolver;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.maps.ImageResolver;
import com.badlogic.gdx.maps.ImageResolver.AssetManagerImageResolver;
import com.badlogic.gdx.maps.ImageResolver.DirectImageResolver;
import com.badlogic.gdx.maps.MapProperties;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer.Cell;
import com.badlogic.gdx.maps.tiled.tiles.AnimatedTiledMapTile;
import com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.GdxRuntimeException;
import com.badlogic.gdx.utils.ObjectMap;
import com.badlogic.gdx.utils.XmlReader;
import com.badlogic.gdx.utils.XmlReader.Element;

import java.io.IOException;
import java.util.StringTokenizer;

public class TideMapLoader extends SynchronousAssetLoader<TiledMap, TideMapLoader.Parameters> {

	public static class Parameters extends AssetLoaderParameters<TiledMap> {

	}

	private XmlReader xml = new XmlReader();
	private Element root;

	public TideMapLoader () {
		super(new InternalFileHandleResolver());
	}

	public TideMapLoader (FileHandleResolver resolver) {
		super(resolver);
	}

	public TiledMap load (String fileName) {
		try {
			FileHandle tideFile = resolve(fileName);
			root = xml.parse(tideFile);
			ObjectMap<String, Texture> textures = new ObjectMap<String, Texture>();
			for (FileHandle textureFile : loadTileSheets(root, tideFile)) {
				textures.put(textureFile.path(), new Texture(textureFile));
			}
			DirectImageResolver imageResolver = new DirectImageResolver(textures);
			TiledMap map = loadMap(root, tideFile, imageResolver);
			map.setOwnedResources(textures.values().toArray());
			return map;
		} catch (IOException e) {
			throw new GdxRuntimeException(""Couldn't load tilemap '"" + fileName + ""'"", e);
		}

	}

	@Override
	public TiledMap load (AssetManager assetManager, String fileName, FileHandle tideFile, Parameters parameter) {
		try {
			return loadMap(root, tideFile, new AssetManagerImageResolver(assetManager));
		} catch (Exception e) {
			throw new GdxRuntimeException(""Couldn't load tilemap '"" + fileName + ""'"", e);
		}
	}

	@Override
	public Array<AssetDescriptor> getDependencies (String fileName, FileHandle tmxFile, Parameters parameter) {
		Array<AssetDescriptor> dependencies = new Array<AssetDescriptor>();
		try {
			root = xml.parse(tmxFile);
			for (FileHandle image : loadTileSheets(root, tmxFile)) {
				dependencies.add(new AssetDescriptor(image.path(), Texture.class));
			}
			return dependencies;
		} catch (IOException e) {
			throw new GdxRuntimeException(""Couldn't load tilemap '"" + fileName + ""'"", e);
		}
	}

	/** Loads the map data, given the XML root element and an {@link ImageResolver} used to return the tileset Textures
	 * @param root the XML root element
	 * @param tmxFile the Filehandle of the tmx file
	 * @param imageResolver the {@link ImageResolver}
	 * @return the {@link TiledMap} */
	private TiledMap loadMap (Element root, FileHandle tmxFile, ImageResolver imageResolver) {
		TiledMap map = new TiledMap();
		Element properties = root.getChildByName(""Properties"");
		if (properties != null) {
			loadProperties(map.getProperties(), properties);
		}
		Element tilesheets = root.getChildByName(""TileSheets"");
		for (Element tilesheet : tilesheets.getChildrenByName(""TileSheet"")) {
			loadTileSheet(map, tilesheet, tmxFile, imageResolver);
		}
		Element layers = root.getChildByName(""Layers"");
		for (Element layer : layers.getChildrenByName(""Layer"")) {
			loadLayer(map, layer);
		}
		return map;
	}

	/** Loads the tilesets
	 * @param root the root XML element
	 * @return a list of filenames for images containing tiles
	 * @throws IOException */
	private Array<FileHandle> loadTileSheets (Element root, FileHandle tideFile) throws IOException {
		Array<FileHandle> images = new Array<FileHandle>();
		Element tilesheets = root.getChildByName(""TileSheets"");
		for (Element tileset : tilesheets.getChildrenByName(""TileSheet"")) {
			Element imageSource = tileset.getChildByName(""ImageSource"");
			FileHandle image = getRelativeFileHandle(tideFile, imageSource.getText());
			images.add(image);
		}
		return images;
	}

	private void loadTileSheet (TiledMap map, Element element, FileHandle tideFile, ImageResolver imageResolver) {
		if (element.getName().equals(""TileSheet"")) {
			String id = element.getAttribute(""Id"");
			String description = element.getChildByName(""Description"").getText();
			String imageSource = element.getChildByName(""ImageSource"").getText();

			Element  [MASK]  = element.getChildByName(""Alignment"");
			String sheetSize =  [MASK] .getAttribute(""SheetSize"");
			String tileSize =  [MASK] .getAttribute(""TileSize"");
			String margin =  [MASK] .getAttribute(""Margin"");
			String spacing =  [MASK] .getAttribute(""Spacing"");

			String[] sheetSizeParts = sheetSize.split("" x "");
			int sheetSizeX = Integer.parseInt(sheetSizeParts[0]);
			int sheetSizeY = Integer.parseInt(sheetSizeParts[1]);

			String[] tileSizeParts = tileSize.split("" x "");
			int tileSizeX = Integer.parseInt(tileSizeParts[0]);
			int tileSizeY = Integer.parseInt(tileSizeParts[1]);

			String[] marginParts = margin.split("" x "");
			int marginX = Integer.parseInt(marginParts[0]);
			int marginY = Integer.parseInt(marginParts[1]);

			String[] spacingParts = margin.split("" x "");
			int spacingX = Integer.parseInt(spacingParts[0]);
			int spacingY = Integer.parseInt(spacingParts[1]);

			FileHandle image = getRelativeFileHandle(tideFile, imageSource);
			TextureRegion texture = imageResolver.getImage(image.path());

			TiledMapTileSets tilesets = map.getTileSets();
			int firstgid = 1;
			for (TiledMapTileSet tileset : tilesets) {
				firstgid += tileset.size();
			}

			TiledMapTileSet tileset = new TiledMapTileSet();
			tileset.setName(id);
			tileset.getProperties().put(""firstgid"", firstgid);
			int gid = firstgid;

			int stopWidth = texture.getRegionWidth() - tileSizeX;
			int stopHeight = texture.getRegionHeight() - tileSizeY;

			for (int y = marginY; y <= stopHeight; y += tileSizeY + spacingY) {
				for (int x = marginX; x <= stopWidth; x += tileSizeX + spacingX) {
					TiledMapTile tile = new StaticTiledMapTile(new TextureRegion(texture, x, y, tileSizeX, tileSizeY));
					tile.setId(gid);
					tileset.putTile(gid++, tile);
				}
			}

			Element properties = element.getChildByName(""Properties"");
			if (properties != null) {
				loadProperties(tileset.getProperties(), properties);
			}

			tilesets.addTileSet(tileset);
		}
	}

	private void loadLayer (TiledMap map, Element element) {
		if (element.getName().equals(""Layer"")) {
			String id = element.getAttribute(""Id"");
			String visible = element.getAttribute(""Visible"");

			Element dimensions = element.getChildByName(""Dimensions"");
			String layerSize = dimensions.getAttribute(""LayerSize"");
			String tileSize = dimensions.getAttribute(""TileSize"");

			String[] layerSizeParts = layerSize.split("" x "");
			int layerSizeX = Integer.parseInt(layerSizeParts[0]);
			int layerSizeY = Integer.parseInt(layerSizeParts[1]);

			String[] tileSizeParts = tileSize.split("" x "");
			int tileSizeX = Integer.parseInt(tileSizeParts[0]);
			int tileSizeY = Integer.parseInt(tileSizeParts[1]);

			TiledMapTileLayer layer = new TiledMapTileLayer(layerSizeX, layerSizeY, tileSizeX, tileSizeY);
			layer.setName(id);
			layer.setVisible(visible.equalsIgnoreCase(""True""));
			Element tileArray = element.getChildByName(""TileArray"");
			Array<Element> rows = tileArray.getChildrenByName(""Row"");
			TiledMapTileSets tilesets = map.getTileSets();
			TiledMapTileSet currentTileSet = null;
			int firstgid = 0;
			int x, y;
			for (int row = 0, rowCount = rows.size; row < rowCount; row++) {
				Element currentRow = rows.get(row);
				y = rowCount - 1 - row;
				x = 0;
				for (int child = 0, childCount = currentRow.getChildCount(); child < childCount; child++) {
					Element currentChild = currentRow.getChild(child);
					String name = currentChild.getName();
					if (name.equals(""TileSheet"")) {
						currentTileSet = tilesets.getTileSet(currentChild.getAttribute(""Ref""));
						firstgid = currentTileSet.getProperties().get(""firstgid"", Integer.class);
					} else if (name.equals(""Null"")) {
						x += currentChild.getIntAttribute(""Count"");
					} else if (name.equals(""Static"")) {
						Cell cell = new Cell();
						cell.setTile(currentTileSet.getTile(firstgid + currentChild.getIntAttribute(""Index"")));
						layer.setCell(x++, y, cell);
					} else if (name.equals(""Animated"")) {
						// Create an AnimatedTile
						int interval = currentChild.getInt(""Interval"");
						Element frames = currentChild.getChildByName(""Frames"");
						Array<StaticTiledMapTile> frameTiles = new Array<StaticTiledMapTile>();
						for (int frameChild = 0, frameChildCount = frames.getChildCount(); frameChild < frameChildCount; frameChild++) {
							Element frame = frames.getChild(frameChild);
							String frameName = frame.getName();
							if (frameName.equals(""TileSheet"")) {
								currentTileSet = tilesets.getTileSet(frame.getAttribute(""Ref""));
								firstgid = currentTileSet.getProperties().get(""firstgid"", Integer.class);
							} else if (frameName.equals(""Static"")) {
								frameTiles.add((StaticTiledMapTile)currentTileSet.getTile(firstgid + frame.getIntAttribute(""Index"")));
							}
						}
						Cell cell = new Cell();
						cell.setTile(new AnimatedTiledMapTile(interval / 1000f, frameTiles));
						layer.setCell(x++, y, cell); // TODO: Reuse existing animated tiles
					}
				}
			}

			Element properties = element.getChildByName(""Properties"");
			if (properties != null) {
				loadProperties(layer.getProperties(), properties);
			}

			map.getLayers().add(layer);
		}
	}

	private void loadProperties (MapProperties properties, Element element) {
		if (element.getName().equals(""Properties"")) {
			for (Element property : element.getChildrenByName(""Property"")) {
				String key = property.getAttribute(""Key"", null);
				String type = property.getAttribute(""Type"", null);
				String value = property.getText();

				if (type.equals(""Int32"")) {
					properties.put(key, Integer.parseInt(value));
				} else if (type.equals(""String"")) {
					properties.put(key, value);
				} else if (type.equals(""Boolean"")) {
					properties.put(key, value.equalsIgnoreCase(""true""));
				} else {
					properties.put(key, value);
				}
			}
		}
	}

	private static FileHandle getRelativeFileHandle (FileHandle file, String path) {
		StringTokenizer tokenizer = new StringTokenizer(path, ""\\/"");
		FileHandle result = file.parent();
		while (tokenizer.hasMoreElements()) {
			String token = tokenizer.nextToken();
			if (token.equals(""..""))
				result = result.parent();
			else {
				result = result.child(token);
			}
		}
		return result;
	}

}
","alignment
"
"/*******************************************************************************
 * Copyright (C) 2018, OpenRefine contributors
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/

package com.google.refine.expr;

import org.slf4j.LoggerFactory;
import org.testng.Assert;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.Test;

import com.google.refine.RefineTest;
import com.google.refine.util.TestUtils;

public class EvalErrorTests extends RefineTest {

    @Override
    @BeforeTest
    public void init() {
        logger = LoggerFactory.getLogger(this.getClass());
    }

    @Test
    public void serializeEvalError() {
        EvalError e = new EvalError(""This is a critical error"");
        TestUtils.isSerializedTo(e, ""{\""type\"":\""error\"",\""message\"":\""This is a critical error\""}"");
    }

    @Test
    public void testInnerHtml() {
        Assert.assertTrue(invoke(""innerHtml"") instanceof EvalError);
        Assert.assertTrue(invoke(""innerHtml"", ""test"") instanceof EvalError);

        EvalError  [MASK]  = (EvalError) invoke(""innerHtml"", ""test"");
        Assert.assertEquals( [MASK] .toString(),
                ""innerHtml() cannot work with this \'string\'. The first parameter is not an HTML Element. Please first use parseHtml(string) and select(query) prior to using this function"");
    }

    @Test
    public void testWholeText() {
        Assert.assertTrue(invoke(""wholeText"") instanceof EvalError);
        Assert.assertTrue(invoke(""wholeText"", ""test"") instanceof EvalError);

        EvalError  [MASK]  = (EvalError) invoke(""wholeText"", ""test"");
        Assert.assertEquals( [MASK] .toString(),
                ""wholeText() cannot work with this \'string\' and failed as the first parameter is not an XML or HTML Element.  Please first use parseXml() or parseHtml() and select(query) prior to using this function"");
    }

    @Test
    public void testXmlText() {
        Assert.assertTrue(invoke(""xmlText"") instanceof EvalError);
        Assert.assertTrue(invoke(""xmlText"", ""test"") instanceof EvalError);

        EvalError  [MASK]  = (EvalError) invoke(""xmlText"", ""test"");
        Assert.assertEquals( [MASK] .toString(),
                ""xmlText() cannot work with this \'string\' and failed as the first parameter is not an XML or HTML Element.  Please first use parseXml() or parseHtml() and select(query) prior to using this function"");
    }
}
","evalError
"
"/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

package com.facebook.drawee.generic;

import android.content.res.Resources;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.drawable.Animatable;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import androidx.annotation.VisibleForTesting;
import com.facebook.common.internal.Preconditions;
import com.facebook.drawee.drawable.DrawableParent;
import com.facebook.drawee.drawable.FadeDrawable;
import com.facebook.drawee.drawable.ForwardingDrawable;
import com.facebook.drawee.drawable.MatrixDrawable;
import com.facebook.drawee.drawable.ScaleTypeDrawable;
import com.facebook.drawee.drawable.ScalingUtils;
import com.facebook.drawee.interfaces.SettableDraweeHierarchy;
import com.facebook.fresco.ui.common.OnFadeListener;
import com.facebook.imagepipeline.systrace.FrescoSystrace;
import javax.annotation.Nullable;

/**
 * A SettableDraweeHierarchy that displays placeholder image until the actual image is set. If
 * provided, failure image will be used in case of failure (placeholder otherwise). If provided,
 * retry image will be used in case of failure when retrying is enabled. If provided, progressbar
 * will be displayed until fully loaded. Each image can be displayed with a different scale type (or
 * no scaling at all). Fading between the layers is supported. Rounding is supported.
 *
 * <p>Example hierarchy with a placeholder, retry, failure and the actual image:
 *
 * <pre>
 *  o RootDrawable (top level drawable)
 *  |
 *  +--o FadeDrawable
 *     |
 *     +--o ScaleTypeDrawable (placeholder branch, optional)
 *     |  |
 *     |  +--o Drawable (placeholder image)
 *     |
 *     +--o ScaleTypeDrawable (actual image branch)
 *     |  |
 *     |  +--o ForwardingDrawable (actual image wrapper)
 *     |     |
 *     |     +--o Drawable (actual image)
 *     |
 *     +--o null (progress bar branch, optional)
 *     |
 *     +--o Drawable (retry image branch, optional)
 *     |
 *     +--o ScaleTypeDrawable (failure image branch, optional)
 *        |
 *        +--o Drawable (failure image)
 *  </pre>
 *
 * <p>Note:
 *
 * <ul>
 *   <li>RootDrawable and FadeDrawable are always created.
 *   <li>All branches except the actual image branch are optional (placeholder, failure, retry,
 *       progress bar). If some branch is not specified it won't be created. Index in FadeDrawable
 *       will still be reserved though.
 *   <li>If overlays and/or background are specified, they are added to the same fade drawable, and
 *       are always being displayed.
 *   <li>ScaleType and Matrix transformations will be added only if specified. If both are
 *       unspecified, then the branch for that image is attached to FadeDrawable directly. Matrix
 *       transformation is only supported for the actual image, and it is not recommended to be
 *       used.
 *   <li>Rounding, if specified, is applied to all layers. Rounded drawable can either wrap
 *       FadeDrawable, or if leaf rounding is specified, each leaf drawable will be rounded
 *       separately.
 *   <li>A particular drawable instance should be used by only one DH. If more than one DH is being
 *       built with the same builder, different drawable instances must be specified for each DH.
 * </ul>
 */
public class GenericDraweeHierarchy implements SettableDraweeHierarchy {

  private static final int BACKGROUND_IMAGE_INDEX = 0;
  private static final int PLACEHOLDER_IMAGE_INDEX = 1;
  private static final int ACTUAL_IMAGE_INDEX = 2;
  private static final int PROGRESS_BAR_IMAGE_INDEX = 3;
  private static final int RETRY_IMAGE_INDEX = 4;
  private static final int FAILURE_IMAGE_INDEX = 5;
  private static final int OVERLAY_IMAGES_INDEX = 6;

  private final Drawable mEmptyActualImageDrawable = new ColorDrawable(Color.TRANSPARENT);

  private final Resources mResources;
  private @Nullable RoundingParams mRoundingParams;

  private final RootDrawable mTopLevelDrawable;
  private final FadeDrawable mFadeDrawable;
  private final ForwardingDrawable mActualImageWrapper;

  GenericDraweeHierarchy(GenericDraweeHierarchyBuilder builder) {
    if (FrescoSystrace.isTracing()) {
      FrescoSystrace.beginSection(""GenericDraweeHierarchy()"");
    }
    mResources = builder.getResources();
    mRoundingParams = builder.getRoundingParams();

    mActualImageWrapper = new ForwardingDrawable(mEmptyActualImageDrawable);

    int numOverlays = (builder.getOverlays() != null) ? builder.getOverlays().size() : 1;

    // make sure there is at least one overlay to make setOverlayImage(Drawable)
    // method work.
    if (numOverlays == 0) {
      numOverlays = 1;
    }

    numOverlays += (builder.getPressedStateOverlay() != null) ? 1 : 0;

    // layer indices and count
    int numLayers = OVERLAY_IMAGES_INDEX + numOverlays;

    // array of layers
    Drawable[] layers = new Drawable[numLayers];
    layers[BACKGROUND_IMAGE_INDEX] = buildBranch(builder.getBackground(), null);
    layers[PLACEHOLDER_IMAGE_INDEX] =
        buildBranch(builder.getPlaceholderImage(), builder.getPlaceholderImageScaleType());
    layers[ACTUAL_IMAGE_INDEX] =
        buildActualImageBranch(
            mActualImageWrapper,
            builder.getActualImageScaleType(),
            builder.getActualImageFocusPoint(),
            builder.getActualImageColorFilter());
    layers[PROGRESS_BAR_IMAGE_INDEX] =
        buildBranch(builder.getProgressBarImage(), builder.getProgressBarImageScaleType());
    layers[RETRY_IMAGE_INDEX] =
        buildBranch(builder.getRetryImage(), builder.getRetryImageScaleType());
    layers[FAILURE_IMAGE_INDEX] =
        buildBranch(builder.getFailureImage(), builder.getFailureImageScaleType());
    if (numOverlays > 0) {
      int index = 0;
      if (builder.getOverlays() != null) {
        for (Drawable overlay : builder.getOverlays()) {
          layers[OVERLAY_IMAGES_INDEX + index++] = buildBranch(overlay, null);
        }
      } else {
        index = 1; // reserve space for one overlay
      }
      if (builder.getPressedStateOverlay() != null) {
        layers[OVERLAY_IMAGES_INDEX + index] = buildBranch(builder.getPressedStateOverlay(), null);
      }
    }

    // fade drawable composed of layers
    mFadeDrawable = new FadeDrawable(layers, false, ACTUAL_IMAGE_INDEX);
    mFadeDrawable.setTransitionDuration(builder.getFadeDuration());

    // rounded corners drawable (optional)
    Drawable maybeRoundedDrawable =
        WrappingUtils.maybeWrapWithRoundedOverlayColor(mFadeDrawable, mRoundingParams);

    // top-level drawable
    mTopLevelDrawable = new RootDrawable(maybeRoundedDrawable);
    mTopLevelDrawable.mutate();

    resetFade();
    if (FrescoSystrace.isTracing()) {
      FrescoSystrace.endSection();
    }
  }

  @Nullable
  private Drawable buildActualImageBranch(
      Drawable drawable,
      @Nullable ScalingUtils.ScaleType scaleType,
      @Nullable PointF  [MASK] ,
      @Nullable ColorFilter colorFilter) {
    drawable.setColorFilter(colorFilter);
    drawable = WrappingUtils.maybeWrapWithScaleType(drawable, scaleType,  [MASK] );
    return drawable;
  }

  /** Applies scale type and rounding (both if specified). */
  @Nullable
  private Drawable buildBranch(
      @Nullable Drawable drawable, @Nullable ScalingUtils.ScaleType scaleType) {
    drawable = WrappingUtils.maybeApplyLeafRounding(drawable, mRoundingParams, mResources);
    drawable = WrappingUtils.maybeWrapWithScaleType(drawable, scaleType);
    return drawable;
  }

  private void resetActualImages() {
    mActualImageWrapper.setDrawable(mEmptyActualImageDrawable);
  }

  private void resetFade() {
    if (mFadeDrawable != null) {
      mFadeDrawable.beginBatchMode();
      // turn on all layers (backgrounds, branches, overlays)
      mFadeDrawable.fadeInAllLayers();
      // turn off branches (leaving backgrounds and overlays on)
      fadeOutBranches();
      // turn on placeholder
      fadeInLayer(PLACEHOLDER_IMAGE_INDEX);
      mFadeDrawable.finishTransitionImmediately();
      mFadeDrawable.endBatchMode();
    }
  }

  private void fadeOutBranches() {
    fadeOutLayer(PLACEHOLDER_IMAGE_INDEX);
    fadeOutLayer(ACTUAL_IMAGE_INDEX);
    fadeOutLayer(PROGRESS_BAR_IMAGE_INDEX);
    fadeOutLayer(RETRY_IMAGE_INDEX);
    fadeOutLayer(FAILURE_IMAGE_INDEX);
  }

  private void fadeInLayer(int index) {
    if (index >= 0) {
      mFadeDrawable.fadeInLayer(index);
    }
  }

  private void fadeOutLayer(int index) {
    if (index >= 0) {
      mFadeDrawable.fadeOutLayer(index);
    }
  }

  private void setProgress(float progress) {
    Drawable progressBarDrawable = mFadeDrawable.getDrawable(PROGRESS_BAR_IMAGE_INDEX);
    if (progressBarDrawable == null) {
      return;
    }

    // display progressbar when not fully loaded, hide otherwise
    if (progress >= 0.999f) {
      if (progressBarDrawable instanceof Animatable) {
        ((Animatable) progressBarDrawable).stop();
      }
      fadeOutLayer(PROGRESS_BAR_IMAGE_INDEX);
    } else {
      if (progressBarDrawable instanceof Animatable) {
        ((Animatable) progressBarDrawable).start();
      }
      fadeInLayer(PROGRESS_BAR_IMAGE_INDEX);
    }
    // set drawable level, scaled to [0, 10000] per drawable specification
    progressBarDrawable.setLevel(Math.round(progress * 10000));
  }

  // SettableDraweeHierarchy interface

  @Override
  public Drawable getTopLevelDrawable() {
    return mTopLevelDrawable;
  }

  @Override
  public void reset() {
    resetActualImages();
    resetFade();
  }

  @Override
  public void setImage(Drawable drawable, float progress, boolean immediate) {
    drawable = WrappingUtils.maybeApplyLeafRounding(drawable, mRoundingParams, mResources);
    drawable.mutate();
    mActualImageWrapper.setDrawable(drawable);
    mFadeDrawable.beginBatchMode();
    fadeOutBranches();
    fadeInLayer(ACTUAL_IMAGE_INDEX);
    setProgress(progress);
    if (immediate) {
      mFadeDrawable.finishTransitionImmediately();
    }
    mFadeDrawable.endBatchMode();
  }

  @Override
  public void setProgress(float progress, boolean immediate) {
    if (mFadeDrawable.getDrawable(PROGRESS_BAR_IMAGE_INDEX) == null) {
      return;
    }
    mFadeDrawable.beginBatchMode();
    setProgress(progress);
    if (immediate) {
      mFadeDrawable.finishTransitionImmediately();
    }
    mFadeDrawable.endBatchMode();
  }

  @Override
  public void setFailure(Throwable throwable) {
    mFadeDrawable.beginBatchMode();
    fadeOutBranches();
    if (mFadeDrawable.getDrawable(FAILURE_IMAGE_INDEX) != null) {
      fadeInLayer(FAILURE_IMAGE_INDEX);
    } else {
      fadeInLayer(PLACEHOLDER_IMAGE_INDEX);
    }
    mFadeDrawable.endBatchMode();
  }

  @Override
  public void setRetry(Throwable throwable) {
    mFadeDrawable.beginBatchMode();
    fadeOutBranches();
    if (mFadeDrawable.getDrawable(RETRY_IMAGE_INDEX) != null) {
      fadeInLayer(RETRY_IMAGE_INDEX);
    } else {
      fadeInLayer(PLACEHOLDER_IMAGE_INDEX);
    }
    mFadeDrawable.endBatchMode();
  }

  @Override
  public void setControllerOverlay(@Nullable Drawable drawable) {
    mTopLevelDrawable.setControllerOverlay(drawable);
  }

  @Override
  public Rect getBounds() {
    return mTopLevelDrawable.getBounds();
  }

  // Helper methods for accessing layers

  /**
   * Gets the lowest parent drawable for the layer at the specified index.
   *
   * <p>Following drawables are considered as parents: FadeDrawable, MatrixDrawable,
   * ScaleTypeDrawable. This is because those drawables are added automatically by the hierarchy (if
   * specified), whereas their children are created externally by the client code. When we need to
   * change the previously set drawable this is the parent whose child needs to be replaced.
   */
  private DrawableParent getParentDrawableAtIndex(int index) {
    DrawableParent parent = mFadeDrawable.getDrawableParentForIndex(index);
    if (parent.getDrawable() instanceof MatrixDrawable) {
      parent = (MatrixDrawable) parent.getDrawable();
    }
    if (parent.getDrawable() instanceof ScaleTypeDrawable) {
      parent = (ScaleTypeDrawable) parent.getDrawable();
    }
    return parent;
  }

  /**
   * Sets the drawable at the specified index while keeping the old scale type and rounding. In case
   * the given drawable is null, scale type gets cleared too.
   */
  private void setChildDrawableAtIndex(int index, @Nullable Drawable drawable) {
    if (drawable == null) {
      mFadeDrawable.setDrawable(index, null);
      return;
    }
    drawable = WrappingUtils.maybeApplyLeafRounding(drawable, mRoundingParams, mResources);
    getParentDrawableAtIndex(index).setDrawable(drawable);
  }

  /**
   * Gets the ScaleTypeDrawable at the specified index. In case there is no child at the specified
   * index, a NullPointerException is thrown. In case there is a child, but the ScaleTypeDrawable
   * does not exist, the child will be wrapped with a new ScaleTypeDrawable.
   */
  private ScaleTypeDrawable getScaleTypeDrawableAtIndex(int index) {
    DrawableParent parent = getParentDrawableAtIndex(index);
    if (parent instanceof ScaleTypeDrawable) {
      return (ScaleTypeDrawable) parent;
    } else {
      return WrappingUtils.wrapChildWithScaleType(parent, ScalingUtils.ScaleType.FIT_XY);
    }
  }

  /** Returns whether the given layer has a scale type drawable. */
  private boolean hasScaleTypeDrawableAtIndex(int index) {
    DrawableParent parent = getParentDrawableAtIndex(index);
    return (parent instanceof ScaleTypeDrawable);
  }

  // Mutability

  /** Sets the fade duration. */
  public void setFadeDuration(int durationMs) {
    mFadeDrawable.setTransitionDuration(durationMs);
  }

  /** Gets the fade duration. */
  public int getFadeDuration() {
    return mFadeDrawable.getTransitionDuration();
  }

  /** Sets the actual image focus point. */
  public void setActualImageFocusPoint(PointF  [MASK] ) {
    Preconditions.checkNotNull( [MASK] );
    getScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX).setFocusPoint( [MASK] );
  }

  /** Sets the actual image scale type. */
  public void setActualImageScaleType(ScalingUtils.ScaleType scaleType) {
    Preconditions.checkNotNull(scaleType);
    getScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX).setScaleType(scaleType);
  }

  public @Nullable ScalingUtils.ScaleType getActualImageScaleType() {
    if (!hasScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX)) {
      return null;
    }
    return getScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX).getScaleType();
  }

  public @Nullable PointF getActualImageFocusPoint() {
    if (!hasScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX)) {
      return null;
    }
    return getScaleTypeDrawableAtIndex(ACTUAL_IMAGE_INDEX).getFocusPoint();
  }

  /** Sets the color filter to be applied on the actual image. */
  public void setActualImageColorFilter(@Nullable ColorFilter colorfilter) {
    mActualImageWrapper.setColorFilter(colorfilter);
  }

  /** Gets the non-cropped post-scaling bounds of the actual image. */
  public void getActualImageBounds(RectF outBounds) {
    mActualImageWrapper.getTransformedBounds(outBounds);
  }

  /** Sets a new placeholder drawable with old scale type. */
  public void setPlaceholderImage(@Nullable Drawable drawable) {
    setChildDrawableAtIndex(PLACEHOLDER_IMAGE_INDEX, drawable);
  }

  /** Sets a new placeholder drawable with scale type. */
  public void setPlaceholderImage(Drawable drawable, ScalingUtils.ScaleType scaleType) {
    setChildDrawableAtIndex(PLACEHOLDER_IMAGE_INDEX, drawable);
    getScaleTypeDrawableAtIndex(PLACEHOLDER_IMAGE_INDEX).setScaleType(scaleType);
  }

  /** @return true if there is a placeholder image set. */
  public boolean hasPlaceholderImage() {
    return mFadeDrawable.getDrawable(PLACEHOLDER_IMAGE_INDEX) != null;
  }

  /** Sets the placeholder image focus point. */
  public void setPlaceholderImageFocusPoint(PointF  [MASK] ) {
    Preconditions.checkNotNull( [MASK] );
    getScaleTypeDrawableAtIndex(PLACEHOLDER_IMAGE_INDEX).setFocusPoint( [MASK] );
  }

  /**
   * Sets a new placeholder drawable with old scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   */
  public void setPlaceholderImage(int resourceId) {
    setPlaceholderImage(mResources.getDrawable(resourceId));
  }

  /**
   * Sets a new placeholder drawable with scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   * @param ScalingUtils.ScaleType a new scale type.
   */
  public void setPlaceholderImage(int resourceId, ScalingUtils.ScaleType scaleType) {
    setPlaceholderImage(mResources.getDrawable(resourceId), scaleType);
  }

  /** Sets a new failure drawable with old scale type. */
  public void setFailureImage(@Nullable Drawable drawable) {
    setChildDrawableAtIndex(FAILURE_IMAGE_INDEX, drawable);
  }

  /** Sets a new failure drawable with scale type. */
  public void setFailureImage(Drawable drawable, ScalingUtils.ScaleType scaleType) {
    setChildDrawableAtIndex(FAILURE_IMAGE_INDEX, drawable);
    getScaleTypeDrawableAtIndex(FAILURE_IMAGE_INDEX).setScaleType(scaleType);
  }

  /**
   * Sets a new failure drawable with old scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   */
  public void setFailureImage(int resourceId) {
    setFailureImage(mResources.getDrawable(resourceId));
  }

  /**
   * Sets a new failure drawable with scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   * @param ScalingUtils.ScaleType a new scale type.
   */
  public void setFailureImage(int resourceId, ScalingUtils.ScaleType scaleType) {
    setFailureImage(mResources.getDrawable(resourceId), scaleType);
  }

  /** Sets a new retry drawable with old scale type. */
  public void setRetryImage(@Nullable Drawable drawable) {
    setChildDrawableAtIndex(RETRY_IMAGE_INDEX, drawable);
  }

  /** Sets a new retry drawable with scale type. */
  public void setRetryImage(Drawable drawable, ScalingUtils.ScaleType scaleType) {
    setChildDrawableAtIndex(RETRY_IMAGE_INDEX, drawable);
    getScaleTypeDrawableAtIndex(RETRY_IMAGE_INDEX).setScaleType(scaleType);
  }

  /**
   * Sets a new retry drawable with old scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   */
  public void setRetryImage(int resourceId) {
    setRetryImage(mResources.getDrawable(resourceId));
  }

  /**
   * Sets a new retry drawable with scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   * @param ScalingUtils.ScaleType a new scale type.
   */
  public void setRetryImage(int resourceId, ScalingUtils.ScaleType scaleType) {
    setRetryImage(mResources.getDrawable(resourceId), scaleType);
  }

  /** Sets a new progress bar drawable with old scale type. */
  public void setProgressBarImage(@Nullable Drawable drawable) {
    setChildDrawableAtIndex(PROGRESS_BAR_IMAGE_INDEX, drawable);
  }

  /** Sets a new progress bar drawable with scale type. */
  public void setProgressBarImage(Drawable drawable, ScalingUtils.ScaleType scaleType) {
    setChildDrawableAtIndex(PROGRESS_BAR_IMAGE_INDEX, drawable);
    getScaleTypeDrawableAtIndex(PROGRESS_BAR_IMAGE_INDEX).setScaleType(scaleType);
  }

  /**
   * Sets a new progress bar drawable with old scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   */
  public void setProgressBarImage(int resourceId) {
    setProgressBarImage(mResources.getDrawable(resourceId));
  }

  /**
   * Sets a new progress bar drawable with scale type.
   *
   * @param resourceId an identifier of an Android drawable or color resource.
   * @param ScalingUtils.ScaleType a new scale type.
   */
  public void setProgressBarImage(int resourceId, ScalingUtils.ScaleType scaleType) {
    setProgressBarImage(mResources.getDrawable(resourceId), scaleType);
  }

  /** Sets the background image if allowed. */
  public void setBackgroundImage(@Nullable Drawable drawable) {
    setChildDrawableAtIndex(BACKGROUND_IMAGE_INDEX, drawable);
  }

  /**
   * Sets a new overlay image at the specified index.
   *
   * <p>This method will throw if the given index is out of bounds.
   *
   * @param drawable background image
   */
  public void setOverlayImage(int index, @Nullable Drawable drawable) {
    // Note that overlays are by definition top-most and therefore the last elements in the array.
    Preconditions.checkArgument(
        index >= 0 && OVERLAY_IMAGES_INDEX + index < mFadeDrawable.getNumberOfLayers(),
        ""The given index does not correspond to an overlay image."");
    setChildDrawableAtIndex(OVERLAY_IMAGES_INDEX + index, drawable);
  }

  /** Sets the overlay image if allowed. */
  public void setOverlayImage(@Nullable Drawable drawable) {
    setOverlayImage(0, drawable);
  }

  /** Sets the rounding params. */
  public void setRoundingParams(@Nullable RoundingParams roundingParams) {
    mRoundingParams = roundingParams;
    WrappingUtils.updateOverlayColorRounding(mTopLevelDrawable, mRoundingParams);
    for (int i = 0; i < mFadeDrawable.getNumberOfLayers(); i++) {
      WrappingUtils.updateLeafRounding(getParentDrawableAtIndex(i), mRoundingParams, mResources);
    }
  }

  /** Gets the rounding params. */
  @Nullable
  public RoundingParams getRoundingParams() {
    return mRoundingParams;
  }

  @VisibleForTesting
  public boolean hasImage() {
    return mActualImageWrapper.getDrawable() != mEmptyActualImageDrawable;
  }

  public void setOnFadeListener(OnFadeListener onFadeListener) {
    mFadeDrawable.setOnFadeListener(onFadeListener);
  }
}
","focusPoint
"
